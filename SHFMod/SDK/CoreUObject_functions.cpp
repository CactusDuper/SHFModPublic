#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreUObject

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "CoreUObject_parameters.hpp"
#include <numbers>


namespace SDK
{

	FMatrix FMatrix::operator*(const FMatrix& Other) const {
		FMatrix Result;
		VectorMatrixMultiply(&Result, this, &Other);
		return Result;
	}

	void FMatrix::operator*=(const FMatrix& Other) {
		VectorMatrixMultiply(this, this, &Other);
	}

	FMatrix FMatrix::Inverse() const {
		if (GetScaledAxis(EAxis::X).IsNearlyZero(UE_SMALL_NUMBER) &&
			GetScaledAxis(EAxis::Y).IsNearlyZero(UE_SMALL_NUMBER) &&
			GetScaledAxis(EAxis::Z).IsNearlyZero(UE_SMALL_NUMBER)) {
			return {};
		}

		FMatrix Result;
		VectorMatrixInverse(&Result, this);
		return Result;
	}

	FVector4 FMatrix::TransformFVector4(const FVector4& P) const {
		FVector4 Result;
		VectorRegister4Double VecP = VectorLoadAligned(P.XYZW);
		VectorRegister4Double VecR = VectorTransformVector(VecP, this);
		VectorStoreAligned(VecR, Result.XYZW);
		return Result;
	}

	FQuat::FQuat(const FMatrix& M) {
		if (M.GetScaledAxis(EAxis::X).IsNearlyZero() || M.GetScaledAxis(EAxis::Y).IsNearlyZero() || M.GetScaledAxis(EAxis::Z).IsNearlyZero()) {
			*this = { 0.0, 0.0, 0.0, 1.0 };
			return;
		}

		double s;

		const double tr = M.M[0][0] + M.M[1][1] + M.M[2][2];

		if (tr > 0.0f) {
			double InvS = InvSqrt(tr + 1.0);
			this->W = double(0.5 * (1.0 / InvS));
			s = 0.5 * InvS;

			this->X = ((M.M[1][2] - M.M[2][1]) * s);
			this->Y = ((M.M[2][0] - M.M[0][2]) * s);
			this->Z = ((M.M[0][1] - M.M[1][0]) * s);
		}
		else {
			int32 i = 0;

			if (M.M[1][1] > M.M[0][0])
				i = 1;

			if (M.M[2][2] > M.M[i][i])
				i = 2;

			static constexpr int32 nxt[3] = { 1, 2, 0 };
			const int32 j = nxt[i];
			const int32 k = nxt[j];

			s = M.M[i][i] - M.M[j][j] - M.M[k][k] + 1.0;

			double InvS = InvSqrt(s);

			double qt[4];
			qt[i] = 0.5 * (1.0 / InvS);

			s = 0.5 * InvS;

			qt[3] = (M.M[j][k] - M.M[k][j]) * s;
			qt[j] = (M.M[i][j] + M.M[j][i]) * s;
			qt[k] = (M.M[i][k] + M.M[k][i]) * s;

			this->X = qt[0];
			this->Y = qt[1];
			this->Z = qt[2];
			this->W = qt[3];
		}
	}

	void FTransform::ConstructTransformFromMatrixWithDesiredScale(const FMatrix& AMatrix, const FMatrix& BMatrix, const FVector& DesiredScale, FTransform& OutTransform) const {
		FMatrix M = AMatrix * BMatrix;
		M.RemoveScaling();

		FVector SignedScale = DesiredScale.GetSignVector();

		M.SetAxis(0, M.GetScaledAxis(EAxis::X) * SignedScale.X);
		M.SetAxis(1, M.GetScaledAxis(EAxis::Y) * SignedScale.Y);
		M.SetAxis(2, M.GetScaledAxis(EAxis::Z) * SignedScale.Z);

		FQuat Rotation = FQuat(M);
		Rotation.Normalize();

		OutTransform.Scale3D = DesiredScale;
		OutTransform.Rotation = Rotation;
		OutTransform.Translation = M.GetOrigin();
	}

	FBoxSphereBounds FBoxSphereBounds::TransformBy(const FMatrix& M) const {
		FBoxSphereBounds Result;

		const VectorRegister4Double VecOrigin = VectorLoadFloat3(reinterpret_cast<const double*>(&Origin));
		const VectorRegister4Double VecExtent = VectorLoadFloat3(reinterpret_cast<const double*>(&BoxExtent));

		const VectorRegister4Double m0 = VectorLoadAligned(M.M[0]);
		const VectorRegister4Double m1 = VectorLoadAligned(M.M[1]);
		const VectorRegister4Double m2 = VectorLoadAligned(M.M[2]);
		const VectorRegister4Double m3 = VectorLoadAligned(M.M[3]);

		VectorRegister4Double NewOrigin = VectorMultiply(VectorReplicate(VecOrigin, 0), m0);
		NewOrigin = VectorMultiplyAdd(VectorReplicate(VecOrigin, 1), m1, NewOrigin);
		NewOrigin = VectorMultiplyAdd(VectorReplicate(VecOrigin, 2), m2, NewOrigin);
		NewOrigin = VectorAdd(NewOrigin, m3);

		VectorRegister4Double NewExtent = VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 0), m0));
		NewExtent = VectorAdd(NewExtent, VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 1), m1)));
		NewExtent = VectorAdd(NewExtent, VectorAbs(VectorMultiply(VectorReplicate(VecExtent, 2), m2)));

		VectorStoreFloat3(NewExtent, &(Result.BoxExtent.X));
		VectorStoreFloat3(NewOrigin, &(Result.Origin.X));

		VectorRegister4Double MaxRadius = VectorMultiply(m0, m0);
		MaxRadius = VectorMultiplyAdd(m1, m1, MaxRadius);
		MaxRadius = VectorMultiplyAdd(m2, m2, MaxRadius);
		MaxRadius = VectorMax(VectorMax(MaxRadius, VectorReplicate(MaxRadius, 1)), VectorReplicate(MaxRadius, 2));
		Result.SphereRadius = std::sqrt(VectorGetComponent(MaxRadius, 0)) * SphereRadius;

		double const BoxExtentMagnitude = std::sqrt(VectorDot3Scalar(NewExtent, NewExtent));
		Result.SphereRadius = std::min(Result.SphereRadius, BoxExtentMagnitude);

		return Result;
	}

	FBoxSphereBounds FBoxSphereBounds::TransformBy(const FTransform& M) const {
		const FMatrix Mat = M.ToMatrixWithScale();
		FBoxSphereBounds Result = TransformBy(Mat);
		return Result;
	}

	FRotator FQuat::ToRotator() const {
		const double SinR_CosP = 2 * (W * X + Y * Z);
		const double CosR_CosP = 1 - 2 * (X * X + Y * Y);
		const double Roll = std::atan2(SinR_CosP, CosR_CosP);

		const double SinP = 2 * (W * Y - Z * X);
		double Pitch;
		if (std::abs(SinP) >= 1)
			Pitch = std::copysign(std::numbers::pi / 2, SinP);
		else
			Pitch = std::asin(SinP);

		const double SinY_CosP = 2 * (W * Z + X * Y);
		const double CosY_CosP = 1 - 2 * (Y * Y + Z * Z);
		const double Yaw = std::atan2(SinY_CosP, CosY_CosP);

		return { Pitch * (180.0 / std::numbers::pi), Yaw * (180.0 / std::numbers::pi), Roll * (180.0 / std::numbers::pi) };
	}

// Predefined Function
// Finds a UObject in the global object array by name, optionally with ECastFlags to reduce heavy string comparison

class UObject* UObject::FindObjectFastImpl(const std::string& Name, EClassCastFlags RequiredType)
{
	for (int i = 0; i < GObjects->Num(); ++i)
	{
		UObject* Object = GObjects->GetByIndex(i);
	
		if (!Object)
			continue;
		
		if (Object->HasTypeFlag(RequiredType) && Object->GetName() == Name)
			return Object;
	}

	return nullptr;
}


// Predefined Function
// Finds a UObject in the global object array by full-name, optionally with ECastFlags to reduce heavy string comparison

class UObject* UObject::FindObjectImpl(const std::string& FullName, EClassCastFlags RequiredType)
{
	for (int i = 0; i < GObjects->Num(); ++i)
	{
		UObject* Object = GObjects->GetByIndex(i);
	
		if (!Object)
			continue;
		
		if (Object->HasTypeFlag(RequiredType) && Object->GetFullName() == FullName)
			return Object;
	}

	return nullptr;
}


// Predefined Function
// Returns the name of this object in the format 'Class Package.Outer.Object'

std::string UObject::GetFullName() const
{
	if (this && Class)
	{
		std::string Temp;

		for (UObject* NextOuter = Outer; NextOuter; NextOuter = NextOuter->Outer)
		{
			Temp = NextOuter->GetName() + "." + Temp;
		}

		std::string Name = Class->GetName();
		Name += " ";
		Name += Temp;
		Name += GetName();

		return Name;
	}

	return "None";
}


// Predefined Function
// Retuns the name of this object

std::string UObject::GetName() const
{
	return this ? Name.ToString() : "None";
}


// Predefined Function
// Checks Class->FunctionFlags for TypeFlags

bool UObject::HasTypeFlag(EClassCastFlags TypeFlags) const
{
	return (Class->CastFlags & TypeFlags);
}


// Predefined Function
// Checks a UObjects' type by TypeFlags

bool UObject::IsA(EClassCastFlags TypeFlags) const
{
	return (Class->CastFlags & TypeFlags);
}


// Predefined Function
// Checks a UObjects' type by Class name

bool UObject::IsA(const class FName& ClassName) const
{
	return Class->IsSubclassOf(ClassName);
}


// Predefined Function
// Checks a UObjects' type by Class

bool UObject::IsA(const class UClass* TypeClass) const
{
	return Class->IsSubclassOf(TypeClass);
}


// Predefined Function
// Checks whether this object is a classes' default-object

bool UObject::IsDefaultObject() const
{
	return (Flags & EObjectFlags::ClassDefaultObject);
}


// Function CoreUObject.Object.ExecuteUbergraph
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   EntryPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObject::ExecuteUbergraph(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Object", "ExecuteUbergraph");

	Params::Object_ExecuteUbergraph Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Predefined Function
// Checks if this class has a certain base

bool UStruct::IsSubclassOf(const UStruct* Base) const
{
	if (!Base)
		return false;

	for (const UStruct* Struct = this; Struct; Struct = Struct->Super)
	{
		if (Struct == Base)
			return true;
	}

	return false;
}


// Predefined Function
// Checks if this class has a certain base

bool UStruct::IsSubclassOf(const FName& baseClassName) const
{
	if (baseClassName.IsNone())
		return false;

	for (const UStruct* Struct = this; Struct; Struct = Struct->Super)
	{
		if (Struct->Name == baseClassName)
			return true;
	}

	return false;
}


// Predefined Function
// Gets a UFunction from this UClasses' 'Children' list

class UFunction* UClass::GetFunction(const char* ClassName, const char* FuncName) const
{
	for(const UStruct* Clss = this; Clss; Clss = Clss->Super)
	{
		if (Clss->GetName() != ClassName)
			continue;
			
		for (UField* Field = Clss->Children; Field; Field = Field->Next)
		{
			if(Field->HasTypeFlag(EClassCastFlags::Function) && Field->GetName() == FuncName)
				return static_cast<class UFunction*>(Field);
		}
	}

	return nullptr;
}

}

