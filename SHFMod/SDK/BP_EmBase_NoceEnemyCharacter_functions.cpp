#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_EmBase_NoceEnemyCharacter

#include "Basic.hpp"

#include "BP_EmBase_NoceEnemyCharacter_classes.hpp"
#include "BP_EmBase_NoceEnemyCharacter_parameters.hpp"


namespace SDK
{

// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.BndEvt__BP_EmBase_NoceEnemyCharacter_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::BndEvt__BP_EmBase_NoceEnemyCharacter_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "BndEvt__BP_EmBase_NoceEnemyCharacter_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentHitSignature__DelegateSignature");

	Params::BP_EmBase_NoceEnemyCharacter_C_BndEvt__BP_EmBase_NoceEnemyCharacter_CapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.BndEvt__BP_EmBase_NoceEnemyCharacter_Mesh_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::BndEvt__BP_EmBase_NoceEnemyCharacter_Mesh_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "BndEvt__BP_EmBase_NoceEnemyCharacter_Mesh_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature");

	Params::BP_EmBase_NoceEnemyCharacter_C_BndEvt__BP_EmBase_NoceEnemyCharacter_Mesh_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.Claculate Wince Type
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENoceWinceType                          InWinceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENoceWinceType*                         RetWinceType                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::Claculate_Wince_Type(ENoceWinceType InWinceType, ENoceWinceType* RetWinceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "Claculate Wince Type");

	Params::BP_EmBase_NoceEnemyCharacter_C_Claculate_Wince_Type Parms{};

	Parms.InWinceType = InWinceType;

	UObject::ProcessEvent(Func, &Parms);

	if (RetWinceType != nullptr)
		*RetWinceType = Parms.RetWinceType;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.Die_BP
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_EmBase_NoceEnemyCharacter_C::Die_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "Die_BP");

	Params::BP_EmBase_NoceEnemyCharacter_C_Die_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.ExecuteUbergraph_BP_EmBase_NoceEnemyCharacter
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::ExecuteUbergraph_BP_EmBase_NoceEnemyCharacter(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "ExecuteUbergraph_BP_EmBase_NoceEnemyCharacter");

	Params::BP_EmBase_NoceEnemyCharacter_C_ExecuteUbergraph_BP_EmBase_NoceEnemyCharacter Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.FadeIn
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.FadeOut
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "FadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.GetDebugShowLinkMotionInfo
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::GetDebugShowLinkMotionInfo(bool* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "GetDebugShowLinkMotionInfo");

	Params::BP_EmBase_NoceEnemyCharacter_C_GetDebugShowLinkMotionInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.GetEnemyHealthBarInfo
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName*                            ParentSocketName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         RelativeLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::GetEnemyHealthBarInfo(class FName* ParentSocketName, struct FVector* RelativeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "GetEnemyHealthBarInfo");

	Params::BP_EmBase_NoceEnemyCharacter_C_GetEnemyHealthBarInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ParentSocketName != nullptr)
		*ParentSocketName = Parms.ParentSocketName;

	if (RelativeLocation != nullptr)
		*RelativeLocation = std::move(Parms.RelativeLocation);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.Handle Optimization Mode
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Start_Optimization                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::Handle_Optimization_Mode(bool Start_Optimization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "Handle Optimization Mode");

	Params::BP_EmBase_NoceEnemyCharacter_C_Handle_Optimization_Mode Parms{};

	Parms.Start_Optimization = Start_Optimization;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_ApplySplineTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 SplineComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_ApplySplineTarget(class USplineComponent* SplineComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_ApplySplineTarget");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_ApplySplineTarget Parms{};

	Parms.SplineComp = SplineComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_ArriveSplineDestination
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_ArriveSplineDestination()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_ArriveSplineDestination");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_CanFollowSpline
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   FollowSpline                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_CanFollowSpline(bool* FollowSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_CanFollowSpline");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_CanFollowSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FollowSpline != nullptr)
		*FollowSpline = Parms.FollowSpline;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_ClearSplineTarget
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_ClearSplineTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_ClearSplineTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_CustomEvent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PatternName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Parameter                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_CustomEvent(class FName PatternName, double Parameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_CustomEvent");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_CustomEvent Parms{};

	Parms.PatternName = PatternName;
	Parms.Parameter = Parameter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_DebugBeahivourRemoveComp
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UActorComponent*                  In                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_DebugBeahivourRemoveComp(class UActorComponent* In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_DebugBeahivourRemoveComp");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_DebugBeahivourRemoveComp Parms{};

	Parms.In = In;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEMBase_EnableMeshCollisionToPlayer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InEnable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEMBase_EnableMeshCollisionToPlayer(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEMBase_EnableMeshCollisionToPlayer");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEMBase_EnableMeshCollisionToPlayer Parms{};

	Parms.InEnable = InEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetCurBaseMovementSpeed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 BaseSpeed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetCurBaseMovementSpeed(double* BaseSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetCurBaseMovementSpeed");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetCurBaseMovementSpeed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BaseSpeed != nullptr)
		*BaseSpeed = Parms.BaseSpeed;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetDefaultCapusleSetting
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 HalfHeight                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<ECollisionChannel, ECollisionResponse>*Response                                               (Parm, OutParm)
// ECollisionChannel*                      ObjectType                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetDefaultCapusleSetting(double* Radius, double* HalfHeight, TMap<ECollisionChannel, ECollisionResponse>* Response, ECollisionChannel* ObjectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetDefaultCapusleSetting");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetDefaultCapusleSetting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Radius != nullptr)
		*Radius = Parms.Radius;

	if (HalfHeight != nullptr)
		*HalfHeight = Parms.HalfHeight;

	if (Response != nullptr)
		*Response = std::move(Parms.Response);

	if (ObjectType != nullptr)
		*ObjectType = Parms.ObjectType;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetDefaultSpawnMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage**                    SpawnMontage                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetDefaultSpawnMontage(class UAnimMontage** SpawnMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetDefaultSpawnMontage");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetDefaultSpawnMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnMontage != nullptr)
		*SpawnMontage = Parms.SpawnMontage;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetIsCurrentOptimized
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Bool                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetIsCurrentOptimized(bool* Bool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetIsCurrentOptimized");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetIsCurrentOptimized Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bool != nullptr)
		*Bool = Parms.Bool;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetIsStrafe
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsStrafe_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetIsStrafe(bool* IsStrafe_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetIsStrafe");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetIsStrafe Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsStrafe_0 != nullptr)
		*IsStrafe_0 = Parms.IsStrafe_0;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetLocoTurnMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage**                    outMTG                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetLocoTurnMontage(int32 Index_0, class UAnimMontage** outMTG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetLocoTurnMontage");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetLocoTurnMontage Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (outMTG != nullptr)
		*outMTG = Parms.outMTG;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetPivotTurnMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  QuickTurnDegree                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  LongTurnDegree                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   TargetLoc                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage**                    TurnMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetPivotTurnMontage(double QuickTurnDegree, double LongTurnDegree, const struct FVector& TargetLoc, class UAnimMontage** TurnMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetPivotTurnMontage");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetPivotTurnMontage Parms{};

	Parms.QuickTurnDegree = QuickTurnDegree;
	Parms.LongTurnDegree = LongTurnDegree;
	Parms.TargetLoc = std::move(TargetLoc);

	UObject::ProcessEvent(Func, &Parms);

	if (TurnMontage != nullptr)
		*TurnMontage = Parms.TurnMontage;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetSplineTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent**                SplineComp                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetSplineTarget(class USplineComponent** SplineComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetSplineTarget");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetSplineTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SplineComp != nullptr)
		*SplineComp = Parms.SplineComp;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetStrafeDirectionMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENoceHitReactionFourWayType             Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage**                    Montage                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetStrafeDirectionMontage(ENoceHitReactionFourWayType Direction, class UAnimMontage** Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetStrafeDirectionMontage");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetStrafeDirectionMontage Parms{};

	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	if (Montage != nullptr)
		*Montage = Parms.Montage;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_GetUsedNavData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARecastNavMesh**                  NavData                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_GetUsedNavData(class ARecastNavMesh** NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_GetUsedNavData");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_GetUsedNavData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NavData != nullptr)
		*NavData = Parms.NavData;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_HandleDialogWhenDamaged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENoceWinceType                          WinceType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_HandleDialogWhenDamaged(ENoceWinceType WinceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_HandleDialogWhenDamaged");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_HandleDialogWhenDamaged Parms{};

	Parms.WinceType = WinceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_HandleHitByFriend
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      NoceHitResult                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_HandleHitByFriend(const struct FNoceAttackHitResult& NoceHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_HandleHitByFriend");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_HandleHitByFriend Parms{};

	Parms.NoceHitResult = std::move(NoceHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_HandleSpawnerTeleportEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   DestLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  DestRoration                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_HandleSpawnerTeleportEvent(const struct FVector& DestLocation, const struct FRotator& DestRoration, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_HandleSpawnerTeleportEvent");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_HandleSpawnerTeleportEvent Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRoration = std::move(DestRoration);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_IsInPlayerCamDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Bool                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_IsInPlayerCamDirection(bool* Bool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_IsInPlayerCamDirection");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_IsInPlayerCamDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bool != nullptr)
		*Bool = Parms.Bool;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_IsPauseFollowSpline
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Pause                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_IsPauseFollowSpline(bool* Pause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_IsPauseFollowSpline");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_IsPauseFollowSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Pause != nullptr)
		*Pause = Parms.Pause;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_OverrideLocoBaseSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  BaseSpeed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_OverrideLocoBaseSpeed(double BaseSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_OverrideLocoBaseSpeed");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_OverrideLocoBaseSpeed Parms{};

	Parms.BaseSpeed = BaseSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_PlayMontageFromAnimBank
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   BankID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MotionID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 duration                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_PlayMontageFromAnimBank(int32 BankID, int32 MotionID, double* duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_PlayMontageFromAnimBank");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_PlayMontageFromAnimBank Parms{};

	Parms.BankID = BankID;
	Parms.MotionID = MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (duration != nullptr)
		*duration = Parms.duration;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_RandomFient
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Dilation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimSequenceBase*                Anim                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_RandomFient(double duration, double Dilation, class UAnimSequenceBase* Anim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_RandomFient");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_RandomFient Parms{};

	Parms.duration = duration;
	Parms.Dilation = Dilation;
	Parms.Anim = Anim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SendAudioTrigger
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AudioTriggerName                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SendAudioTrigger(class FName AudioTriggerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SendAudioTrigger");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SendAudioTrigger Parms{};

	Parms.AudioTriggerName = AudioTriggerName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetEnableLookAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FNoceAILookAtSetting&      LookAtSetting                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetEnableLookAt(bool Enable, const struct FNoceAILookAtSetting& LookAtSetting, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetEnableLookAt");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetEnableLookAt Parms{};

	Parms.Enable = Enable;
	Parms.LookAtSetting = std::move(LookAtSetting);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetFaceToTargetInfo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceAIFaceToTargetInfo&   Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetFaceToTargetInfo(const struct FNoceAIFaceToTargetInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetFaceToTargetInfo");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetFaceToTargetInfo Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetFocusActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsStrafe_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           FocusActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetFocusActor(bool IsStrafe_0, class AActor* FocusActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetFocusActor");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetFocusActor Parms{};

	Parms.IsStrafe_0 = IsStrafe_0;
	Parms.FocusActor = FocusActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetFocusPoint
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsStrafe_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   FocusLoc                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetFocusPoint(bool IsStrafe_0, const struct FVector& FocusLoc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetFocusPoint");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetFocusPoint Parms{};

	Parms.IsStrafe_0 = IsStrafe_0;
	Parms.FocusLoc = std::move(FocusLoc);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetHopeNotMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HopeNotMove                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetHopeNotMove(bool HopeNotMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetHopeNotMove");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetHopeNotMove Parms{};

	Parms.HopeNotMove = HopeNotMove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_SetMaxLookDistance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxLookDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_SetMaxLookDistance(bool Enable, double MaxLookDistance, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_SetMaxLookDistance");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_SetMaxLookDistance Parms{};

	Parms.Enable = Enable;
	Parms.MaxLookDistance = MaxLookDistance;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_ShootProjectile
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PatternName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_ShootProjectile(class FName PatternName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_ShootProjectile");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_ShootProjectile Parms{};

	Parms.PatternName = PatternName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_TriggerLinkAbility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   LinkTarget                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             ExAbilityName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_TriggerLinkAbility(class ANoceCharacter* LinkTarget, class FName ExAbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_TriggerLinkAbility");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_TriggerLinkAbility Parms{};

	Parms.LinkTarget = LinkTarget;
	Parms.ExAbilityName = ExAbilityName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_UpdateAdditionalCollisionTransform
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_UpdateAdditionalCollisionTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_UpdateAdditionalCollisionTransform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_UpdateBaseMovementSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  BaseSpeed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_UpdateBaseMovementSpeed(double BaseSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_UpdateBaseMovementSpeed");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_UpdateBaseMovementSpeed Parms{};

	Parms.BaseSpeed = BaseSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_UpdateLocomotionOffset
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_UpdateLocomotionOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_UpdateLocomotionOffset");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_UpdateLocomotionOffset Parms{};

	Parms.Offset = std::move(Offset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IEmBase_UpdateModifiedMovementSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Modifier                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IEmBase_UpdateModifiedMovementSpeed(double Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IEmBase_UpdateModifiedMovementSpeed");

	Params::BP_EmBase_NoceEnemyCharacter_C_IEmBase_UpdateModifiedMovementSpeed Parms{};

	Parms.Modifier = Modifier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.InitCapsuleCollisionSetting
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::InitCapsuleCollisionSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "InitCapsuleCollisionSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.InitialLocomotionMovement
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::InitialLocomotionMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "InitialLocomotionMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.InitNavSetting
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::InitNavSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "InitNavSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IsHealthAlive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Alive                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IsHealthAlive(bool* Alive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IsHealthAlive");

	Params::BP_EmBase_NoceEnemyCharacter_C_IsHealthAlive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Alive != nullptr)
		*Alive = Parms.Alive;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IsLockHealth
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsLimit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IsLockHealth(bool* IsLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IsLockHealth");

	Params::BP_EmBase_NoceEnemyCharacter_C_IsLockHealth Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsLimit != nullptr)
		*IsLimit = Parms.IsLimit;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.IsLockWince
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsLimit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::IsLockWince(bool* IsLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "IsLockWince");

	Params::BP_EmBase_NoceEnemyCharacter_C_IsLockWince Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsLimit != nullptr)
		*IsLimit = Parms.IsLimit;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnAttackHitFriend
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      NoceHitResult                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::OnAttackHitFriend(const struct FNoceAttackHitResult& NoceHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnAttackHitFriend");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnAttackHitFriend Parms{};

	Parms.NoceHitResult = std::move(NoceHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnAttackTraceGrappleHit
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&HitResults                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::OnAttackTraceGrappleHit(const TArray<struct FNoceAttackHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnAttackTraceGrappleHit");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnAttackTraceGrappleHit Parms{};

	Parms.HitResults = std::move(HitResults);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnAttackTraceHit
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&HitResults                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void ABP_EmBase_NoceEnemyCharacter_C::OnAttackTraceHit(const TArray<struct FNoceAttackHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnAttackTraceHit");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnAttackTraceHit Parms{};

	Parms.HitResults = std::move(HitResults);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnBodyPartBreak
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PartName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::OnBodyPartBreak(class FName PartName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnBodyPartBreak");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnBodyPartBreak Parms{};

	Parms.PartName = PartName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnDamaged_BP
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      AttackHitResult                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_EmBase_NoceEnemyCharacter_C::OnDamaged_BP(const struct FNoceAttackHitResult& AttackHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnDamaged_BP");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnDamaged_BP Parms{};

	Parms.AttackHitResult = std::move(AttackHitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnDamaged_ForceEnableAI
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::OnDamaged_ForceEnableAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnDamaged_ForceEnableAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnDamaged_MontageBlendOut
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::OnDamaged_MontageBlendOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnDamaged_MontageBlendOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.OnPostSignificance
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float                                   Significance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::OnPostSignificance(class ANoceCharacter* Character, float Significance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "OnPostSignificance");

	Params::BP_EmBase_NoceEnemyCharacter_C_OnPostSignificance Parms{};

	Parms.Character = Character;
	Parms.Significance = Significance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "ReceiveTick");

	Params::BP_EmBase_NoceEnemyCharacter_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.SetupEnemyHealthBar
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::SetupEnemyHealthBar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "SetupEnemyHealthBar");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.StartAutoDestory
// (BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::StartAutoDestory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "StartAutoDestory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.TryGetUsedNavData
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::TryGetUsedNavData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "TryGetUsedNavData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.TryInitNavData
// (BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::TryInitNavData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "TryInitNavData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.Update Push Offset
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EmBase_NoceEnemyCharacter_C::Update_Push_Offset(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "Update Push Offset");

	Params::BP_EmBase_NoceEnemyCharacter_C_Update_Push_Offset Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.UpdateCharacterMovement
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::UpdateCharacterMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "UpdateCharacterMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EmBase_NoceEnemyCharacter.BP_EmBase_NoceEnemyCharacter_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_EmBase_NoceEnemyCharacter_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EmBase_NoceEnemyCharacter_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

