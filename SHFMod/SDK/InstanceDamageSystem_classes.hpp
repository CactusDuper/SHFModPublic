#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InstanceDamageSystem

#include "Basic.hpp"

#include "InstanceDamageSystem_structs.hpp"
#include "Foliage_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class InstanceDamageSystem.DamageableFoliageISMC
// 0x0030 (0x0B80 - 0x0B50)
class UDamageableFoliageISMC final : public UFoliageInstancedStaticMeshComponent
{
public:
	TSoftObjectPtr<class UInstancedStaticMeshComponent> ServerReference;                             // 0x0B50(0x0028)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, InstancedReference, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecieveBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void RecieveHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void RecievePointDamage(int32 InstanceIndex, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void RecieveRadialDamage(const TArray<int32>& Instances, const TArray<float>& Damages, class AController* InstigatedBy, const struct FVector& Origin, float MaxRadius, const class UDamageType* DamageType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("DamageableFoliageISMC")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"DamageableFoliageISMC")
	}
	static class UDamageableFoliageISMC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageableFoliageISMC>();
	}
};
DUMPER7_ASSERTS_UDamageableFoliageISMC;

// Class InstanceDamageSystem.InstanceDamageCoreInterface
// 0x0000 (0x0000 - 0x0000)
class IInstanceDamageCoreInterface final
{
public:
	bool GetInstanceID(struct FInstanceID* OutInstanceID);
	bool GetPointDamageTraceTypes(TArray<EObjectTypeQuery>* OutObjectTypes);
	void GetTargetMesh(TSoftObjectPtr<class UStaticMesh>* TargetMesh);
	void PoolBeginPlay();
	void SetInstanceInfo(const struct FInstanceID& NewInstanceID, const TSoftObjectPtr<class UStaticMesh>& TargetMesh);
	bool SwitchToInstMeshOnEndPlay();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageCoreInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageCoreInterface")
	}
	static class IInstanceDamageCoreInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInstanceDamageCoreInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IInstanceDamageCoreInterface;

// Class InstanceDamageSystem.InstanceDamageRepHelperInterface
// 0x0000 (0x0000 - 0x0000)
class IInstanceDamageRepHelperInterface final
{
public:
	TSoftObjectPtr<class UInstancedStaticMeshComponent> GetLocalInstCompReference(const TSoftObjectPtr<class UInstancedStaticMeshComponent>& ServerRef);
	TSoftObjectPtr<class UInstancedStaticMeshComponent> GetServerInstCompReference();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageRepHelperInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageRepHelperInterface")
	}
	static class IInstanceDamageRepHelperInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInstanceDamageRepHelperInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IInstanceDamageRepHelperInterface;

// Class InstanceDamageSystem.InstanceDamageReplication
// 0x0020 (0x00C0 - 0x00A0)
class UInstanceDamageReplication final : public UActorComponent
{
public:
	TArray<TSoftObjectPtr<class UInstancedStaticMeshComponent>> ReplicatedUpdatedComponents;         // 0x00A0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FHiddenInstancesInfo>           ReplicatedHiddenInstances;                         // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_HiddenInstances(const TArray<struct FHiddenInstancesInfo>& PreRepHiddenInstances);
	void OnVisibilityUpdate(const struct FInstanceID& InstanceID, bool bIsVisible, EInstanceVisibilityInstigatorType InstigatorType, class AController* InstigatedBy, class UObject* Causer);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageReplication")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageReplication")
	}
	static class UInstanceDamageReplication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstanceDamageReplication>();
	}
};
DUMPER7_ASSERTS_UInstanceDamageReplication;

// Class InstanceDamageSystem.InstanceDamageSettings
// 0x0038 (0x0070 - 0x0038)
class UInstanceDamageSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UDataTable>              SetupInfoTable;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalTimeInterval;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimeInterval;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceCustomDataLocalVisibilityIndex;            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDistance;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageSettings")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageSettings")
	}
	static class UInstanceDamageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstanceDamageSettings>();
	}
};
DUMPER7_ASSERTS_UInstanceDamageSettings;

// Class InstanceDamageSystem.InstanceDamageSubsystem
// 0x0168 (0x0198 - 0x0030)
class UInstanceDamageSubsystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FInstanceID& InstanceID, bool bIsVisible, EInstanceVisibilityInstigatorType ToggleInstigatorType, class AController* InstigatedBy, class UObject* Causer)> OnInstanceVisibilityToggleDelegate; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TSoftObjectPtr<class UInstancedStaticMeshComponent>& InstancedMesh, const TArray<int32>& RespawnedIndexes)> OnInstancesRespawnDelegate; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FInstanceID& InstanceID, class AActor* Destructible, const TSoftObjectPtr<class UStaticMesh>& TargetMesh, bool bReusedFromPool, class AActor* Causer, class AController* InstigatedBy)> OnDestructibleSpawnedDelegate; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDebugToggledDelegate;                            // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInstanceDamageSettings*                Settings;                                          // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UInstancedStaticMeshComponent>> UpdatedComponents;                   // 0x0078(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UStaticMesh>, struct FIDSSetupInfo> SetupInfoMap;                      // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xC0];                                      // 0x00D8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInstancedMesh(TSoftObjectPtr<class UInstancedStaticMeshComponent> InstMesh);
	class AActor* FindDestructibleByID(const struct FInstanceID& InstanceID, TSoftObjectPtr<class UStaticMesh> TargetMesh);
	void ForceVisibilityUpdate(TSoftObjectPtr<class UInstancedStaticMeshComponent> SingleTarget);
	void GetHiddenInstances(TArray<struct FHiddenInstancesInfo>* OutHiddenInstances);
	void GetRemovalTimer(struct FTimerHandle* OutTimerHandle);
	void GetRespawnTimer(struct FTimerHandle* OutTimerHandle);
	void HandleDestructibleRemoval(class AActor* Actor, EEndPlayReason EndPlayReason);
	void HideInstance(const struct FInstanceID& InstanceID, EInstanceVisibilityInstigatorType InstigatorType, class AController* InstigatedBy, class UObject* Causer);
	void IDSReset();
	void OnInstBeginOverlap(const class UInstancedStaticMeshComponent* InstancedMesh, class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnInstHit(const class UInstancedStaticMeshComponent* InstancedMesh, class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnInstPointDamage(const struct FInstanceID& InstanceID, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void OnInstRadialDamage(const class UInstancedStaticMeshComponent* InstancedMesh, const TArray<int32>& Instances, const TArray<float>& Damages, class AController* InstigatedBy, const struct FVector& Origin, float MaxRadius, const class UDamageType* DamageType, class AActor* DamageCauser);
	void OnInstRadialDamageWorkaround(const struct FHitResult& HitResult, float DamageRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class AController* InstigatedBy, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageType);
	void OnRemoval();
	void OnRespawn();
	void RemoveInstancedMesh(TSoftObjectPtr<class UInstancedStaticMeshComponent> InstMesh);
	void RespawnInstances(bool bRespawnLoaded);
	void RestoreSavedInfo(const TArray<struct FHiddenInstancesInfo>& StoredInfo);
	void SetReplicationComp(class UInstanceDamageReplication* RepComp);
	void ShowInstance(const struct FInstanceID& InstanceID, EInstanceVisibilityInstigatorType InstigatorType, class AController* InstigatedBy, class UObject* Causer);
	void ShowInstancesSingleMesh(const struct FHiddenInstancesInfo& InstancesInfo, EInstanceVisibilityInstigatorType InstigatorType, class AController* InstigatedBy, class UObject* Causer);
	void ToggleDebug();
	void ToggleInstanceVisibility(const struct FInstanceID& InstanceID, bool bVisible, EInstanceVisibilityInstigatorType ToggleInstigatorType, class AController* Instigator, class UObject* Causer);

	const struct FIDSSetupInfo GetSetup(const TSoftObjectPtr<class UStaticMesh>& TargetMesh) const;
	bool IsDebugOn() const;
	bool IsInstanceHidden(const struct FInstanceID& InstanceID) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageSubsystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageSubsystem")
	}
	static class UInstanceDamageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstanceDamageSubsystem>();
	}
};
DUMPER7_ASSERTS_UInstanceDamageSubsystem;

// Class InstanceDamageSystem.InstanceDamageStatics
// 0x0000 (0x0028 - 0x0028)
class UInstanceDamageStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool AreSoftSubobjectsEqual(class AActor* WorldContextObject, const TSoftObjectPtr<class UObject>& First, const TSoftObjectPtr<class UObject>& Second);
	static bool ComponentIsDamageableFrom(class UPrimitiveComponent* VictimComp, const struct FVector& Origin, class AActor* IgnoredActor, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, struct FHitResult* OutHitResult);
	static bool GetClosestPlayerLocation(class UObject* WorldContextObject, const struct FVector& StartLocation, struct FVector* OutLocation);
	static float GetInstancedMeshCustomData(class UInstancedStaticMeshComponent* InstMesh, int32 InstanceIndex, int32 CustomDataIndex);
	static float GetMass(const class UObject* WorldContextObject, class UPrimitiveComponent* Primitive, class FName BoneName);
	static class FString InstanceIDToString(const struct FInstanceID& InstanceID);
	static bool IsAnyPlayerInRange(class UObject* WorldContextObject, const struct FVector& InTestLocation, float Range);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("InstanceDamageStatics")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"InstanceDamageStatics")
	}
	static class UInstanceDamageStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstanceDamageStatics>();
	}
};
DUMPER7_ASSERTS_UInstanceDamageStatics;

}

