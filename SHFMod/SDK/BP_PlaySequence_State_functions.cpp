#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlaySequence_State

#include "Basic.hpp"

#include "BP_PlaySequence_State_classes.hpp"
#include "BP_PlaySequence_State_parameters.hpp"


namespace SDK
{

// Function BP_PlaySequence_State.BP_PlaySequence_State_C.WaitingSkipStateFinish
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::WaitingSkipStateFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "WaitingSkipStateFinish");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.UpdateHinaMeshType
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::UpdateHinaMeshType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "UpdateHinaMeshType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.UnregisterCutsceneWidget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::UnregisterCutsceneWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "UnregisterCutsceneWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.UnbindCallBack
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::UnbindCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "UnbindCallBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SolvePhysicsPopping
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   InChar                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bResetPhysics                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::SolvePhysicsPopping(class ANoceCharacter* InChar, bool bResetPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SolvePhysicsPopping");

	Params::BP_PlaySequence_State_C_SolvePhysicsPopping Parms{};

	Parms.InChar = InChar;
	Parms.bResetPhysics = bResetPhysics;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.ShowGreyboxObjects
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InHide                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::ShowGreyboxObjects(bool InHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "ShowGreyboxObjects");

	Params::BP_PlaySequence_State_C_ShowGreyboxObjects Parms{};

	Parms.InHide = InHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SetupType
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::SetupType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SetupType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SetupActorReference
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::SetupActorReference()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SetupActorReference");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SetPlayerViewRotationToCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  InYawOffset                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::SetPlayerViewRotationToCharacter(double InYawOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SetPlayerViewRotationToCharacter");

	Params::BP_PlaySequence_State_C_SetPlayerViewRotationToCharacter Parms{};

	Parms.InYawOffset = InYawOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SetPlayerViewRotation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRotator&                  InRotation                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_PlaySequence_State_C::SetPlayerViewRotation(const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SetPlayerViewRotation");

	Params::BP_PlaySequence_State_C_SetPlayerViewRotation Parms{};

	Parms.InRotation = std::move(InRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.SetPlayerInCutscene
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InValue                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::SetPlayerInCutscene(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "SetPlayerInCutscene");

	Params::BP_PlaySequence_State_C_SetPlayerInCutscene Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_LastShotStart_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// double                                  InYawOffset                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableCallBlendEvent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_LastShotStart_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller, double InYawOffset, bool EnableCallBlendEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_LastShotStart_Event");

	Params::BP_PlaySequence_State_C_Seamless_LastShotStart_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);
	Parms.InYawOffset = InYawOffset;
	Parms.EnableCallBlendEvent = EnableCallBlendEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_LastCharBlendStart_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_LastCharBlendStart_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_LastCharBlendStart_Event");

	Params::BP_PlaySequence_State_C_Seamless_LastCharBlendStart_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_LastCamBlendStart_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// double                                  InYawOffset                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableYawOffset                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnableCallBlendEvent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_LastCamBlendStart_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller, double InYawOffset, bool EnableYawOffset, bool EnableCallBlendEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_LastCamBlendStart_Event");

	Params::BP_PlaySequence_State_C_Seamless_LastCamBlendStart_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);
	Parms.InYawOffset = InYawOffset;
	Parms.EnableYawOffset = EnableYawOffset;
	Parms.EnableCallBlendEvent = EnableCallBlendEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_IntroShotEnd_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_IntroShotEnd_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_IntroShotEnd_Event");

	Params::BP_PlaySequence_State_C_Seamless_IntroShotEnd_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_IntroCharBlendEnd_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_IntroCharBlendEnd_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_IntroCharBlendEnd_Event");

	Params::BP_PlaySequence_State_C_Seamless_IntroCharBlendEnd_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_IntroCamBlendEnd_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_IntroCamBlendEnd_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_IntroCamBlendEnd_Event");

	Params::BP_PlaySequence_State_C_Seamless_IntroCamBlendEnd_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_Exit_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_Exit_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_Exit_Event");

	Params::BP_PlaySequence_State_C_Seamless_Exit_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_Enter_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    WeaponShow                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_Enter_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller, bool WeaponShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_Enter_Event");

	Params::BP_PlaySequence_State_C_Seamless_Enter_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);
	Parms.WeaponShow = WeaponShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_BeforeEnter_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_BeforeEnter_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_BeforeEnter_Event");

	Params::BP_PlaySequence_State_C_Seamless_BeforeEnter_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Seamless_AfterExit_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   NoceChar                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Debug_Caller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::Seamless_AfterExit_Event(class ANoceCharacter* NoceChar, const class FString& Debug_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Seamless_AfterExit_Event");

	Params::BP_PlaySequence_State_C_Seamless_AfterExit_Event Parms{};

	Parms.NoceChar = NoceChar;
	Parms.Debug_Caller = std::move(Debug_Caller);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.RetryStateBegin
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::RetryStateBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "RetryStateBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.RetryPrepareSequence
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::RetryPrepareSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "RetryPrepareSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Register Cutscene Widget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::Register_Cutscene_Widget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Register Cutscene Widget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.PrepareSequence
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::PrepareSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "PrepareSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.PlaySequence
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::PlaySequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "PlaySequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.PlaySeqInGame
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::PlaySeqInGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "PlaySeqInGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnStateUpdate
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::OnStateUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnStateUpdate");

	Params::BP_PlaySequence_State_C_OnStateUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnStateEnd
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnStateEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnStateEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnStateBegin
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnStateBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnStateBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnSequenceStop
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnSequenceStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnSequenceStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnSequenceLoadFailed
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnSequenceLoadFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnSequenceLoadFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnSequenceLoaded
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnSequenceLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnSequenceLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnSequenceGoEnded
// (Protected, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnSequenceGoEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnSequenceGoEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnResetFromPrepareSeq
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnResetFromPrepareSeq()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnResetFromPrepareSeq");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnResetFromPlaySeq
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnResetFromPlaySeq()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnResetFromPlaySeq");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnRenderType_PreviewMode
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnRenderType_PreviewMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnRenderType_PreviewMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnRenderType_InGamePure
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnRenderType_InGamePure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnRenderType_InGamePure");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnRenderType_InGame
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnRenderType_InGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnRenderType_InGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnRenderType_InfoTip
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnRenderType_InfoTip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnRenderType_InfoTip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnRenderType_HDRRendering
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnRenderType_HDRRendering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnRenderType_HDRRendering");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnReceiveSkipEvent
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnReceiveSkipEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnReceiveSkipEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnPostEdit
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      PropertyName                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::OnPostEdit(const class FName& PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnPostEdit");

	Params::BP_PlaySequence_State_C_OnPostEdit Parms{};

	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnPlay
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnLoaded_0F28732841521FD2D7F5048378E7D499
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::OnLoaded_0F28732841521FD2D7F5048378E7D499(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnLoaded_0F28732841521FD2D7F5048378E7D499");

	Params::BP_PlaySequence_State_C_OnLoaded_0F28732841521FD2D7F5048378E7D499 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnExecutorFinishedDelegate_clear
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMoviePipelineExecutorBase*       PipelineExecutor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bSuccess                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::OnExecutorFinishedDelegate_clear(class UMoviePipelineExecutorBase* PipelineExecutor, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnExecutorFinishedDelegate_clear");

	Params::BP_PlaySequence_State_C_OnExecutorFinishedDelegate_clear Parms{};

	Parms.PipelineExecutor = PipelineExecutor;
	Parms.bSuccess = bSuccess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnDestroyLevelSeqActor
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnDestroyLevelSeqActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnDestroyLevelSeqActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnComplete_DDD7C0A74CF21D39A382F2A5A0492FC3
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::OnComplete_DDD7C0A74CF21D39A382F2A5A0492FC3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnComplete_DDD7C0A74CF21D39A382F2A5A0492FC3");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.OnCameraCut
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::OnCameraCut(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "OnCameraCut");

	Params::BP_PlaySequence_State_C_OnCameraCut Parms{};

	Parms.CameraComponent = CameraComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.NotifyAI Start Sequence
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::NotifyAI_Start_Sequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "NotifyAI Start Sequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.NotifyAI End Sequence
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::NotifyAI_End_Sequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "NotifyAI End Sequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.MontageStopForReBindings
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::MontageStopForReBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "MontageStopForReBindings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.LockFPS
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    FPS                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::LockFPS(const class FString& FPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "LockFPS");

	Params::BP_PlaySequence_State_C_LockFPS Parms{};

	Parms.FPS = std::move(FPS);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.HandleStreaming
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Streaming                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::HandleStreaming(bool* Streaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "HandleStreaming");

	Params::BP_PlaySequence_State_C_HandleStreaming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Streaming != nullptr)
		*Streaming = Parms.Streaming;
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.HandleSkipComplete
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::HandleSkipComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "HandleSkipComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.HandleSkipBlackTime
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::HandleSkipBlackTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "HandleSkipBlackTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.HandleShowHidePlayer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SequenceStart                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::HandleShowHidePlayer(bool SequenceStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "HandleShowHidePlayer");

	Params::BP_PlaySequence_State_C_HandleShowHidePlayer Parms{};

	Parms.SequenceStart = SequenceStart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.HandleAudioState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SequenceStart                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::HandleAudioState(bool SequenceStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "HandleAudioState");

	Params::BP_PlaySequence_State_C_HandleAudioState Parms{};

	Parms.SequenceStart = SequenceStart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.Handle Audio Skip
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::Handle_Audio_Skip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "Handle Audio Skip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.GetAllBindingChar
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class UClass*, struct FNoceActorRefDepotData>&InValue                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// TArray<class ANoceCharacter*>*          Result                                                 (Parm, OutParm)

void UBP_PlaySequence_State_C::GetAllBindingChar(const TMap<class UClass*, struct FNoceActorRefDepotData>& InValue, TArray<class ANoceCharacter*>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "GetAllBindingChar");

	Params::BP_PlaySequence_State_C_GetAllBindingChar Parms{};

	Parms.InValue = std::move(InValue);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.FacialABPUpdate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   Char                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsBeforeEnter                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::FacialABPUpdate(class ANoceCharacter* Char, bool IsBeforeEnter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "FacialABPUpdate");

	Params::BP_PlaySequence_State_C_FacialABPUpdate Parms{};

	Parms.Char = Char;
	Parms.IsBeforeEnter = IsBeforeEnter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.ExecuteUbergraph_BP_PlaySequence_State
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::ExecuteUbergraph_BP_PlaySequence_State(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "ExecuteUbergraph_BP_PlaySequence_State");

	Params::BP_PlaySequence_State_C_ExecuteUbergraph_BP_PlaySequence_State Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.EnableGlobalEnemyThinkEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    GlobalEnemyThinkEnable                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::EnableGlobalEnemyThinkEnable(bool GlobalEnemyThinkEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "EnableGlobalEnemyThinkEnable");

	Params::BP_PlaySequence_State_C_EnableGlobalEnemyThinkEnable Parms{};

	Parms.GlobalEnemyThinkEnable = GlobalEnemyThinkEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.EnableEnvDither
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::EnableEnvDither(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "EnableEnvDither");

	Params::BP_PlaySequence_State_C_EnableEnvDither Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.CustomEvent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMoviePipelineExecutorBase*       PipelineExecutor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bSuccess                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_PlaySequence_State_C::CustomEvent(class UMoviePipelineExecutorBase* PipelineExecutor, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "CustomEvent");

	Params::BP_PlaySequence_State_C_CustomEvent Parms{};

	Parms.PipelineExecutor = PipelineExecutor;
	Parms.bSuccess = bSuccess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.ConstructionScript
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::ConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "ConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.ClearScreenMessage
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::ClearScreenMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "ClearScreenMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.CheckSkipFadeOutReady
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::CheckSkipFadeOutReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "CheckSkipFadeOutReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.CheckFadeOutReady
// (BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::CheckFadeOutReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "CheckFadeOutReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlaySequence_State.BP_PlaySequence_State_C.BindCallback
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_PlaySequence_State_C::BindCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlaySequence_State_C", "BindCallback");

	UObject::ProcessEvent(Func, nullptr);
}

}

