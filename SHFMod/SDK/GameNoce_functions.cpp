#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameNoce

#include "Basic.hpp"

#include "GameNoce_classes.hpp"
#include "GameNoce_parameters.hpp"


namespace SDK
{

// Function GameNoce.NoceUserWidgetBase.AddToInputDeviceUpdateList
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUserWidgetBase::AddToInputDeviceUpdateList(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "AddToInputDeviceUpdateList");

	Params::NoceUserWidgetBase_AddToInputDeviceUpdateList Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.ClearResource
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUserWidgetBase::ClearResource(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "ClearResource");

	Params::NoceUserWidgetBase_ClearResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUserWidgetBase.OnInputDeviceChanged
// (Native, Event, Protected, BlueprintEvent)

void UNoceUserWidgetBase::OnInputDeviceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "OnInputDeviceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.OnLanguageChanged
// (Native, Event, Protected, BlueprintEvent)

void UNoceUserWidgetBase::OnLanguageChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "OnLanguageChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.OnSynchronizeProperties
// (Native, Event, Protected, BlueprintEvent)

void UNoceUserWidgetBase::OnSynchronizeProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "OnSynchronizeProperties");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.PlayUIAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRestorable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUserWidgetBase::PlayUIAnimation(class UWidgetAnimation* InAnimation, bool IsLoop, bool IsRestorable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "PlayUIAnimation");

	Params::NoceUserWidgetBase_PlayUIAnimation Parms{};

	Parms.InAnimation = InAnimation;
	Parms.IsLoop = IsLoop;
	Parms.IsRestorable = IsRestorable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.PlayUISound
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  TriggerId                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceUserWidgetBase::PlayUISound(const struct FNeoAudioTriggerIdHandle& TriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "PlayUISound");

	Params::NoceUserWidgetBase_PlayUISound Parms{};

	Parms.TriggerId = std::move(TriggerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.StopUIAnimations
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UWidgetAnimation*>&  InAnimations                                           (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceUserWidgetBase::StopUIAnimations(const TArray<class UWidgetAnimation*>& InAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "StopUIAnimations");

	Params::NoceUserWidgetBase_StopUIAnimations Parms{};

	Parms.InAnimations = std::move(InAnimations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUserWidgetBase.SynchronizeProperties
// (Final, Native, Public, BlueprintCallable)

void UNoceUserWidgetBase::SynchronizeProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUserWidgetBase", "SynchronizeProperties");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSelectItemWidget.GetAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 NormalAnim                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 DisableAnim                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UNoceSelectItemWidget::GetAnimation(class UWidgetAnimation* NormalAnim, class UWidgetAnimation* DisableAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSelectItemWidget", "GetAnimation");

	Params::NoceSelectItemWidget_GetAnimation Parms{};

	Parms.NormalAnim = NormalAnim;
	Parms.DisableAnim = DisableAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSelectItemWidget.OnDecideCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceSelectItemWidget::OnDecideCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSelectItemWidget", "OnDecideCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSelectItemWidget.OnFocusCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceSelectItemWidget::OnFocusCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSelectItemWidget", "OnFocusCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSelectItemWidget.OnUnfocusCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceSelectItemWidget::OnUnfocusCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSelectItemWidget", "OnUnfocusCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSelectItemWidget.StopSelectAnimations
// (Final, Native, Protected, BlueprintCallable)

void UNoceSelectItemWidget::StopSelectAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSelectItemWidget", "StopSelectAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceScrollItemWidget.GetIsSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceScrollItemWidget::GetIsSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceScrollItemWidget", "GetIsSelected");

	Params::NoceScrollItemWidget_GetIsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceScrollItemWidget.RefreshObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceScrollItemWidget::RefreshObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceScrollItemWidget", "RefreshObject");

	Params::NoceScrollItemWidget_RefreshObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.AsyncActionHandleNoceStorage.NoceAsyncLoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SlotIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleNoceStorage*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleNoceStorage* UAsyncActionHandleNoceStorage::NoceAsyncLoadGameFromSlot(class UObject* WorldContextObject, const int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncActionHandleNoceStorage", "NoceAsyncLoadGameFromSlot");

	Params::AsyncActionHandleNoceStorage_NoceAsyncLoadGameFromSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.AsyncActionHandleNoceStorage.NoceAsyncSaveClearGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SlotIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         ClearEndingType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleNoceStorage*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleNoceStorage* UAsyncActionHandleNoceStorage::NoceAsyncSaveClearGameToSlot(class UObject* WorldContextObject, const int32 SlotIndex, ENoceEndingType ClearEndingType, bool ClearProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncActionHandleNoceStorage", "NoceAsyncSaveClearGameToSlot");

	Params::AsyncActionHandleNoceStorage_NoceAsyncSaveClearGameToSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotIndex = SlotIndex;
	Parms.ClearEndingType = ClearEndingType;
	Parms.ClearProgress = ClearProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.AsyncActionHandleNoceStorage.NoceAsyncSaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SlotIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocationName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleNoceStorage*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleNoceStorage* UAsyncActionHandleNoceStorage::NoceAsyncSaveGameToSlot(class UObject* WorldContextObject, const int32 SlotIndex, class FName LocationName, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncActionHandleNoceStorage", "NoceAsyncSaveGameToSlot");

	Params::AsyncActionHandleNoceStorage_NoceAsyncSaveGameToSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotIndex = SlotIndex;
	Parms.LocationName = LocationName;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.AsyncActionHandleNoceStorage.NoceAsyncSaveSystemSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleNoceStorage*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleNoceStorage* UAsyncActionHandleNoceStorage::NoceAsyncSaveSystemSave(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncActionHandleNoceStorage", "NoceAsyncSaveSystemSave");

	Params::AsyncActionHandleNoceStorage_NoceAsyncSaveSystemSave Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatLevelExtension.AddSpecialTag
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCheatLevelExtension::AddSpecialTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "AddSpecialTag");

	Params::NoceCheatLevelExtension_AddSpecialTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatLevelExtension.Debug_AddAllMapLocationIDs
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatLevelExtension::Debug_AddAllMapLocationIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "Debug_AddAllMapLocationIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.Debug_AddMapLocationID
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatLevelExtension::Debug_AddMapLocationID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "Debug_AddMapLocationID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.Debug_AddRemoveMapIcon
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatLevelExtension::Debug_AddRemoveMapIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "Debug_AddRemoveMapIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.Debug_AddSpecialTag
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatLevelExtension::Debug_AddSpecialTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "Debug_AddSpecialTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.Debug_RemoveMapLocationID
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatLevelExtension::Debug_RemoveMapLocationID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "Debug_RemoveMapLocationID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.GetSpecialTags
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatLevelExtension::GetSpecialTags(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "GetSpecialTags");

	Params::NoceCheatLevelExtension_GetSpecialTags Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatLevelExtension.OnAddSpecialTagWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatLevelExtension::OnAddSpecialTagWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "OnAddSpecialTagWindowDecided");

	Params::NoceCheatLevelExtension_OnAddSpecialTagWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.OnMapIconDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatLevelExtension::OnMapIconDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "OnMapIconDecided");

	Params::NoceCheatLevelExtension_OnMapIconDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.OnMapIconDecidedV2
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatLevelExtension::OnMapIconDecidedV2(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "OnMapIconDecidedV2");

	Params::NoceCheatLevelExtension_OnMapIconDecidedV2 Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.OnMapWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatLevelExtension::OnMapWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "OnMapWindowDecided");

	Params::NoceCheatLevelExtension_OnMapWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatLevelExtension.RefreshMinimap
// (Exec, Event, Public, BlueprintEvent)

void UNoceCheatLevelExtension::RefreshMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "RefreshMinimap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCheatLevelExtension.ToggleMinimap
// (Exec, Event, Public, BlueprintEvent)

void UNoceCheatLevelExtension::ToggleMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "ToggleMinimap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCheatLevelExtension.ZoomInMinimap
// (Exec, Event, Public, BlueprintEvent)

void UNoceCheatLevelExtension::ZoomInMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "ZoomInMinimap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCheatLevelExtension.ZoomOutMinimap
// (Exec, Event, Public, BlueprintEvent)

void UNoceCheatLevelExtension::ZoomOutMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatLevelExtension", "ZoomOutMinimap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCharacterMovementComponent.SetMoveSpeedRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCharacterMovementComponent::SetMoveSpeedRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacterMovementComponent", "SetMoveSpeedRatio");

	Params::NoceCharacterMovementComponent_SetMoveSpeedRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleUIExtension.Debug_AutoSwitchInputIcon
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleUIExtension::Debug_AutoSwitchInputIcon(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleUIExtension", "Debug_AutoSwitchInputIcon");

	Params::NoceCheatTitleUIExtension_Debug_AutoSwitchInputIcon Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleUIExtension.Debug_HideDevInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleUIExtension::Debug_HideDevInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleUIExtension", "Debug_HideDevInfo");

	Params::NoceCheatTitleUIExtension_Debug_HideDevInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleUIExtension.Debug_SetSkipLogo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleUIExtension::Debug_SetSkipLogo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleUIExtension", "Debug_SetSkipLogo");

	Params::NoceCheatTitleUIExtension_Debug_SetSkipLogo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChunkInstance.CheckDownloadableContentByRowName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsChunkInstalled                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsOwnedDLC                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChunkInstance::CheckDownloadableContentByRowName(class FName InRowName, bool* OutIsChunkInstalled, bool* OutIsOwnedDLC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "CheckDownloadableContentByRowName");

	Params::NoceChunkInstance_CheckDownloadableContentByRowName Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsChunkInstalled != nullptr)
		*OutIsChunkInstalled = Parms.OutIsChunkInstalled;

	if (OutIsOwnedDLC != nullptr)
		*OutIsOwnedDLC = Parms.OutIsOwnedDLC;
}


// Function GameNoce.NoceChunkInstance.Initialize_BP
// (Event, Public, BlueprintEvent)

void UNoceChunkInstance::Initialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "Initialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceChunkInstance.SetupDebugData_BP
// (Event, Public, BlueprintEvent)

void UNoceChunkInstance::SetupDebugData_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "SetupDebugData_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceChunkInstance.SetUsingChunkDebugData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChunkInstance::SetUsingChunkDebugData(bool InIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "SetUsingChunkDebugData");

	Params::NoceChunkInstance_SetUsingChunkDebugData Parms{};

	Parms.InIsEnable = InIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChunkInstance.ShowCheckDLCResult_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsChunkInstalled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOwnedDLC                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChunkInstance::ShowCheckDLCResult_BP(class FName InRowName, bool IsChunkInstalled, bool IsOwnedDLC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "ShowCheckDLCResult_BP");

	Params::NoceChunkInstance_ShowCheckDLCResult_BP Parms{};

	Parms.InRowName = InRowName;
	Parms.IsChunkInstalled = IsChunkInstalled;
	Parms.IsOwnedDLC = IsOwnedDLC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceChunkInstance.StartQueryDLC
// (Final, Native, Public, BlueprintCallable)

void UNoceChunkInstance::StartQueryDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "StartQueryDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChunkInstance.StopQueryDLC
// (Final, Native, Public, BlueprintCallable)

void UNoceChunkInstance::StopQueryDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "StopQueryDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChunkInstance.UpdateChunkDebugData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceChunkDebugType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceChunkDebugAction                   InAction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::UpdateChunkDebugData(class FName InRowName, ENoceChunkDebugType InType, ENoceChunkDebugAction InAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "UpdateChunkDebugData");

	Params::NoceChunkInstance_UpdateChunkDebugData Parms{};

	Parms.InRowName = InRowName;
	Parms.InType = InType;
	Parms.InAction = InAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.DoesChunkFileExist
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InChunkID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::DoesChunkFileExist(int32 InChunkID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "DoesChunkFileExist");

	Params::NoceChunkInstance_DoesChunkFileExist Parms{};

	Parms.InChunkID = InChunkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.GetChunkDataByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceChunkDataRow                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceChunkDataRow UNoceChunkInstance::GetChunkDataByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "GetChunkDataByName");

	Params::NoceChunkInstance_GetChunkDataByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.GetChunkDataRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceChunkInstance::GetChunkDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "GetChunkDataRowNames");

	Params::NoceChunkInstance_GetChunkDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.GetChunkIDFromDataRow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FNoceChunkDataRow&         InDataRow                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceChunkInstance::GetChunkIDFromDataRow(const struct FNoceChunkDataRow& InDataRow) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "GetChunkIDFromDataRow");

	Params::NoceChunkInstance_GetChunkIDFromDataRow Parms{};

	Parms.InDataRow = std::move(InDataRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.GetDebugDataByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceChunkDebugType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::GetDebugDataByType(class FName InRowName, ENoceChunkDebugType InType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "GetDebugDataByType");

	Params::NoceChunkInstance_GetDebugDataByType Parms{};

	Parms.InRowName = InRowName;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.GetDownloadContentIDFromDataRow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FNoceChunkDataRow&         InDataRow                                              (Parm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceChunkInstance::GetDownloadContentIDFromDataRow(const struct FNoceChunkDataRow& InDataRow) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "GetDownloadContentIDFromDataRow");

	Params::NoceChunkInstance_GetDownloadContentIDFromDataRow Parms{};

	Parms.InDataRow = std::move(InDataRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.IsChunkInstalled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InChunkID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::IsChunkInstalled(int32 InChunkID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "IsChunkInstalled");

	Params::NoceChunkInstance_IsChunkInstalled Parms{};

	Parms.InChunkID = InChunkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.IsChunkInstalledByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::IsChunkInstalledByRowName(class FName InRowName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "IsChunkInstalledByRowName");

	Params::NoceChunkInstance_IsChunkInstalledByRowName Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.IsOwnedDLCByID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    InDLCID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::IsOwnedDLCByID(const class FString& InDLCID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "IsOwnedDLCByID");

	Params::NoceChunkInstance_IsOwnedDLCByID Parms{};

	Parms.InDLCID = std::move(InDLCID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChunkInstance.IsOwnedDLCByRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceChunkInstance::IsOwnedDLCByRowName(class FName InRowName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChunkInstance", "IsOwnedDLCByRowName");

	Params::NoceChunkInstance_IsOwnedDLCByRowName Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceShowByProgressBaseComponent.OnAdditionalTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceShowByProgressBaseComponent::OnAdditionalTagChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShowByProgressBaseComponent", "OnAdditionalTagChanged");

	Params::NoceShowByProgressBaseComponent_OnAdditionalTagChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceShowByProgressBaseComponent.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceShowByProgressBaseComponent::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShowByProgressBaseComponent", "OnProgressChanged");

	Params::NoceShowByProgressBaseComponent_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceShowByProgressBaseComponent.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceShowByProgressBaseComponent::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShowByProgressBaseComponent", "OnProgressInitialized");

	Params::NoceShowByProgressBaseComponent_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceShowByProgressBaseComponent.OnProgressOrTagChanged_BP
// (Native, Event, Protected, BlueprintEvent)

void UNoceShowByProgressBaseComponent::OnProgressOrTagChanged_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShowByProgressBaseComponent", "OnProgressOrTagChanged_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.FrameworkFunctionLibrary.GetNoceWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceWorldSettings*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceWorldSettings* UFrameworkFunctionLibrary::GetNoceWorldSettings(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameworkFunctionLibrary", "GetNoceWorldSettings");

	Params::FrameworkFunctionLibrary_GetNoceWorldSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.FrameworkFunctionLibrary.IsGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AGameModeBase>        GameModeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFrameworkFunctionLibrary::IsGameMode(const class UObject* WorldContextObject, TSubclassOf<class AGameModeBase> GameModeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameworkFunctionLibrary", "IsGameMode");

	Params::FrameworkFunctionLibrary_IsGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GameModeClass = GameModeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.FrameworkFunctionLibrary.IsNoceGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFrameworkFunctionLibrary::IsNoceGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameworkFunctionLibrary", "IsNoceGameMode");

	Params::FrameworkFunctionLibrary_IsNoceGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.FrameworkFunctionLibrary.IsNoceTitleGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFrameworkFunctionLibrary::IsNoceTitleGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameworkFunctionLibrary", "IsNoceTitleGameMode");

	Params::FrameworkFunctionLibrary_IsNoceTitleGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetActionLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceActionLevel                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceActionLevel AGameNoceGameModeBase::GetActionLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetActionLevel");

	Params::GameNoceGameModeBase_GetActionLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetPlayerOutfitValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerOutfit                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePlayerOutfit AGameNoceGameModeBase::GetPlayerOutfitValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetPlayerOutfitValue");

	Params::GameNoceGameModeBase_GetPlayerOutfitValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetPlayerSaveGameOutfit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerOutfit                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePlayerOutfit AGameNoceGameModeBase::GetPlayerSaveGameOutfit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetPlayerSaveGameOutfit");

	Params::GameNoceGameModeBase_GetPlayerSaveGameOutfit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetRiddleLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRiddleLevel                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRiddleLevel AGameNoceGameModeBase::GetRiddleLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetRiddleLevel");

	Params::GameNoceGameModeBase_GetRiddleLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetRoundType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType AGameNoceGameModeBase::GetRoundType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetRoundType");

	Params::GameNoceGameModeBase_GetRoundType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetSaveGameRoundType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType AGameNoceGameModeBase::GetSaveGameRoundType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetSaveGameRoundType");

	Params::GameNoceGameModeBase_GetSaveGameRoundType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetSimulateStoryClearBitmask
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameNoceGameModeBase::GetSimulateStoryClearBitmask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetSimulateStoryClearBitmask");

	Params::GameNoceGameModeBase_GetSimulateStoryClearBitmask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.GetStoryEndingType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEndingType AGameNoceGameModeBase::GetStoryEndingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "GetStoryEndingType");

	Params::GameNoceGameModeBase_GetStoryEndingType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.GameNoceGameModeBase.HandleUpdatePlayerCharMeshType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCharMeshRowName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::HandleUpdatePlayerCharMeshType(ENocePlayerType InPlayerType, class FName InCharMeshRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "HandleUpdatePlayerCharMeshType");

	Params::GameNoceGameModeBase_HandleUpdatePlayerCharMeshType Parms{};

	Parms.InPlayerType = InPlayerType;
	Parms.InCharMeshRowName = InCharMeshRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.OnSystemSaveLoaded
// (Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              SystemSave                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::OnSystemSaveLoaded(class UNoceSystemSaveGame* SystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "OnSystemSaveLoaded");

	Params::GameNoceGameModeBase_OnSystemSaveLoaded Parms{};

	Parms.SystemSave = SystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.OnSystemSaveSaved
// (Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              SystemSave                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::OnSystemSaveSaved(class UNoceSystemSaveGame* SystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "OnSystemSaveSaved");

	Params::GameNoceGameModeBase_OnSystemSaveSaved Parms{};

	Parms.SystemSave = SystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetActionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetActionLevel(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetActionLevel");

	Params::GameNoceGameModeBase_SetActionLevel Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetPlayerOutfitValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerOutfit                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetPlayerOutfitValue(ENocePlayerOutfit InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetPlayerOutfitValue");

	Params::GameNoceGameModeBase_SetPlayerOutfitValue Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetRiddleLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceRiddleLevel                        RiddleLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetRiddleLevel(ENoceRiddleLevel RiddleLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetRiddleLevel");

	Params::GameNoceGameModeBase_SetRiddleLevel Parms{};

	Parms.RiddleLevel = RiddleLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetSimulateRoundType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceRoundType                          DebugRoundType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetSimulateRoundType(ENoceRoundType DebugRoundType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetSimulateRoundType");

	Params::GameNoceGameModeBase_SetSimulateRoundType Parms{};

	Parms.DebugRoundType = DebugRoundType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetSimulateStoryClearBitmask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetSimulateStoryClearBitmask(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetSimulateStoryClearBitmask");

	Params::GameNoceGameModeBase_SetSimulateStoryClearBitmask Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.GameNoceGameModeBase.SetStoryEndingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameNoceGameModeBase::SetStoryEndingType(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameNoceGameModeBase", "SetStoryEndingType");

	Params::GameNoceGameModeBase_SetStoryEndingType Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTestBaseController.OnMemReportIntervalChanged
// (Final, Native, Private)

void UNoceTestBaseController::OnMemReportIntervalChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTestBaseController", "OnMemReportIntervalChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTestBaseController.OnMemReportTimerExpired
// (Final, Native, Private)

void UNoceTestBaseController::OnMemReportTimerExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTestBaseController", "OnMemReportTimerExpired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTestBaseController.TryEarlyExec
// (Final, Native, Private)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTestBaseController::TryEarlyExec(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTestBaseController", "TryEarlyExec");

	Params::NoceTestBaseController_TryEarlyExec Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.BP_Debug_SetWeaponDurability
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::BP_Debug_SetWeaponDurability(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "BP_Debug_SetWeaponDurability");

	Params::NoceCheatManager_BP_Debug_SetWeaponDurability Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_AnalyticsEndSession
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_AnalyticsEndSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_AnalyticsEndSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_AnalyticsStartSession
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_AnalyticsStartSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_AnalyticsStartSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ApplyClawAlterBackMark
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ApplyClawAlterBackMark(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ApplyClawAlterBackMark");

	Params::NoceCheatManager_Debug_ApplyClawAlterBackMark Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ApplyClawAlterBackMarkRound3
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ApplyClawAlterBackMarkRound3(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ApplyClawAlterBackMarkRound3");

	Params::NoceCheatManager_Debug_ApplyClawAlterBackMarkRound3 Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ApplyClawAlterHandRound2
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ApplyClawAlterHandRound2(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ApplyClawAlterHandRound2");

	Params::NoceCheatManager_Debug_ApplyClawAlterHandRound2 Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ApplyClawAlterMask
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ApplyClawAlterMask(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ApplyClawAlterMask");

	Params::NoceCheatManager_Debug_ApplyClawAlterMask Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_AsyncAutoSave
// (Exec, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceCheatManager::Debug_AsyncAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_AsyncAutoSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCheatManager.Debug_AutoLoad
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_AutoLoad(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_AutoLoad");

	Params::NoceCheatManager_Debug_AutoLoad Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_AutoSave
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocationRowName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_AutoSave(int32 SlotIndex, class FName LocationRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_AutoSave");

	Params::NoceCheatManager_Debug_AutoSave Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.LocationRowName = LocationRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_BugIt
// (Final, Exec, Native, Public)

void UNoceCheatManager::Debug_BugIt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_BugIt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ChangeActionLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ChangeActionLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ChangeActionLevel");

	Params::NoceCheatManager_Debug_ChangeActionLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ChangeGameRound
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ChangeGameRound(int32 InRound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ChangeGameRound");

	Params::NoceCheatManager_Debug_ChangeGameRound Parms{};

	Parms.InRound = InRound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ChangePlayerCharMeshType
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ChangePlayerCharMeshType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ChangePlayerCharMeshType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ClearAllTutorial
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ClearAllTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ClearAllTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ClearAllWorldTriggerSetting
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ClearAllWorldTriggerSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ClearAllWorldTriggerSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ClearTemporaryGameSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_ClearTemporaryGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ClearTemporaryGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_CollisionOpacity
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_CollisionOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_CollisionOpacity");

	Params::NoceCheatManager_Debug_CollisionOpacity Parms{};

	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_CollisionViewMode
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InViewMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_CollisionViewMode(int32 InViewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_CollisionViewMode");

	Params::NoceCheatManager_Debug_CollisionViewMode Parms{};

	Parms.InViewMode = InViewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ConditionHandlerInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ConditionHandlerInfo(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ConditionHandlerInfo");

	Params::NoceCheatManager_Debug_ConditionHandlerInfo Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_CreateTemporaryGameSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_CreateTemporaryGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_CreateTemporaryGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DeleteAllAutoSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_DeleteAllAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DeleteAllAutoSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DeleteAllGameSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_DeleteAllGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DeleteAllGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DeleteAllMaunalSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_DeleteAllMaunalSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DeleteAllMaunalSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DeleteSlot
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DeleteSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DeleteSlot");

	Params::NoceCheatManager_Debug_DeleteSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DeleteSystemSave
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_DeleteSystemSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DeleteSystemSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisableAutoSave
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisableAutoSave(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisableAutoSave");

	Params::NoceCheatManager_Debug_DisableAutoSave Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisableLinkMotionAvoidCol
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisableLinkMotionAvoidCol(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisableLinkMotionAvoidCol");

	Params::NoceCheatManager_Debug_DisableLinkMotionAvoidCol Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisableLinkMotionInterruptSequencer
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisableLinkMotionInterruptSequencer(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisableLinkMotionInterruptSequencer");

	Params::NoceCheatManager_Debug_DisableLinkMotionInterruptSequencer Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisaplyNPCLookAtSystemInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisaplyNPCLookAtSystemInfo(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisaplyNPCLookAtSystemInfo");

	Params::NoceCheatManager_Debug_DisaplyNPCLookAtSystemInfo Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisaplyPlayerLookAtSystemInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisaplyPlayerLookAtSystemInfo(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisaplyPlayerLookAtSystemInfo");

	Params::NoceCheatManager_Debug_DisaplyPlayerLookAtSystemInfo Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DisplayFadeSystemInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DisplayFadeSystemInfo(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DisplayFadeSystemInfo");

	Params::NoceCheatManager_Debug_DisplayFadeSystemInfo Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_DrawCellLoadingTime
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_DrawCellLoadingTime(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_DrawCellLoadingTime");

	Params::NoceCheatManager_Debug_DrawCellLoadingTime Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnableDynamicPickups
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnableDynamicPickups(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnableDynamicPickups");

	Params::NoceCheatManager_Debug_EnableDynamicPickups Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnableEventPickups
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnableEventPickups(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnableEventPickups");

	Params::NoceCheatManager_Debug_EnableEventPickups Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnableGlobalRigidBody
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnableGlobalRigidBody(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnableGlobalRigidBody");

	Params::NoceCheatManager_Debug_EnableGlobalRigidBody Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EndTutorial
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TutorialIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EndTutorial(int32 TutorialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EndTutorial");

	Params::NoceCheatManager_Debug_EndTutorial Parms{};

	Parms.TutorialIndex = TutorialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EndTutorialByName
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EndTutorialByName(class FName TutorialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EndTutorialByName");

	Params::NoceCheatManager_Debug_EndTutorialByName Parms{};

	Parms.TutorialName = TutorialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnemyMayNotRevive
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnemyMayNotRevive(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnemyMayNotRevive");

	Params::NoceCheatManager_Debug_EnemyMayNotRevive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnemyOneShotKill
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnemyOneShotKill(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnemyOneShotKill");

	Params::NoceCheatManager_Debug_EnemyOneShotKill Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_EnemyOneShotKillNotRevive
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_EnemyOneShotKillNotRevive(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_EnemyOneShotKillNotRevive");

	Params::NoceCheatManager_Debug_EnemyOneShotKillNotRevive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_FindRigidBodyOverlapWorldStatic
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_FindRigidBodyOverlapWorldStatic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_FindRigidBodyOverlapWorldStatic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceChangeStoryEndingType
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ForceChangeStoryEndingType(int32 EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceChangeStoryEndingType");

	Params::NoceCheatManager_Debug_ForceChangeStoryEndingType Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceClawGToClaw
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ForceClawGToClaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceClawGToClaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceClawToClawG
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ForceClawToClawG()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceClawToClawG");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceEnableRagdoll
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ForceEnableRagdoll(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceEnableRagdoll");

	Params::NoceCheatManager_Debug_ForceEnableRagdoll Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceJumpPlaybackPos
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ForceJumpPlaybackPos(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceJumpPlaybackPos");

	Params::NoceCheatManager_Debug_ForceJumpPlaybackPos Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceShowEyeLacrimalFluid
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ForceShowEyeLacrimalFluid(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceShowEyeLacrimalFluid");

	Params::NoceCheatManager_Debug_ForceShowEyeLacrimalFluid Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ForceUpdateLight
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ForceUpdateLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ForceUpdateLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_GenerateDynamicPickups
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_GenerateDynamicPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_GenerateDynamicPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_GenerateEventPickupsNearbyPlayer
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_GenerateEventPickupsNearbyPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_GenerateEventPickupsNearbyPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_GoNextProgress
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_GoNextProgress(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_GoNextProgress");

	Params::NoceCheatManager_Debug_GoNextProgress Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_HideBasicDebugInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_HideBasicDebugInfo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_HideBasicDebugInfo");

	Params::NoceCheatManager_Debug_HideBasicDebugInfo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_HideGreyboxObject
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_HideGreyboxObject(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_HideGreyboxObject");

	Params::NoceCheatManager_Debug_HideGreyboxObject Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_HideSubtitle
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_HideSubtitle(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_HideSubtitle");

	Params::NoceCheatManager_Debug_HideSubtitle Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_InGameFixedEV
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_InGameFixedEV(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_InGameFixedEV");

	Params::NoceCheatManager_Debug_InGameFixedEV Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_InGameFixedEVMode
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   EVMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_InGameFixedEVMode(int32 EVMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_InGameFixedEVMode");

	Params::NoceCheatManager_Debug_InGameFixedEVMode Parms{};

	Parms.EVMode = EVMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_MakeFakeClearGame
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_MakeFakeClearGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_MakeFakeClearGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_NoceFadeIn
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_NoceFadeIn(int32 FadeType, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_NoceFadeIn");

	Params::NoceCheatManager_Debug_NoceFadeIn Parms{};

	Parms.FadeType = FadeType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_NoceFadeOut
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_NoceFadeOut(int32 FadeType, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_NoceFadeOut");

	Params::NoceCheatManager_Debug_NoceFadeOut Parms{};

	Parms.FadeType = FadeType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_PlayerAnimationLogInfoStateChange
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_PlayerAnimationLogInfoStateChange(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_PlayerAnimationLogInfoStateChange");

	Params::NoceCheatManager_Debug_PlayerAnimationLogInfoStateChange Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_PlayerFootIKDebugDraw
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_PlayerFootIKDebugDraw(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_PlayerFootIKDebugDraw");

	Params::NoceCheatManager_Debug_PlayerFootIKDebugDraw Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_PlayerFootIKDebugTrace
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_PlayerFootIKDebugTrace(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_PlayerFootIKDebugTrace");

	Params::NoceCheatManager_Debug_PlayerFootIKDebugTrace Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_PlayerShiromukuRevive
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_PlayerShiromukuRevive(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_PlayerShiromukuRevive");

	Params::NoceCheatManager_Debug_PlayerShiromukuRevive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_PrintNoceGlobalDelegatesStatus
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_PrintNoceGlobalDelegatesStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_PrintNoceGlobalDelegatesStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RemoveAdditionalTag
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InTagName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_RemoveAdditionalTag(class FName InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RemoveAdditionalTag");

	Params::NoceCheatManager_Debug_RemoveAdditionalTag Parms{};

	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RemoveAllEventPickups
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_RemoveAllEventPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RemoveAllEventPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RemoveCurrentDynamicPickups
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_RemoveCurrentDynamicPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RemoveCurrentDynamicPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RequesetWorldTrigger
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_RequesetWorldTrigger(class FName InName, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RequesetWorldTrigger");

	Params::NoceCheatManager_Debug_RequesetWorldTrigger Parms{};

	Parms.InName = InName;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RequestNocePPV
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InDataRowName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_RequestNocePPV(class FName InType, class FName InDataRowName, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RequestNocePPV");

	Params::NoceCheatManager_Debug_RequestNocePPV Parms{};

	Parms.InType = InType;
	Parms.InDataRowName = InDataRowName;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_RequestWind
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InDataRowName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_RequestWind(class FName InDataRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_RequestWind");

	Params::NoceCheatManager_Debug_RequestWind Parms{};

	Parms.InDataRowName = InDataRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ResetAchievements
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SelectBColType
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBColType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SelectBColType(int32 InBColType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SelectBColType");

	Params::NoceCheatManager_Debug_SelectBColType Parms{};

	Parms.InBColType = InBColType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAdditionalTag
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InTagName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAdditionalTag(class FName InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAdditionalTag");

	Params::NoceCheatManager_Debug_SetAdditionalTag Parms{};

	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAllStoryEndingCleared
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_SetAllStoryEndingCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAllStoryEndingCleared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetATPCCameraLocationObjectDebug
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetATPCCameraLocationObjectDebug(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetATPCCameraLocationObjectDebug");

	Params::NoceCheatManager_Debug_SetATPCCameraLocationObjectDebug Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetATPCCameraLockObjectDebug
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetATPCCameraLockObjectDebug(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetATPCCameraLockObjectDebug");

	Params::NoceCheatManager_Debug_SetATPCCameraLockObjectDebug Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackLogEnemy
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackLogEnemy(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackLogEnemy");

	Params::NoceCheatManager_Debug_SetAttackLogEnemy Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackLogEnviroment
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackLogEnviroment(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackLogEnviroment");

	Params::NoceCheatManager_Debug_SetAttackLogEnviroment Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackLogPlayer
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackLogPlayer(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackLogPlayer");

	Params::NoceCheatManager_Debug_SetAttackLogPlayer Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawResultEnemy
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawResultEnemy(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawResultEnemy");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawResultEnemy Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawResultEnviroment
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawResultEnviroment(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawResultEnviroment");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawResultEnviroment Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawResultPlayer
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawResultPlayer(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawResultPlayer");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawResultPlayer Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawResultPlayerDefelct
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawResultPlayerDefelct(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawResultPlayerDefelct");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawResultPlayerDefelct Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawShapeEnemy
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawShapeEnemy(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawShapeEnemy");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawShapeEnemy Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawShapeEnviroment
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawShapeEnviroment(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawShapeEnviroment");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawShapeEnviroment Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawShapePlayer
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawShapePlayer(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawShapePlayer");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawShapePlayer Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetAttackTraceDrawShapePlayerDefelct
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetAttackTraceDrawShapePlayerDefelct(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetAttackTraceDrawShapePlayerDefelct");

	Params::NoceCheatManager_Debug_SetAttackTraceDrawShapePlayerDefelct Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetBattlePositionForceActivate
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetBattlePositionForceActivate(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetBattlePositionForceActivate");

	Params::NoceCheatManager_Debug_SetBattlePositionForceActivate Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetBattlePositionSystemEnabled
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetBattlePositionSystemEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetBattlePositionSystemEnabled");

	Params::NoceCheatManager_Debug_SetBattlePositionSystemEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetBattleStatusTime
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetBattleStatusTime(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetBattleStatusTime");

	Params::NoceCheatManager_Debug_SetBattleStatusTime Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetCapsuleShrinkEnableDebug
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetCapsuleShrinkEnableDebug(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetCapsuleShrinkEnableDebug");

	Params::NoceCheatManager_Debug_SetCapsuleShrinkEnableDebug Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetCapsuleShrinkEnableUse
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetCapsuleShrinkEnableUse(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetCapsuleShrinkEnableUse");

	Params::NoceCheatManager_Debug_SetCapsuleShrinkEnableUse Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetClawTransform
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetClawTransform(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetClawTransform");

	Params::NoceCheatManager_Debug_SetClawTransform Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetCurrentMaxSanity
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetCurrentMaxSanity(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetCurrentMaxSanity");

	Params::NoceCheatManager_Debug_SetCurrentMaxSanity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetDebugEnemyInSight
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetDebugEnemyInSight(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetDebugEnemyInSight");

	Params::NoceCheatManager_Debug_SetDebugEnemyInSight Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetDrawTriggerBox
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetDrawTriggerBox(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetDrawTriggerBox");

	Params::NoceCheatManager_Debug_SetDrawTriggerBox Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetEnemyAttackRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetEnemyAttackRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetEnemyAttackRatio");

	Params::NoceCheatManager_Debug_SetEnemyAttackRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetEnemyNoAttack
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetEnemyNoAttack(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetEnemyNoAttack");

	Params::NoceCheatManager_Debug_SetEnemyNoAttack Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetEventMaxTryFailedCount
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetEventMaxTryFailedCount(int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetEventMaxTryFailedCount");

	Params::NoceCheatManager_Debug_SetEventMaxTryFailedCount Parms{};

	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetEventMinDistanceSquared
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InDistanceSquared                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetEventMinDistanceSquared(float InDistanceSquared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetEventMinDistanceSquared");

	Params::NoceCheatManager_Debug_SetEventMinDistanceSquared Parms{};

	Parms.InDistanceSquared = InDistanceSquared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetForceJustDodge
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetForceJustDodge(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetForceJustDodge");

	Params::NoceCheatManager_Debug_SetForceJustDodge Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetFreeCameraRotate
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetFreeCameraRotate(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetFreeCameraRotate");

	Params::NoceCheatManager_Debug_SetFreeCameraRotate Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetHealth
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetHealth(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetHealth");

	Params::NoceCheatManager_Debug_SetHealth Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetHealthPercent
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetHealthPercent(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetHealthPercent");

	Params::NoceCheatManager_Debug_SetHealthPercent Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetHeightFogDistance
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetHeightFogDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetHeightFogDistance");

	Params::NoceCheatManager_Debug_SetHeightFogDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetLanternPointRadius
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetLanternPointRadius(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetLanternPointRadius");

	Params::NoceCheatManager_Debug_SetLanternPointRadius Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetLeaveEnemyInSightDistance
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetLeaveEnemyInSightDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetLeaveEnemyInSightDistance");

	Params::NoceCheatManager_Debug_SetLeaveEnemyInSightDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetLowStaminaThreshold
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetLowStaminaThreshold(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetLowStaminaThreshold");

	Params::NoceCheatManager_Debug_SetLowStaminaThreshold Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetMaxHealth
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetMaxHealth(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetMaxHealth");

	Params::NoceCheatManager_Debug_SetMaxHealth Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetMaxSanity
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetMaxSanity(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetMaxSanity");

	Params::NoceCheatManager_Debug_SetMaxSanity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetMaxStamina
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetMaxStamina(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetMaxStamina");

	Params::NoceCheatManager_Debug_SetMaxStamina Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetMoonlightRadius
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetMoonlightRadius(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetMoonlightRadius");

	Params::NoceCheatManager_Debug_SetMoonlightRadius Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetNoCostSanity
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetNoCostSanity(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetNoCostSanity");

	Params::NoceCheatManager_Debug_SetNoCostSanity Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetNoPlayerHandleDamage
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetNoPlayerHandleDamage(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetNoPlayerHandleDamage");

	Params::NoceCheatManager_Debug_SetNoPlayerHandleDamage Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetNormalBattleBGMDistMultiplier
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetNormalBattleBGMDistMultiplier(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetNormalBattleBGMDistMultiplier");

	Params::NoceCheatManager_Debug_SetNormalBattleBGMDistMultiplier Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerAttackRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerAttackRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerAttackRatio");

	Params::NoceCheatManager_Debug_SetPlayerAttackRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerControlerShowDebugInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerControlerShowDebugInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerControlerShowDebugInfo");

	Params::NoceCheatManager_Debug_SetPlayerControlerShowDebugInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerDeflectRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerDeflectRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerDeflectRatio");

	Params::NoceCheatManager_Debug_SetPlayerDeflectRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerFurClawGRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerFurClawGRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerFurClawGRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerFurClawGRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerFurClawRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerFurClawRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerFurClawRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerFurClawRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerMoveSpeedRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerMoveSpeedRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerMoveSpeedRatio");

	Params::NoceCheatManager_Debug_SetPlayerMoveSpeedRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerOutfit
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerOutfit(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerOutfit");

	Params::NoceCheatManager_Debug_SetPlayerOutfit Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerScabbardRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerScabbardRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerScabbardRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerScabbardRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerScarfRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerScarfRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerScarfRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerScarfRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerShawlRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerShawlRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerShawlRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerShawlRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerSkirtRigidBodyAlpha
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerSkirtRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerSkirtRigidBodyAlpha");

	Params::NoceCheatManager_Debug_SetPlayerSkirtRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetPlayerWinceRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetPlayerWinceRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetPlayerWinceRatio");

	Params::NoceCheatManager_Debug_SetPlayerWinceRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetProgressTag
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InTagName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetProgressTag(class FName InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetProgressTag");

	Params::NoceCheatManager_Debug_SetProgressTag Parms{};

	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowEnemyHealthBar
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowEnemyHealthBar(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowEnemyHealthBar");

	Params::NoceCheatManager_Debug_SetShowEnemyHealthBar Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowFootStepVFXInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowFootStepVFXInfo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowFootStepVFXInfo");

	Params::NoceCheatManager_Debug_SetShowFootStepVFXInfo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowPlayerClawTransformLog
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowPlayerClawTransformLog(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowPlayerClawTransformLog");

	Params::NoceCheatManager_Debug_SetShowPlayerClawTransformLog Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowPlayerInvincibleInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowPlayerInvincibleInfo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowPlayerInvincibleInfo");

	Params::NoceCheatManager_Debug_SetShowPlayerInvincibleInfo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowPlayerSanityCostLog
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowPlayerSanityCostLog(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowPlayerSanityCostLog");

	Params::NoceCheatManager_Debug_SetShowPlayerSanityCostLog Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowPlayerShowHideInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowPlayerShowHideInfo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowPlayerShowHideInfo");

	Params::NoceCheatManager_Debug_SetShowPlayerShowHideInfo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetShowPlayerStaminaCostLog
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetShowPlayerStaminaCostLog(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetShowPlayerStaminaCostLog");

	Params::NoceCheatManager_Debug_SetShowPlayerStaminaCostLog Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetSkipEnemyCounterableCheck
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetSkipEnemyCounterableCheck(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetSkipEnemyCounterableCheck");

	Params::NoceCheatManager_Debug_SetSkipEnemyCounterableCheck Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetStoryEndingCleared
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetStoryEndingCleared(int32 EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetStoryEndingCleared");

	Params::NoceCheatManager_Debug_SetStoryEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetTriggerDetail
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetTriggerDetail(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetTriggerDetail");

	Params::NoceCheatManager_Debug_SetTriggerDetail Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetWeaponDurability
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetWeaponDurability(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetWeaponDurability");

	Params::NoceCheatManager_Debug_SetWeaponDurability Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SetWeaponDurabilityCostRatio
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_SetWeaponDurabilityCostRatio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SetWeaponDurabilityCostRatio");

	Params::NoceCheatManager_Debug_SetWeaponDurabilityCostRatio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowAchievementStatus
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowAchievementStatus(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowAchievementStatus");

	Params::NoceCheatManager_Debug_ShowAchievementStatus Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowAutoAimCompWarpLocationInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowAutoAimCompWarpLocationInfo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowAutoAimCompWarpLocationInfo");

	Params::NoceCheatManager_Debug_ShowAutoAimCompWarpLocationInfo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowCounterableExtendAutoAimDistance
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowCounterableExtendAutoAimDistance(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowCounterableExtendAutoAimDistance");

	Params::NoceCheatManager_Debug_ShowCounterableExtendAutoAimDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowDynamicPickupsDebugInfo
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InIsShow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowDynamicPickupsDebugInfo(bool InIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowDynamicPickupsDebugInfo");

	Params::NoceCheatManager_Debug_ShowDynamicPickupsDebugInfo Parms{};

	Parms.InIsShow = InIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowGimmickInfo
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowGimmickInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowGimmickInfo");

	Params::NoceCheatManager_Debug_ShowGimmickInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowHitPerfromVFXInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowHitPerfromVFXInfo(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowHitPerfromVFXInfo");

	Params::NoceCheatManager_Debug_ShowHitPerfromVFXInfo Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowIndicator
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowIndicator(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowIndicator");

	Params::NoceCheatManager_Debug_ShowIndicator Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowInteractInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowInteractInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowInteractInfo");

	Params::NoceCheatManager_Debug_ShowInteractInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowInteractPriority
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowInteractPriority(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowInteractPriority");

	Params::NoceCheatManager_Debug_ShowInteractPriority Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowLinkMotionDebugInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowLinkMotionDebugInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowLinkMotionDebugInfo");

	Params::NoceCheatManager_Debug_ShowLinkMotionDebugInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowRecordStatus
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowRecordStatus(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowRecordStatus");

	Params::NoceCheatManager_Debug_ShowRecordStatus Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowSaveClearGame
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_ShowSaveClearGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowSaveClearGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowSceneDitherFade
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowSceneDitherFade(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowSceneDitherFade");

	Params::NoceCheatManager_Debug_ShowSceneDitherFade Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowTeleportBlackScreen
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowTeleportBlackScreen(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowTeleportBlackScreen");

	Params::NoceCheatManager_Debug_ShowTeleportBlackScreen Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ShowWorldTriggerStatus
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_ShowWorldTriggerStatus(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ShowWorldTriggerStatus");

	Params::NoceCheatManager_Debug_ShowWorldTriggerStatus Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_SpawnEnemy
// (Exec, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceCheatManager::Debug_SpawnEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_SpawnEnemy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCheatManager.Debug_StartTutorial
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TutorialIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_StartTutorial(int32 TutorialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_StartTutorial");

	Params::NoceCheatManager_Debug_StartTutorial Parms{};

	Parms.TutorialIndex = TutorialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_StartTutorialByName
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_StartTutorialByName(class FName TutorialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_StartTutorialByName");

	Params::NoceCheatManager_Debug_StartTutorialByName Parms{};

	Parms.TutorialName = TutorialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_StartTutorialByPopWindow
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_StartTutorialByPopWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_StartTutorialByPopWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleBColOnly
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleBColOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleBColOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleBlockCameraColOnly
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleBlockCameraColOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleBlockCameraColOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleCollisionViewLighting
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleCollisionViewLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleCollisionViewLighting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleEColOnly
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleEColOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleEColOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleGreyboxVisibility
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleGreyboxVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleGreyboxVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleStorageInfo
// (Final, Exec, Native, Protected, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleStorageInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleStorageInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleToolLight
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleToolLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleToolLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleTriggerBox
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleTriggerBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleTriggerBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_ToggleTriggerDetail
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_ToggleTriggerDetail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_ToggleTriggerDetail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UnequipWeapon
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::Debug_UnequipWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UnequipWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UnlockAchievement
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UnlockAchievement(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UnlockAchievement");

	Params::NoceCheatManager_Debug_UnlockAchievement Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UseEnemyFootIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UseEnemyFootIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UseEnemyFootIK");

	Params::NoceCheatManager_Debug_UseEnemyFootIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UseNPCFootIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UseNPCFootIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UseNPCFootIK");

	Params::NoceCheatManager_Debug_UseNPCFootIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UseNPCLookAtIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UseNPCLookAtIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UseNPCLookAtIK");

	Params::NoceCheatManager_Debug_UseNPCLookAtIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UseNPCPoseDriverIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UseNPCPoseDriverIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UseNPCPoseDriverIK");

	Params::NoceCheatManager_Debug_UseNPCPoseDriverIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerAimIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerAimIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerAimIK");

	Params::NoceCheatManager_Debug_UsePlayerAimIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerFootIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerFootIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerFootIK");

	Params::NoceCheatManager_Debug_UsePlayerFootIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerFullBodyIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerFullBodyIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerFullBodyIK");

	Params::NoceCheatManager_Debug_UsePlayerFullBodyIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerLookAtIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerLookAtIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerLookAtIK");

	Params::NoceCheatManager_Debug_UsePlayerLookAtIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerPoseDriverIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerPoseDriverIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerPoseDriverIK");

	Params::NoceCheatManager_Debug_UsePlayerPoseDriverIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.Debug_UsePlayerSkirtIK
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::Debug_UsePlayerSkirtIK(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "Debug_UsePlayerSkirtIK");

	Params::NoceCheatManager_Debug_UsePlayerSkirtIK Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.DebugGoBack
// (Final, Exec, Native, Public)

void UNoceCheatManager::DebugGoBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "DebugGoBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.DebugGoSave
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InSpotName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::DebugGoSave(class FName InSpotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "DebugGoSave");

	Params::NoceCheatManager_DebugGoSave Parms{};

	Parms.InSpotName = InSpotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.DebugGoTo
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InSpotName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::DebugGoTo(class FName InSpotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "DebugGoTo");

	Params::NoceCheatManager_DebugGoTo Parms{};

	Parms.InSpotName = InSpotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.EnableEnemyNavModifier
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::EnableEnemyNavModifier(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "EnableEnemyNavModifier");

	Params::NoceCheatManager_EnableEnemyNavModifier Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.EnablePlayerNavModifier
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::EnablePlayerNavModifier(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "EnablePlayerNavModifier");

	Params::NoceCheatManager_EnablePlayerNavModifier Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.EnableSanitySpawnSystem
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::EnableSanitySpawnSystem(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "EnableSanitySpawnSystem");

	Params::NoceCheatManager_EnableSanitySpawnSystem Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.GetDialogParentTables
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UCompositeDataTable*              CompositeDataTable                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDataTable*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDataTable*> UNoceCheatManager::GetDialogParentTables(class UCompositeDataTable* CompositeDataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "GetDialogParentTables");

	Params::NoceCheatManager_GetDialogParentTables Parms{};

	Parms.CompositeDataTable = CompositeDataTable;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatManager.GetGamePlayTagByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTagName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceCheatManager::GetGamePlayTagByName(const class FName& InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "GetGamePlayTagByName");

	Params::NoceCheatManager_GetGamePlayTagByName Parms{};

	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatManager.IsDebugInvincibleEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCheatManager::IsDebugInvincibleEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "IsDebugInvincibleEnabled");

	Params::NoceCheatManager_IsDebugInvincibleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatManager.LockNavigationBuild
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bLock                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::LockNavigationBuild(bool bLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "LockNavigationBuild");

	Params::NoceCheatManager_LockNavigationBuild Parms{};

	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.NoceBugItGo
// (Final, Exec, Native, Private, HasOutParams)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          GatewayString                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::NoceBugItGo(float X, float Y, float Z, float pitch, float Yaw, float Roll, class FString* GatewayString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "NoceBugItGo");

	Params::NoceCheatManager_NoceBugItGo Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.pitch = pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GatewayString != nullptr)
		*GatewayString = std::move(Parms.GatewayString);
}


// Function GameNoce.NoceCheatManager.OnChangePlayerCharMeshTypeWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatManager::OnChangePlayerCharMeshTypeWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "OnChangePlayerCharMeshTypeWindowDecided");

	Params::NoceCheatManager_OnChangePlayerCharMeshTypeWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.OnStartTutorialWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatManager::OnStartTutorialWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "OnStartTutorialWindowDecided");

	Params::NoceCheatManager_OnStartTutorialWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.OnTestDiloagWindowDecided
// (Final, Native, Protected)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatManager::OnTestDiloagWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "OnTestDiloagWindowDecided");

	Params::NoceCheatManager_OnTestDiloagWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.SetDrawNavLinkInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::SetDrawNavLinkInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "SetDrawNavLinkInfo");

	Params::NoceCheatManager_SetDrawNavLinkInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.SetNoceAIGlobalThinkEnable
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::SetNoceAIGlobalThinkEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "SetNoceAIGlobalThinkEnable");

	Params::NoceCheatManager_SetNoceAIGlobalThinkEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.SetNoceEnv
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    AreaName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RuntimeState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::SetNoceEnv(const class FString& AreaName, int32 Index_0, int32 RuntimeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "SetNoceEnv");

	Params::NoceCheatManager_SetNoceEnv Parms{};

	Parms.AreaName = std::move(AreaName);
	Parms.Index_0 = Index_0;
	Parms.RuntimeState = RuntimeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.SetNoceEnvExtra
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    AreaName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RuntimeState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::SetNoceEnvExtra(const class FString& AreaName, int32 Index_0, int32 RuntimeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "SetNoceEnvExtra");

	Params::NoceCheatManager_SetNoceEnvExtra Parms{};

	Parms.AreaName = std::move(AreaName);
	Parms.Index_0 = Index_0;
	Parms.RuntimeState = RuntimeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowDebugControlRig
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowDebugControlRig(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowDebugControlRig");

	Params::NoceCheatManager_ShowDebugControlRig Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowDebugKawaii
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowDebugKawaii(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowDebugKawaii");

	Params::NoceCheatManager_ShowDebugKawaii Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowDebugRigidBody
// (Final, Exec, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowDebugRigidBody(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowDebugRigidBody");

	Params::NoceCheatManager_ShowDebugRigidBody Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowNoceAINoiseInfo
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowNoceAINoiseInfo(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowNoceAINoiseInfo");

	Params::NoceCheatManager_ShowNoceAINoiseInfo Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowNoceAISpawnerInfo
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowNoceAISpawnerInfo(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowNoceAISpawnerInfo");

	Params::NoceCheatManager_ShowNoceAISpawnerInfo Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ShowNoceAISystemInfo
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatManager::ShowNoceAISystemInfo(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ShowNoceAISystemInfo");

	Params::NoceCheatManager_ShowNoceAISystemInfo Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.SpawnDialogVOTestActor
// (Final, Exec, Native, Public)

void UNoceCheatManager::SpawnDialogVOTestActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "SpawnDialogVOTestActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.TestDialog
// (Final, Exec, Native, Public)

void UNoceCheatManager::TestDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "TestDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleCinematicNote
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleCinematicNote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleCinematicNote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleFog
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleFog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleFog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleGameClockInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleGameClockInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleGameClockInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleGameSettingInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleGameSettingInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleGameSettingInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNoceAIGlobalThinkEnable
// (Final, Exec, Native, Public)

void UNoceCheatManager::ToggleNoceAIGlobalThinkEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNoceAIGlobalThinkEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNoceBattlePositionInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleNoceBattlePositionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNoceBattlePositionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNoceBattlePositionSystem
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleNoceBattlePositionSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNoceBattlePositionSystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNoceDialogInfo
// (Final, Exec, Native, Public)

void UNoceCheatManager::ToggleNoceDialogInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNoceDialogInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNocePPVDetailInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleNocePPVDetailInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNocePPVDetailInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleNocePPVInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleNocePPVInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleNocePPVInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleOnewayInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleOnewayInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleOnewayInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleOnlyPPVInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleOnlyPPVInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleOnlyPPVInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleProgressInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleProgressInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleProgressInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleSweetLightCh
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleSweetLightCh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleSweetLightCh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleSweetLightEnv
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleSweetLightEnv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleSweetLightEnv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatManager.ToggleSweetLightMoon
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatManager::ToggleSweetLightMoon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatManager", "ToggleSweetLightMoon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.AddAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimWidget::AddAnimation(class UWidgetAnimation* Animation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "AddAnimation");

	Params::NoceAnimWidget_AddAnimation Parms{};

	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.BP_ForceClose
// (Event, Protected, BlueprintEvent)

void UNoceAnimWidget::BP_ForceClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "BP_ForceClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceAnimWidget.BP_HideCommon
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimWidget::BP_HideCommon(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "BP_HideCommon");

	Params::NoceAnimWidget_BP_HideCommon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceAnimWidget.BP_ShowCommon
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimWidget::BP_ShowCommon(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "BP_ShowCommon");

	Params::NoceAnimWidget_BP_ShowCommon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceAnimWidget.ForceClose
// (Native, Public, BlueprintCallable)

void UNoceAnimWidget::ForceClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "ForceClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.ForceHide
// (Native, Public, BlueprintCallable)

void UNoceAnimWidget::ForceHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "ForceHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.GetFadeInAnim
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UNoceAnimWidget::GetFadeInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "GetFadeInAnim");

	Params::NoceAnimWidget_GetFadeInAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimWidget.GetFadeOutAnim
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UNoceAnimWidget::GetFadeOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "GetFadeOutAnim");

	Params::NoceAnimWidget_GetFadeOutAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimWidget.Hide
// (Native, Public, BlueprintCallable)

void UNoceAnimWidget::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.IsShowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimWidget::IsShowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "IsShowing");

	Params::NoceAnimWidget_IsShowing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimWidget.OnFadeInCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceAnimWidget::OnFadeInCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "OnFadeInCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.OnFadeOutCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceAnimWidget::OnFadeOutCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "OnFadeOutCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.SetAllData
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimWidget::SetAllData(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "SetAllData");

	Params::NoceAnimWidget_SetAllData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceAnimWidget.Show
// (Native, Public, BlueprintCallable)

void UNoceAnimWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimWidget.StopAnimations
// (Final, Native, Protected, BlueprintCallable)

void UNoceAnimWidget::StopAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimWidget", "StopAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusableWidget.BP_DisableInputs
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFocusableWidget::BP_DisableInputs(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "BP_DisableInputs");

	Params::NoceFocusableWidget_BP_DisableInputs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceFocusableWidget.BP_EnableInputs
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFocusableWidget::BP_EnableInputs(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "BP_EnableInputs");

	Params::NoceFocusableWidget_BP_EnableInputs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceFocusableWidget.BP_TryFocusDefaultWidget
// (Native, Protected, BlueprintCallable)
// Parameters:
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UNoceFocusableWidget::BP_TryFocusDefaultWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "BP_TryFocusDefaultWidget");

	Params::NoceFocusableWidget_BP_TryFocusDefaultWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFocusableWidget.Cancel
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFocusableWidget::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "Cancel");

	Params::NoceFocusableWidget_Cancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFocusableWidget.Confirm
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFocusableWidget::Confirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "Confirm");

	Params::NoceFocusableWidget_Confirm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFocusableWidget.DisableInputs
// (Final, Native, Protected, BlueprintCallable)

void UNoceFocusableWidget::DisableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "DisableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusableWidget.EnableInputs
// (Final, Native, Protected, BlueprintCallable)

void UNoceFocusableWidget::EnableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "EnableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusableWidget.HandleNotRepeatKeys
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInputEvent&               InInputEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFocusableWidget::HandleNotRepeatKeys(const struct FInputEvent& InInputEvent, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "HandleNotRepeatKeys");

	Params::NoceFocusableWidget_HandleNotRepeatKeys Parms{};

	Parms.InInputEvent = std::move(InInputEvent);
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFocusableWidget.HandleRepeatKeys
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInputEvent&               InInputEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFocusableWidget::HandleRepeatKeys(const struct FInputEvent& InInputEvent, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "HandleRepeatKeys");

	Params::NoceFocusableWidget_HandleRepeatKeys Parms{};

	Parms.InInputEvent = std::move(InInputEvent);
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFocusableWidget.HideGuide
// (Final, Native, Protected, BlueprintCallable)

void UNoceFocusableWidget::HideGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "HideGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusableWidget.SetCursorVisibility
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InIsVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFocusableWidget::SetCursorVisibility(bool InIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "SetCursorVisibility");

	Params::NoceFocusableWidget_SetCursorVisibility Parms{};

	Parms.InIsVisible = InIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusableWidget.ShowGuide
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InGuide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFocusableWidget::ShowGuide(class FName InGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusableWidget", "ShowGuide");

	Params::NoceFocusableWidget_ShowGuide Parms{};

	Parms.InGuide = InGuide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserArrowWidget.OnMouseButtonDownArrow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGeometry&                 InGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UNoceChooserArrowWidget::OnMouseButtonDownArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserArrowWidget", "OnMouseButtonDownArrow");

	Params::NoceChooserArrowWidget_OnMouseButtonDownArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusDecalActor.BP_OnOutOfGameplay
// (Event, Public, BlueprintEvent)

void AMucusDecalActor::BP_OnOutOfGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "BP_OnOutOfGameplay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.MucusDecalActor.BP_Transformation
// (Event, Public, BlueprintEvent)

void AMucusDecalActor::BP_Transformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "BP_Transformation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.MucusDecalActor.DestroyMe
// (Final, Native, Public, BlueprintCallable)

void AMucusDecalActor::DestroyMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "DestroyMe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.HasTransformed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMucusDecalActor::HasTransformed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "HasTransformed");

	Params::MucusDecalActor_HasTransformed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusDecalActor.IsEnvironmentType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMucusDecalActor::IsEnvironmentType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "IsEnvironmentType");

	Params::MucusDecalActor_IsEnvironmentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusDecalActor.IsOutOfGameplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMucusDecalActor::IsOutOfGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "IsOutOfGameplay");

	Params::MucusDecalActor_IsOutOfGameplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusDecalActor.OnTransformReuse
// (Final, Native, Protected)

void AMucusDecalActor::OnTransformReuse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "OnTransformReuse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.PauseDestroyTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMucusDecalActor::PauseDestroyTimer(bool InPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "PauseDestroyTimer");

	Params::MucusDecalActor_PauseDestroyTimer Parms{};

	Parms.InPause = InPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.ReceiveDestroyRequest
// (Final, Native, Protected)

void AMucusDecalActor::ReceiveDestroyRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "ReceiveDestroyRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.ReceiveEnemyDeadEvent
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMucusDecalActor::ReceiveEnemyDeadEvent(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "ReceiveEnemyDeadEvent");

	Params::MucusDecalActor_ReceiveEnemyDeadEvent Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.RequestTransformation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InRequester                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMucusDecalActor::RequestTransformation(class AActor* InRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "RequestTransformation");

	Params::MucusDecalActor_RequestTransformation Parms{};

	Parms.InRequester = InRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.RequestTransformationAuto
// (Final, Native, Protected)

void AMucusDecalActor::RequestTransformationAuto()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "RequestTransformationAuto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.SetTransformLifeSpan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InLifespan                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMucusDecalActor::SetTransformLifeSpan(float InLifespan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "SetTransformLifeSpan");

	Params::MucusDecalActor_SetTransformLifeSpan Parms{};

	Parms.InLifespan = InLifespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusDecalActor.SetTransformReuseTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMucusDecalActor::SetTransformReuseTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusDecalActor", "SetTransformReuseTime");

	Params::MucusDecalActor_SetTransformReuseTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldSubsystem.Deinitialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceWorldSubsystem::Deinitialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldSubsystem", "Deinitialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceWorldSubsystem.Initialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceWorldSubsystem::Initialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldSubsystem", "Initialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceWorldSubsystem.WorldBeginPlay_BP
// (Event, Protected, BlueprintEvent)

void UNoceWorldSubsystem::WorldBeginPlay_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldSubsystem", "WorldBeginPlay_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCollectibleListWidget.SetAllData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UCollectibleListObject*>&Items                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceCollectibleListWidget::SetAllData(const TArray<class UCollectibleListObject*>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCollectibleListWidget", "SetAllData");

	Params::NoceCollectibleListWidget_SetAllData Parms{};

	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCollectibleListWidget.SetKeyItemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              Items                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceCollectibleListWidget::SetKeyItemData(const TArray<class FName>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCollectibleListWidget", "SetKeyItemData");

	Params::NoceCollectibleListWidget_SetKeyItemData Parms{};

	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCollectibleListWidget.SetLetterGroupData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              LetterGroups                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              NewLetterGroups                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             LastGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCollectibleListWidget::SetLetterGroupData(const TArray<class FName>& LetterGroups, const TArray<class FName>& NewLetterGroups, class FName LastGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCollectibleListWidget", "SetLetterGroupData");

	Params::NoceCollectibleListWidget_SetLetterGroupData Parms{};

	Parms.LetterGroups = std::move(LetterGroups);
	Parms.NewLetterGroups = std::move(NewLetterGroups);
	Parms.LastGroup = LastGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.GetMucusByDistance2D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMucusDecalActor*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMucusDecalActor*> UMucusSubsystem::GetMucusByDistance2D(const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "GetMucusByDistance2D");

	Params::MucusSubsystem_GetMucusByDistance2D Parms{};

	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusSubsystem.HandleSporeEruption
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   CenterLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InRequester                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMucusSubsystem::HandleSporeEruption(const struct FVector& CenterLocation, float Radius, class AActor* InRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "HandleSporeEruption");

	Params::MucusSubsystem_HandleSporeEruption Parms{};

	Parms.CenterLocation = std::move(CenterLocation);
	Parms.Radius = Radius;
	Parms.InRequester = InRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.IsMucusNearby
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMucusSubsystem::IsMucusNearby(const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "IsMucusNearby");

	Params::MucusSubsystem_IsMucusNearby Parms{};

	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.MucusSubsystem.RegisterMucus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMucusDecalActor*                 Mucus                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMucusSubsystem::RegisterMucus(class AMucusDecalActor* Mucus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "RegisterMucus");

	Params::MucusSubsystem_RegisterMucus Parms{};

	Parms.Mucus = Mucus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.RemoveAllMucus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMucusSubsystem::RemoveAllMucus(bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "RemoveAllMucus");

	Params::MucusSubsystem_RemoveAllMucus Parms{};

	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.RemoveOldestMucus
// (Final, Native, Public, BlueprintCallable)

void UMucusSubsystem::RemoveOldestMucus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "RemoveOldestMucus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.RequestTransformAllMucus
// (Final, Native, Public, BlueprintCallable)

void UMucusSubsystem::RequestTransformAllMucus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "RequestTransformAllMucus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.MucusSubsystem.UnregisterMucus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMucusDecalActor*                 Mucus                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMucusSubsystem::UnregisterMucus(class AMucusDecalActor* Mucus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MucusSubsystem", "UnregisterMucus");

	Params::MucusSubsystem_UnregisterMucus Parms{};

	Parms.Mucus = Mucus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookBookmark.Deactivate
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANoceNotebookBookmark::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceNotebookBookmark.GetIsLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceNotebookBookmark::GetIsLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "GetIsLeft");

	Params::NoceNotebookBookmark_GetIsLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookBookmark.GetPageIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceNotebookBookmark::GetPageIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "GetPageIndex");

	Params::NoceNotebookBookmark_GetPageIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookBookmark.GetPosIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceNotebookBookmark::GetPosIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "GetPosIndex");

	Params::NoceNotebookBookmark_GetPosIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookBookmark.OnFadeIn
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              NeedFastFadeIn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::OnFadeIn(const bool NeedFastFadeIn, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "OnFadeIn");

	Params::NoceNotebookBookmark_OnFadeIn Parms{};

	Parms.NeedFastFadeIn = NeedFastFadeIn;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookBookmark.OnFadeOut
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              NeedFastFadeOut                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::OnFadeOut(const bool NeedFastFadeOut, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "OnFadeOut");

	Params::NoceNotebookBookmark_OnFadeOut Parms{};

	Parms.NeedFastFadeOut = NeedFastFadeOut;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookBookmark.ResetPlayRate
// (Final, Native, Public, BlueprintCallable)

void ANoceNotebookBookmark::ResetPlayRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "ResetPlayRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookBookmark.SetIsLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::SetIsLeft(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "SetIsLeft");

	Params::NoceNotebookBookmark_SetIsLeft Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookBookmark.SetPageIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::SetPageIndex(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "SetPageIndex");

	Params::NoceNotebookBookmark_SetPageIndex Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookBookmark.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::SetPlayRate(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "SetPlayRate");

	Params::NoceNotebookBookmark_SetPlayRate Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookBookmark.SetPosIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNotebookBookmark::SetPosIndex(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookBookmark", "SetPosIndex");

	Params::NoceNotebookBookmark_SetPosIndex Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAbilitySystemComponent.ChangeEffectDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FActiveGameplayEffectHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDiff                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAbilitySystemComponent::ChangeEffectDuration(const struct FActiveGameplayEffectHandle& Handle, float TimeDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAbilitySystemComponent", "ChangeEffectDuration");

	Params::NoceAbilitySystemComponent_ChangeEffectDuration Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TimeDiff = TimeDiff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePerfTestController.OnGameStateSet
// (Final, Native, Protected)
// Parameters:
// const class AGameStateBase*             GameStateBase                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePerfTestController::OnGameStateSet(const class AGameStateBase* GameStateBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePerfTestController", "OnGameStateSet");

	Params::NocePerfTestController_OnGameStateSet Parms{};

	Parms.GameStateBase = GameStateBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePerfTestController.OnWorldBeginPlay
// (Final, Native, Protected)

void UNocePerfTestController::OnWorldBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePerfTestController", "OnWorldBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNewGameDataAsset.GetDefaultGameRound
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType UNoceNewGameDataAsset::GetDefaultGameRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewGameDataAsset", "GetDefaultGameRound");

	Params::NoceNewGameDataAsset_GetDefaultGameRound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAchievementSubsystem.AddAchievementRecordByKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceMiscAchievementType                InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::AddAchievementRecordByKey(ENoceMiscAchievementType InType, class FName InKey, int32 InValue, float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "AddAchievementRecordByKey");

	Params::NoceAchievementSubsystem_AddAchievementRecordByKey Parms{};

	Parms.InType = InType;
	Parms.InKey = InKey;
	Parms.InValue = InValue;
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.IsRecordCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAchievementSubsystem::IsRecordCompleted(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "IsRecordCompleted");

	Params::NoceAchievementSubsystem_IsRecordCompleted Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAchievementSubsystem.OnAddConsumableItem
// (Final, Native, Protected)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InQuantity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnAddConsumableItem(class FName InItemName, int32 InQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnAddConsumableItem");

	Params::NoceAchievementSubsystem_OnAddConsumableItem Parms{};

	Parms.InItemName = InItemName;
	Parms.InQuantity = InQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnAddItem
// (Final, Native, Protected)
// Parameters:
// ENoceInventoryType                      InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnAddItem(ENoceInventoryType InType, class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnAddItem");

	Params::NoceAchievementSubsystem_OnAddItem Parms{};

	Parms.InType = InType;
	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnAdditionalTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnAdditionalTagChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnAdditionalTagChanged");

	Params::NoceAchievementSubsystem_OnAdditionalTagChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnAddNewWeapon
// (Final, Native, Protected)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnAddNewWeapon(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnAddNewWeapon");

	Params::NoceAchievementSubsystem_OnAddNewWeapon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnAddNotebookID
// (Final, Native, Protected)
// Parameters:
// ENoceNotebookType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnAddNotebookID(ENoceNotebookType InType, class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnAddNotebookID");

	Params::NoceAchievementSubsystem_OnAddNotebookID Parms{};

	Parms.InType = InType;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnEnemyDead
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InEnemyActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnEnemyDead(class AActor* InEnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnEnemyDead");

	Params::NoceAchievementSubsystem_OnEnemyDead Parms{};

	Parms.InEnemyActor = InEnemyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnEnemyFakeDead
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InEnemyActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnEnemyFakeDead(class AActor* InEnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnEnemyFakeDead");

	Params::NoceAchievementSubsystem_OnEnemyFakeDead Parms{};

	Parms.InEnemyActor = InEnemyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnPlayerDie
// (Final, Native, Protected)

void UNoceAchievementSubsystem::OnPlayerDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnPlayerDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnPlayerMaxLevelChanged
// (Final, Native, Protected)
// Parameters:
// ENoceUpgradeType                        InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnPlayerMaxLevelChanged(ENoceUpgradeType InType, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnPlayerMaxLevelChanged");

	Params::NoceAchievementSubsystem_OnPlayerMaxLevelChanged Parms{};

	Parms.InType = InType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnPlayerTakeDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComboName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnPlayerTakeDamage(class AActor* Attacker, class FName ComboName, float InHealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnPlayerTakeDamage");

	Params::NoceAchievementSubsystem_OnPlayerTakeDamage Parms{};

	Parms.Attacker = Attacker;
	Parms.ComboName = ComboName;
	Parms.InHealthDamage = InHealthDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnProgressChanged");

	Params::NoceAchievementSubsystem_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnProgressInitialized");

	Params::NoceAchievementSubsystem_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAchievementSubsystem.OnUseConsumableItem
// (Final, Native, Protected)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAchievementSubsystem::OnUseConsumableItem(class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAchievementSubsystem", "OnUseConsumableItem");

	Params::NoceAchievementSubsystem_OnUseConsumableItem Parms{};

	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.AbortAction
// (Final, Native, Public, BlueprintCallable)

void UNoceActionBase::AbortAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "AbortAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.CompleteAction
// (Final, Native, Public, BlueprintCallable)

void UNoceActionBase::CompleteAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "CompleteAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.DebugGetActionInfo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceActionBase::DebugGetActionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "DebugGetActionInfo");

	Params::NoceActionBase_DebugGetActionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActionBase.ExecuteAction
// (Final, Native, Public)

void UNoceActionBase::ExecuteAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "ExecuteAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.GetActionStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionStatus                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceActionStatus UNoceActionBase::GetActionStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "GetActionStatus");

	Params::NoceActionBase_GetActionStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActionBase.PerformAction
// (Native, Event, Protected, BlueprintEvent)

void UNoceActionBase::PerformAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "PerformAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.PrepareAction
// (Native, Event, Public, BlueprintEvent)

void UNoceActionBase::PrepareAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "PrepareAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActionBase.GetParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceActionBase::GetParentActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "GetParentActor");

	Params::NoceActionBase_GetParentActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActionBase.GetPersistentOuter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UNoceActionBase::GetPersistentOuter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActionBase", "GetPersistentOuter");

	Params::NoceActionBase_GetPersistentOuter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionBase.BP_DoCheckCondition
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceConditionBase::BP_DoCheckCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionBase", "BP_DoCheckCondition");

	Params::NoceConditionBase_BP_DoCheckCondition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionBase.CheckCondition
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceConditionBase::CheckCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionBase", "CheckCondition");

	Params::NoceConditionBase_CheckCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionBase.DebugGetConditionInfo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceConditionBase::DebugGetConditionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionBase", "DebugGetConditionInfo");

	Params::NoceConditionBase_DebugGetConditionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionBase.GetParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceConditionBase::GetParentActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionBase", "GetParentActor");

	Params::NoceConditionBase_GetParentActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionBase.GetPersistentOuter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UNoceConditionBase::GetPersistentOuter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionBase", "GetPersistentOuter");

	Params::NoceConditionBase_GetPersistentOuter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActiveUserWidget.CheckAndShow
// (Final, Native, Public, BlueprintCallable)

void UNoceActiveUserWidget::CheckAndShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActiveUserWidget", "CheckAndShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.ActivityAvailabilityChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::ActivityAvailabilityChanged(const class FString& ActivityID, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ActivityAvailabilityChanged");

	Params::NoceActivityInstance_ActivityAvailabilityChanged Parms{};

	Parms.ActivityID = std::move(ActivityID);
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.CanActivateByActivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::CanActivateByActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "CanActivateByActivity");

	Params::NoceActivityInstance_CanActivateByActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.CancelAndHideActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::CancelAndHideActivity(const class FString& ActivityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "CancelAndHideActivity");

	Params::NoceActivityInstance_CancelAndHideActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.CheckToStartNewGameActivity
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::CheckToStartNewGameActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "CheckToStartNewGameActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.CompleteAndHideActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::CompleteAndHideActivity(const class FString& ActivityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "CompleteAndHideActivity");

	Params::NoceActivityInstance_CompleteAndHideActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.ContinueGame_BP
// (Event, Public, BlueprintEvent)

void UNoceActivityInstance::ContinueGame_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ContinueGame_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceActivityInstance.DoesSystemSlotExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::DoesSystemSlotExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "DoesSystemSlotExist");

	Params::NoceActivityInstance_DoesSystemSlotExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.EndActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Outcome                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::EndActivity(const class FString& ActivityID, int32 Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "EndActivity");

	Params::NoceActivityInstance_EndActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);
	Parms.Outcome = Outcome;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.GetNoceGameInstance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNoceGameInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceGameInstance* UNoceActivityInstance::GetNoceGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "GetNoceGameInstance");

	Params::NoceActivityInstance_GetNoceGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.GetNocePlayerController
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class ANocePlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerController* UNoceActivityInstance::GetNocePlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "GetNocePlayerController");

	Params::NoceActivityInstance_GetNocePlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.GetNoceUISubsystem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNoceUISubsystem*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceUISubsystem* UNoceActivityInstance::GetNoceUISubsystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "GetNoceUISubsystem");

	Params::NoceActivityInstance_GetNoceUISubsystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.HandleActivatedByActivityCompleted
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::HandleActivatedByActivityCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "HandleActivatedByActivityCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.HandleGameActivityActivationRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::HandleGameActivityActivationRequest(const class FString& ActivityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "HandleGameActivityActivationRequest");

	Params::NoceActivityInstance_HandleGameActivityActivationRequest Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.HasAnySaveGame
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool*                                   IsGameClearSaveGame                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::HasAnySaveGame(bool* IsGameClearSaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "HasAnySaveGame");

	Params::NoceActivityInstance_HasAnySaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsGameClearSaveGame != nullptr)
		*IsGameClearSaveGame = Parms.IsGameClearSaveGame;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.HasToHandleActivateByActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::HasToHandleActivateByActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "HasToHandleActivateByActivity");

	Params::NoceActivityInstance_HasToHandleActivateByActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.HideAllActivities
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::HideAllActivities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "HideAllActivities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.IsLoadingGameClearSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::IsLoadingGameClearSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "IsLoadingGameClearSaveData");

	Params::NoceActivityInstance_IsLoadingGameClearSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.IsLoadingLatestSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::IsLoadingLatestSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "IsLoadingLatestSaveData");

	Params::NoceActivityInstance_IsLoadingLatestSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivityInstance.NewGame_BP
// (Event, Public, BlueprintEvent)

void UNoceActivityInstance::NewGame_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "NewGame_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceActivityInstance.NewGameWithClearGame_BP
// (Event, Public, BlueprintEvent)

void UNoceActivityInstance::NewGameWithClearGame_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "NewGameWithClearGame_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceActivityInstance.ResetAllActiveActivities
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::ResetAllActiveActivities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ResetAllActiveActivities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.ResetCurrentActivity
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::ResetCurrentActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ResetCurrentActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.ResumeActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            InProgressTasks                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FString>&            CompletedTasks                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceActivityInstance::ResumeActivity(const class FString& ActivityID, const TArray<class FString>& InProgressTasks, const TArray<class FString>& CompletedTasks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ResumeActivity");

	Params::NoceActivityInstance_ResumeActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);
	Parms.InProgressTasks = std::move(InProgressTasks);
	Parms.CompletedTasks = std::move(CompletedTasks);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.ResumeAndShowActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            InProgressTasks                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FString>&            CompletedTasks                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceActivityInstance::ResumeAndShowActivity(const class FString& ActivityID, const TArray<class FString>& InProgressTasks, const TArray<class FString>& CompletedTasks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "ResumeAndShowActivity");

	Params::NoceActivityInstance_ResumeAndShowActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);
	Parms.InProgressTasks = std::move(InProgressTasks);
	Parms.CompletedTasks = std::move(CompletedTasks);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.StartActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::StartActivity(const class FString& ActivityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "StartActivity");

	Params::NoceActivityInstance_StartActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.StartAndShowActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivityInstance::StartAndShowActivity(const class FString& ActivityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "StartAndShowActivity");

	Params::NoceActivityInstance_StartAndShowActivity Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.StartNewGame02Activity
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::StartNewGame02Activity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "StartNewGame02Activity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.TrimActivityLog
// (Final, Native, Public, BlueprintCallable)

void UNoceActivityInstance::TrimActivityLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "TrimActivityLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivityInstance.IsActivityObjectID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    ActivityID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActivityInstance::IsActivityObjectID(const class FString& ActivityID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivityInstance", "IsActivityObjectID");

	Params::NoceActivityInstance_IsActivityObjectID Parms{};

	Parms.ActivityID = std::move(ActivityID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActivitySubsystem.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivitySubsystem::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivitySubsystem", "OnProgressChanged");

	Params::NoceActivitySubsystem_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivitySubsystem.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActivitySubsystem::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivitySubsystem", "OnProgressInitialized");

	Params::NoceActivitySubsystem_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActivitySubsystem.UpdateActivitiesByCurrentProgress
// (Final, Native, Public, BlueprintCallable)

void UNoceActivitySubsystem::UpdateActivitiesByCurrentProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActivitySubsystem", "UpdateActivitiesByCurrentProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceANS_Player_DisableSkirt.SetSkirtAlpha
// (Final, Native, Protected, Const)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceANS_Player_DisableSkirt::SetSkirtAlpha(float InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceANS_Player_DisableSkirt", "SetSkirtAlpha");

	Params::NoceANS_Player_DisableSkirt_SetSkirtAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActor.BP_OnRecordLoaded
// (Event, Public, BlueprintEvent)

void ANoceActor::BP_OnRecordLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActor", "BP_OnRecordLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceActor.HasRecorded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceActor::HasRecorded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActor", "HasRecorded");

	Params::NoceActor_HasRecorded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.AddPreloadSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActorReferenceDepotSubsystem::AddPreloadSequence(class ULevelSequence* InSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "AddPreloadSequence");

	Params::NoceActorReferenceDepotSubsystem_AddPreloadSequence Parms{};

	Parms.InSequence = InSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetActorFromPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceActorReferenceDepotSubsystem::GetActorFromPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetActorFromPath");

	Params::NoceActorReferenceDepotSubsystem_GetActorFromPath Parms{};

	Parms.InPath = std::move(InPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetActorFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTag                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceActorReferenceDepotSubsystem::GetActorFromTag(const class FName& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetActorFromTag");

	Params::NoceActorReferenceDepotSubsystem_GetActorFromTag Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetActorsFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTag                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActorReferenceDepotSubsystem::GetActorsFromTag(const class FName& InTag, TArray<class AActor*>* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetActorsFromTag");

	Params::NoceActorReferenceDepotSubsystem_GetActorsFromTag Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.LocateBoundObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelSequenceActor*              SequenceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<TSubclassOf<class AActor>, struct FNoceActorRefDepotData>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<TSubclassOf<class AActor>, struct FNoceActorRefDepotData> UNoceActorReferenceDepotSubsystem::LocateBoundObjects(class ULevelSequence* Sequence, class ALevelSequenceActor* SequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "LocateBoundObjects");

	Params::NoceActorReferenceDepotSubsystem_LocateBoundObjects Parms{};

	Parms.Sequence = Sequence;
	Parms.SequenceActor = SequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.OnEnterCinematic
// (Final, Native, Protected)

void UNoceActorReferenceDepotSubsystem::OnEnterCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "OnEnterCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.OnExitCinematic
// (Final, Native, Protected)

void UNoceActorReferenceDepotSubsystem::OnExitCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "OnExitCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.ProcessSeqEvents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTagGroup                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActorReferenceDepotSubsystem::ProcessSeqEvents(const class FName& InTagGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "ProcessSeqEvents");

	Params::NoceActorReferenceDepotSubsystem_ProcessSeqEvents Parms{};

	Parms.InTagGroup = InTagGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.RegisterActorReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActorReferenceDepotSubsystem::RegisterActorReference(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "RegisterActorReference");

	Params::NoceActorReferenceDepotSubsystem_RegisterActorReference Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.RemovePreloadSeqDataFromCurrentSeqData
// (Final, Native, Public, BlueprintCallable)

void UNoceActorReferenceDepotSubsystem::RemovePreloadSeqDataFromCurrentSeqData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "RemovePreloadSeqDataFromCurrentSeqData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.RemovePreloadSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActorReferenceDepotSubsystem::RemovePreloadSequence(class ULevelSequence* InSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "RemovePreloadSequence");

	Params::NoceActorReferenceDepotSubsystem_RemovePreloadSequence Parms{};

	Parms.InSequence = InSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.ResetCurrentSeqData
// (Final, Native, Public, BlueprintCallable)

void UNoceActorReferenceDepotSubsystem::ResetCurrentSeqData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "ResetCurrentSeqData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.ResetPreloadAssets
// (Final, Native, Protected)

void UNoceActorReferenceDepotSubsystem::ResetPreloadAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "ResetPreloadAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.RollbackSeqEvents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTagGroup                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActorReferenceDepotSubsystem::RollbackSeqEvents(const class FName& InTagGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "RollbackSeqEvents");

	Params::NoceActorReferenceDepotSubsystem_RollbackSeqEvents Parms{};

	Parms.InTagGroup = InTagGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.UnregisterActorReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActorReferenceDepotSubsystem::UnregisterActorReference(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "UnregisterActorReference");

	Params::NoceActorReferenceDepotSubsystem_UnregisterActorReference Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.UpdateCurrentSeqData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      RowName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceActorReferenceDepotSubsystem::UpdateCurrentSeqData(const class UDataTable* DataTable, const class FName& RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "UpdateCurrentSeqData");

	Params::NoceActorReferenceDepotSubsystem_UpdateCurrentSeqData Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.WaitForCurrentSeqDataStreamingTextures
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActorReferenceDepotSubsystem::WaitForCurrentSeqDataStreamingTextures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "WaitForCurrentSeqDataStreamingTextures");

	Params::NoceActorReferenceDepotSubsystem_WaitForCurrentSeqDataStreamingTextures Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetCurrentCineChars
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ANoceCharacter*>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ANoceCharacter*> UNoceActorReferenceDepotSubsystem::GetCurrentCineChars() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetCurrentCineChars");

	Params::NoceActorReferenceDepotSubsystem_GetCurrentCineChars Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetCurrentSeqData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FNoceSeqData               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FNoceSeqData UNoceActorReferenceDepotSubsystem::GetCurrentSeqData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetCurrentSeqData");

	Params::NoceActorReferenceDepotSubsystem_GetCurrentSeqData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.GetDefaultEventTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UNoceActorReferenceDepotSubsystem::GetDefaultEventTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "GetDefaultEventTag");

	Params::NoceActorReferenceDepotSubsystem_GetDefaultEventTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceActorReferenceDepotSubsystem.IsSetCurrentSeqData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceActorReferenceDepotSubsystem::IsSetCurrentSeqData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceActorReferenceDepotSubsystem", "IsSetCurrentSeqData");

	Params::NoceActorReferenceDepotSubsystem_IsSetCurrentSeqData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCommonUINavigateData.GetNavigateTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FromIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceUIInputAction                      InDir                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UNoceCommonUINavigateData::GetNavigateTargets(int32 FromIndex, ENoceUIInputAction InDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonUINavigateData", "GetNavigateTargets");

	Params::NoceCommonUINavigateData_GetNavigateTargets Parms{};

	Parms.FromIndex = FromIndex;
	Parms.InDir = InDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIAlertController.GetFirstSetupTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UNoceAIAlertController::GetFirstSetupTargetTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "GetFirstSetupTargetTransform");

	Params::NoceAIAlertController_GetFirstSetupTargetTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIAlertController.GetLockAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAIAlertController::GetLockAlertness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "GetLockAlertness");

	Params::NoceAIAlertController_GetLockAlertness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIAlertController.IsLockTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAIAlertController::IsLockTimerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "IsLockTimerActive");

	Params::NoceAIAlertController_IsLockTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIAlertController.ResetAlertChangingType
// (Final, Native, Public, BlueprintCallable)

void UNoceAIAlertController::ResetAlertChangingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "ResetAlertChangingType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIAlertController.SetCurrentAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreLock                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAIAlertController::SetCurrentAlertness(float Value, bool IgnoreLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "SetCurrentAlertness");

	Params::NoceAIAlertController_SetCurrentAlertness Parms{};

	Parms.Value = Value;
	Parms.IgnoreLock = IgnoreLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIAlertController.SetFirstSetupTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                InTransform                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAIAlertController::SetFirstSetupTargetTransform(const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "SetFirstSetupTargetTransform");

	Params::NoceAIAlertController_SetFirstSetupTargetTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIAlertController.SetLockAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAIAlertController::SetLockAlertness(bool IsLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "SetLockAlertness");

	Params::NoceAIAlertController_SetLockAlertness Parms{};

	Parms.IsLock = IsLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIAlertController.SetLockAlertnessDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAIAlertController::SetLockAlertnessDelay(bool IsLock, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "SetLockAlertnessDelay");

	Params::NoceAIAlertController_SetLockAlertnessDelay Parms{};

	Parms.IsLock = IsLock;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIAlertController.UpdateAlertChangingType
// (Final, Native, Public, BlueprintCallable)

void UNoceAIAlertController::UpdateAlertChangingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIAlertController", "UpdateAlertChangingType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.ApplyDead
// (Final, Native, Public, BlueprintCallable)

void ANoceAIController::ApplyDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "ApplyDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.ClearHatestTarget
// (Final, Native, Public, BlueprintCallable)

void ANoceAIController::ClearHatestTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "ClearHatestTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.GetAlertChangingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceAIAlertChangingType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceAIAlertChangingType ANoceAIController::GetAlertChangingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAlertChangingType");

	Params::NoceAIController_GetAlertChangingType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetAlertController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceAIAlertController*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceAIAlertController* ANoceAIController::GetAlertController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAlertController");

	Params::NoceAIController_GetAlertController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetAlertness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceAIController::GetAlertness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAlertness");

	Params::NoceAIController_GetAlertness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetAlertnessFirstUpdateTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ANoceAIController::GetAlertnessFirstUpdateTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAlertnessFirstUpdateTransform");

	Params::NoceAIController_GetAlertnessFirstUpdateTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetAlertType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceAIAlertType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceAIAlertType ANoceAIController::GetAlertType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAlertType");

	Params::NoceAIController_GetAlertType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetEnableThink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::GetEnableThink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetEnableThink");

	Params::NoceAIController_GetEnableThink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetEnableThinkLocal
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::GetEnableThinkLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetEnableThinkLocal");

	Params::NoceAIController_GetEnableThinkLocal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetHatestTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ANoceAIController::GetHatestTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetHatestTarget");

	Params::NoceAIController_GetHatestTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetLockAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::GetLockAlertness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetLockAlertness");

	Params::NoceAIController_GetLockAlertness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetPathFollowingCurrentTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceAIController::GetPathFollowingCurrentTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetPathFollowingCurrentTargetLocation");

	Params::NoceAIController_GetPathFollowingCurrentTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetPathFollowingStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPathFollowingStatus                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPathFollowingStatus ANoceAIController::GetPathFollowingStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetPathFollowingStatus");

	Params::NoceAIController_GetPathFollowingStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.GetPrevAlertType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceAIAlertType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceAIAlertType ANoceAIController::GetPrevAlertType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetPrevAlertType");

	Params::NoceAIController_GetPrevAlertType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.IsLockAlertTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::IsLockAlertTimerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "IsLockAlertTimerActive");

	Params::NoceAIController_IsLockAlertTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.OnPerceptionUpdated
// (Native, Protected, HasOutParams)
// Parameters:
// const TArray<class AActor*>&            UpdatedActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ANoceAIController::OnPerceptionUpdated(const TArray<class AActor*>& UpdatedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "OnPerceptionUpdated");

	Params::NoceAIController_OnPerceptionUpdated Parms{};

	Parms.UpdatedActors = std::move(UpdatedActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.OnTargetPerceptionUpdated
// (Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAIStimulus&               Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ANoceAIController::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "OnTargetPerceptionUpdated");

	Params::NoceAIController_OnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.OverrideMovementStopDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::OverrideMovementStopDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "OverrideMovementStopDistance");

	Params::NoceAIController_OverrideMovementStopDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.ResetMovementStopDistance
// (Final, Native, Public, BlueprintCallable)

void ANoceAIController::ResetMovementStopDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "ResetMovementStopDistance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.ResumeBehaviorTree
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::ResumeBehaviorTree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "ResumeBehaviorTree");

	Params::NoceAIController_ResumeBehaviorTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.SetAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreLock                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::SetAlertness(float Value, bool IgnoreLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "SetAlertness");

	Params::NoceAIController_SetAlertness Parms{};

	Parms.Value = Value;
	Parms.IgnoreLock = IgnoreLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.SetAlertnessFirstUpdateTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                InTransform                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::SetAlertnessFirstUpdateTransform(const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "SetAlertnessFirstUpdateTransform");

	Params::NoceAIController_SetAlertnessFirstUpdateTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.SetEnableThink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::SetEnableThink(bool B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "SetEnableThink");

	Params::NoceAIController_SetEnableThink Parms{};

	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.SetLockAlertness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::SetLockAlertness(bool IsLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "SetLockAlertness");

	Params::NoceAIController_SetLockAlertness Parms{};

	Parms.IsLock = IsLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.StartBehaviorTree
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::StartBehaviorTree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "StartBehaviorTree");

	Params::NoceAIController_StartBehaviorTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.StopBehaviorTree
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::StopBehaviorTree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "StopBehaviorTree");

	Params::NoceAIController_StopBehaviorTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.UpdateAIMovement
// (Final, Native, Private, BlueprintCallable)

void ANoceAIController::UpdateAIMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "UpdateAIMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.UpdateNaviMidPoint
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAIController::UpdateNaviMidPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "UpdateNaviMidPoint");

	Params::NoceAIController_UpdateNaviMidPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIController.UpdateNaviPathToMoveTarget
// (Final, Native, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAIController::UpdateNaviPathToMoveTarget(const struct FVector& InTarget, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "UpdateNaviPathToMoveTarget");

	Params::NoceAIController_UpdateNaviPathToMoveTarget Parms{};

	Parms.InTarget = std::move(InTarget);
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIController.GetAISightPerceptionViewPoint
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         out_Location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        out_Rotation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANoceAIController::GetAISightPerceptionViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAIController", "GetAISightPerceptionViewPoint");

	Params::NoceAIController_GetAISightPerceptionViewPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_Location != nullptr)
		*out_Location = std::move(Parms.out_Location);

	if (out_Rotation != nullptr)
		*out_Rotation = std::move(Parms.out_Rotation);
}


// Function GameNoce.NoceCreditWidget.AddDeltaTime
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCreditWidget::AddDeltaTime(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditWidget", "AddDeltaTime");

	Params::NoceCreditWidget_AddDeltaTime Parms{};

	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCreditWidget.GetUpdateSpeed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceCreditWidget::GetUpdateSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditWidget", "GetUpdateSpeed");

	Params::NoceCreditWidget_GetUpdateSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCreditWidget.OnSpeedUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCreditWidget::OnSpeedUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditWidget", "OnSpeedUpdated");

	Params::NoceCreditWidget_OnSpeedUpdated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCreditWidget.OnWindowFocusChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCreditWidget::OnWindowFocusChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditWidget", "OnWindowFocusChanged");

	Params::NoceCreditWidget_OnWindowFocusChanged Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCreditWidget.SetCreditDataTables
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCreditWidget::SetCreditDataTables(const class FName InName, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditWidget", "SetCreditDataTables");

	Params::NoceCreditWidget_SetCreditDataTables Parms{};

	Parms.InName = InName;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceAIFunctionLibrary.SetAIAlertBySetting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceAIController*                AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAISpawnerAlertOverride&   Setting                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceAIFunctionLibrary::SetAIAlertBySetting(class ANoceAIController* AIController, const struct FAISpawnerAlertOverride& Setting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAIFunctionLibrary", "SetAIAlertBySetting");

	Params::NoceAIFunctionLibrary_SetAIAlertBySetting Parms{};

	Parms.AIController = AIController;
	Parms.Setting = std::move(Setting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAIFunctionLibrary.SetNoceHearingRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HearingRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OldHearingRange                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAIFunctionLibrary::SetNoceHearingRange(class AAIController* Controller, float HearingRange, float* OldHearingRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAIFunctionLibrary", "SetNoceHearingRange");

	Params::NoceAIFunctionLibrary_SetNoceHearingRange Parms{};

	Parms.Controller = Controller;
	Parms.HearingRange = HearingRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldHearingRange != nullptr)
		*OldHearingRange = Parms.OldHearingRange;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAIFunctionLibrary.SetSightRadius
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SightRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OldSightRadius                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAIFunctionLibrary::SetSightRadius(class AAIController* Controller, float SightRadius, float* OldSightRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAIFunctionLibrary", "SetSightRadius");

	Params::NoceAIFunctionLibrary_SetSightRadius Parms{};

	Parms.Controller = Controller;
	Parms.SightRadius = SightRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldSightRadius != nullptr)
		*OldSightRadius = Parms.OldSightRadius;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISense_Hearing.ReportNoceNoiseEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseLineTrace                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISense_Hearing::ReportNoceNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag, bool UseLineTrace, ECollisionChannel TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAISense_Hearing", "ReportNoceNoiseEvent");

	Params::NoceAISense_Hearing_ReportNoceNoiseEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.Loudness = Loudness;
	Parms.Instigator = Instigator;
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;
	Parms.UseLineTrace = UseLineTrace;
	Parms.TraceChannel = TraceChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISpawner.CanBeAllowedToSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::CanBeAllowedToSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "CanBeAllowedToSpawn");

	Params::NoceAISpawner_CanBeAllowedToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.CanDisplayDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::CanDisplayDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "CanDisplayDebugInfo");

	Params::NoceAISpawner_CanDisplayDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.CanSpawnAtThisDifficultyLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::CanSpawnAtThisDifficultyLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "CanSpawnAtThisDifficultyLevel");

	Params::NoceAISpawner_CanSpawnAtThisDifficultyLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.GetSignificanceLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceAISpawner::GetSignificanceLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "GetSignificanceLocation");

	Params::NoceAISpawner_GetSignificanceLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.GetSpawnTargetClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> ANoceAISpawner::GetSpawnTargetClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "GetSpawnTargetClass");

	Params::NoceAISpawner_GetSpawnTargetClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.GetSpawnTransform
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ANoceAISpawner::GetSpawnTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "GetSpawnTransform");

	Params::NoceAISpawner_GetSpawnTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleAlertOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAISpawnerAlertOverride&   AlertData                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleAlertOverride(const struct FAISpawnerAlertOverride& AlertData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleAlertOverride");

	Params::NoceAISpawner_HandleAlertOverride Parms{};

	Parms.AlertData = std::move(AlertData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleAttemptRespawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleAttemptRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleAttemptRespawn");

	Params::NoceAISpawner_HandleAttemptRespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleDeleteEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleDeleteEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleDeleteEvent");

	Params::NoceAISpawner_HandleDeleteEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleDeleteSpecifyActorEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SpecifiedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleDeleteSpecifyActorEvent(class AActor* SpecifiedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleDeleteSpecifyActorEvent");

	Params::NoceAISpawner_HandleDeleteSpecifyActorEvent Parms{};

	Parms.SpecifiedActor = SpecifiedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleEnableThinkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleEnableThinkEvent(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleEnableThinkEvent");

	Params::NoceAISpawner_HandleEnableThinkEvent Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleKillEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleKillEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleKillEvent");

	Params::NoceAISpawner_HandleKillEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleSmartSpawnFlow
// (Final, Native, Public, BlueprintCallable)

void ANoceAISpawner::HandleSmartSpawnFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleSmartSpawnFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISpawner.HandleSpawnEventOnce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleSpawnEventOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleSpawnEventOnce");

	Params::NoceAISpawner_HandleSpawnEventOnce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HandleTemporaryRemoved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HandleTemporaryRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HandleTemporaryRemoved");

	Params::NoceAISpawner_HandleTemporaryRemoved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.HasSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::HasSpawnedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "HasSpawnedActor");

	Params::NoceAISpawner_HasSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.IsActorDeadOnRecord
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::IsActorDeadOnRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "IsActorDeadOnRecord");

	Params::NoceAISpawner_IsActorDeadOnRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.IsIgnoreSaveLoad
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::IsIgnoreSaveLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "IsIgnoreSaveLoad");

	Params::NoceAISpawner_IsIgnoreSaveLoad Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.IsInstantSpawnType
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::IsInstantSpawnType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "IsInstantSpawnType");

	Params::NoceAISpawner_IsInstantSpawnType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.IsSignificanceActivate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::IsSignificanceActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "IsSignificanceActivate");

	Params::NoceAISpawner_IsSignificanceActivate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.IsSpawnedOrSpawning
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::IsSpawnedOrSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "IsSpawnedOrSpawning");

	Params::NoceAISpawner_IsSpawnedOrSpawning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.OnGameProgressChanged
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAISpawner::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "OnGameProgressChanged");

	Params::NoceAISpawner_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceAISpawner.OnSpawn_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAISpawner::OnSpawn_BP(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "OnSpawn_BP");

	Params::NoceAISpawner_OnSpawn_BP Parms{};

	Parms.SpawnedActor = SpawnedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceAISpawner.ProcessSpawnerEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceAISpawnerEvent&       EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceAISpawner::ProcessSpawnerEvent(const struct FNoceAISpawnerEvent& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "ProcessSpawnerEvent");

	Params::NoceAISpawner_ProcessSpawnerEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.RegisterSignificance
// (Final, Native, Protected, BlueprintCallable)

void ANoceAISpawner::RegisterSignificance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "RegisterSignificance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISpawner.RequestSpawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    InstantSpawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ANoceAISpawner::RequestSpawn(const struct FVector& Location, const struct FRotator& Rotation, bool InstantSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "RequestSpawn");

	Params::NoceAISpawner_RequestSpawn Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.InstantSpawn = InstantSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISpawner.RequestTriggerSpawnFlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAISpawner::RequestTriggerSpawnFlow(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "RequestTriggerSpawnFlow");

	Params::NoceAISpawner_RequestTriggerSpawnFlow Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISpawner.UnRegisterSignificance
// (Final, Native, Protected, BlueprintCallable)

void ANoceAISpawner::UnRegisterSignificance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISpawner", "UnRegisterSignificance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTickableWorldSubsystem.Deinitialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceTickableWorldSubsystem::Deinitialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickableWorldSubsystem", "Deinitialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceTickableWorldSubsystem.Initialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceTickableWorldSubsystem::Initialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickableWorldSubsystem", "Initialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceTickableWorldSubsystem.Tick_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTickableWorldSubsystem::Tick_BP(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickableWorldSubsystem", "Tick_BP");

	Params::NoceTickableWorldSubsystem_Tick_BP Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceTickableWorldSubsystem.WorldBeginPlay_BP
// (Event, Protected, BlueprintEvent)

void UNoceTickableWorldSubsystem::WorldBeginPlay_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickableWorldSubsystem", "WorldBeginPlay_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceVolumeComponentBase.OnVolumeBeginOverlapBP
// (Native, Event, Protected, BlueprintEvent)

void UNoceVolumeComponentBase::OnVolumeBeginOverlapBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceVolumeComponentBase", "OnVolumeBeginOverlapBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceVolumeComponentBase.OnVolumeEndOverlapBP
// (Native, Event, Protected, BlueprintEvent)

void UNoceVolumeComponentBase::OnVolumeEndOverlapBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceVolumeComponentBase", "OnVolumeEndOverlapBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceVolumeComponentBase.RequestSpecialWeightChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SourceName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceVolumeComponentBase::RequestSpecialWeightChange(const class FString& SourceName, float InWeight, float InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceVolumeComponentBase", "RequestSpecialWeightChange");

	Params::NoceVolumeComponentBase_RequestSpecialWeightChange Parms{};

	Parms.SourceName = std::move(SourceName);
	Parms.InWeight = InWeight;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.AddNavigationBuildLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::AddNavigationBuildLock(uint8 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AddNavigationBuildLock");

	Params::NoceAISystem_AddNavigationBuildLock Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.AddRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceCharacterRecord&      InRecord                                               (Parm, NativeAccessSpecifierPublic)

void UNoceAISystem::AddRecord(const struct FNoceCharacterRecord& InRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AddRecord");

	Params::NoceAISystem_AddRecord Parms{};

	Parms.InRecord = std::move(InRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.AnyEnemyAliveBesidesFreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActorTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              BesidesCharacterTag                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::AnyEnemyAliveBesidesFreak(class FName ActorTag, const struct FGameplayTag& BesidesCharacterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AnyEnemyAliveBesidesFreak");

	Params::NoceAISystem_AnyEnemyAliveBesidesFreak Parms{};

	Parms.ActorTag = ActorTag;
	Parms.BesidesCharacterTag = std::move(BesidesCharacterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.AnyEnemyAliveByCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CharacterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::AnyEnemyAliveByCharacterName(class FName CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AnyEnemyAliveByCharacterName");

	Params::NoceAISystem_AnyEnemyAliveByCharacterName Parms{};

	Parms.CharacterName = CharacterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.AnyEnemyAliveByGameplayTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CharacterNameTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::AnyEnemyAliveByGameplayTag(const struct FGameplayTag& CharacterNameTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AnyEnemyAliveByGameplayTag");

	Params::NoceAISystem_AnyEnemyAliveByGameplayTag Parms{};

	Parms.CharacterNameTag = std::move(CharacterNameTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.AnyEnemyAliveByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::AnyEnemyAliveByTag(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "AnyEnemyAliveByTag");

	Params::NoceAISystem_AnyEnemyAliveByTag Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.BattleBGMDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::BattleBGMDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "BattleBGMDisabled");

	Params::NoceAISystem_BattleBGMDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.ClearSaveGameRecord
// (Final, Native, Public, BlueprintCallable)

void UNoceAISystem::ClearSaveGameRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "ClearSaveGameRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.DestroyAllEnemy
// (Final, Native, Public, BlueprintCallable)

void UNoceAISystem::DestroyAllEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "DestroyAllEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.EnableEnemyNavModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::EnableEnemyNavModifier(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "EnableEnemyNavModifier");

	Params::NoceAISystem_EnableEnemyNavModifier Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.EnablePlayerNavModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::EnablePlayerNavModifier(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "EnablePlayerNavModifier");

	Params::NoceAISystem_EnablePlayerNavModifier Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.GetEnemyActorByOwnedGameplayTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceAISystem::GetEnemyActorByOwnedGameplayTag(const struct FGameplayTag& GameplayTag, bool IsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyActorByOwnedGameplayTag");

	Params::NoceAISystem_GetEnemyActorByOwnedGameplayTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.IsAlive = IsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyActorByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceAISystem::GetEnemyActorByTag(const struct FGameplayTag& CharacterTag, bool ExactMatch, bool IsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyActorByTag");

	Params::NoceAISystem_GetEnemyActorByTag Parms{};

	Parms.CharacterTag = std::move(CharacterTag);
	Parms.ExactMatch = ExactMatch;
	Parms.IsAlive = IsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyActorsByContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     TagContainer                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UNoceAISystem::GetEnemyActorsByContainer(const struct FGameplayTagContainer& TagContainer, bool ExactMatch, bool IsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyActorsByContainer");

	Params::NoceAISystem_GetEnemyActorsByContainer Parms{};

	Parms.TagContainer = std::move(TagContainer);
	Parms.ExactMatch = ExactMatch;
	Parms.IsAlive = IsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyActorsByOwnedGameplayTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UNoceAISystem::GetEnemyActorsByOwnedGameplayTag(const struct FGameplayTag& GameplayTag, bool IsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyActorsByOwnedGameplayTag");

	Params::NoceAISystem_GetEnemyActorsByOwnedGameplayTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.IsAlive = IsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyActorsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UNoceAISystem::GetEnemyActorsByTag(const struct FGameplayTag& CharacterTag, bool ExactMatch, bool IsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyActorsByTag");

	Params::NoceAISystem_GetEnemyActorsByTag Parms{};

	Parms.CharacterTag = std::move(CharacterTag);
	Parms.ExactMatch = ExactMatch;
	Parms.IsAlive = IsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyAliveCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceAISystem::GetEnemyAliveCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyAliveCount");

	Params::NoceAISystem_GetEnemyAliveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyAliveCountByCharacterTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              CharacterTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceAISystem::GetEnemyAliveCountByCharacterTag(const struct FGameplayTag& CharacterTag, bool ExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyAliveCountByCharacterTag");

	Params::NoceAISystem_GetEnemyAliveCountByCharacterTag Parms{};

	Parms.CharacterTag = std::move(CharacterTag);
	Parms.ExactMatch = ExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetEnemyAliveCountByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceAISystem::GetEnemyAliveCountByTag(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetEnemyAliveCountByTag");

	Params::NoceAISystem_GetEnemyAliveCountByTag Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetNewAttackID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceAISystem::GetNewAttackID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetNewAttackID");

	Params::NoceAISystem_GetNewAttackID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FNoceCharacterRecord>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceCharacterRecord> UNoceAISystem::GetSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetSaveData");

	Params::NoceAISystem_GetSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceAISpawner*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceAISpawner* UNoceAISystem::GetSpawner(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetSpawner");

	Params::NoceAISystem_GetSpawner Parms{};

	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetSpecifyRecord
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SpawnerName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceCharacterRecord             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceCharacterRecord UNoceAISystem::GetSpecifyRecord(class FName SpawnerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetSpecifyRecord");

	Params::NoceAISystem_GetSpecifyRecord Parms{};

	Parms.SpawnerName = SpawnerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.GetTerritoriesByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ANoceTerritoryVolume*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ANoceTerritoryVolume*> UNoceAISystem::GetTerritoriesByGroup(class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "GetTerritoriesByGroup");

	Params::NoceAISystem_GetTerritoriesByGroup Parms{};

	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.IsAlreadyDeadOnRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class ANoceAISpawner*             Spawner                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::IsAlreadyDeadOnRecord(const class ANoceAISpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "IsAlreadyDeadOnRecord");

	Params::NoceAISystem_IsAlreadyDeadOnRecord Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.IsAnySpawnerWaiting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::IsAnySpawnerWaiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "IsAnySpawnerWaiting");

	Params::NoceAISystem_IsAnySpawnerWaiting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.IsInheritedAIRecordDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InheritedTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::IsInheritedAIRecordDead(class FName InheritedTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "IsInheritedAIRecordDead");

	Params::NoceAISystem_IsInheritedAIRecordDead Parms{};

	Parms.InheritedTag = InheritedTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.IsInheritedRecordExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InheritedTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::IsInheritedRecordExist(class FName InheritedTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "IsInheritedRecordExist");

	Params::NoceAISystem_IsInheritedRecordExist Parms{};

	Parms.InheritedTag = InheritedTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.IsTerritoryExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAISystem::IsTerritoryExist(class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "IsTerritoryExist");

	Params::NoceAISystem_IsTerritoryExist Parms{};

	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAISystem.KillAllEnemy
// (Final, Native, Public, BlueprintCallable)

void UNoceAISystem::KillAllEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "KillAllEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.KillSpawnerEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       AreaName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::KillSpawnerEnemy(const class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "KillSpawnerEnemy");

	Params::NoceAISystem_KillSpawnerEnemy Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.OnEnemyDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::OnEnemyDead(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "OnEnemyDead");

	Params::NoceAISystem_OnEnemyDead Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.OnEnemyFakeDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::OnEnemyFakeDead(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "OnEnemyFakeDead");

	Params::NoceAISystem_OnEnemyFakeDead Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.ProcessEndCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             IgnoreTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UnlockNavigation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::ProcessEndCutscene(class FName IgnoreTag, bool UnlockNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "ProcessEndCutscene");

	Params::NoceAISystem_ProcessEndCutscene Parms{};

	Parms.IgnoreTag = IgnoreTag;
	Parms.UnlockNavigation = UnlockNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.ProcessEnterCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             IgnoreTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHideEnemy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHideNPC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LockNavigation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::ProcessEnterCutscene(class FName IgnoreTag, bool InHideEnemy, bool InHideNPC, bool LockNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "ProcessEnterCutscene");

	Params::NoceAISystem_ProcessEnterCutscene Parms{};

	Parms.IgnoreTag = IgnoreTag;
	Parms.InHideEnemy = InHideEnemy;
	Parms.InHideNPC = InHideNPC;
	Parms.LockNavigation = LockNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RebuildNavigation
// (Final, Native, Public, BlueprintCallable)

void UNoceAISystem::RebuildNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RebuildNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RegisterEnemyActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::RegisterEnemyActor(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RegisterEnemyActor");

	Params::NoceAISystem_RegisterEnemyActor Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RegisterEnemyController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceAIController*                pController                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::RegisterEnemyController(class ANoceAIController* pController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RegisterEnemyController");

	Params::NoceAISystem_RegisterEnemyController Parms{};

	Parms.pController = pController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RegisterSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceAISpawner*                   pSpawner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::RegisterSpawner(class FName Group, class ANoceAISpawner* pSpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RegisterSpawner");

	Params::NoceAISystem_RegisterSpawner Parms{};

	Parms.Group = Group;
	Parms.pSpawner = pSpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RegisterTerritory
// (Final, Native, Public)
// Parameters:
// class ANoceTerritoryVolume*             Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::RegisterTerritory(class ANoceTerritoryVolume* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RegisterTerritory");

	Params::NoceAISystem_RegisterTerritory Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.RemoveNavigationBuildLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::RemoveNavigationBuildLock(uint8 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "RemoveNavigationBuildLock");

	Params::NoceAISystem_RemoveNavigationBuildLock Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.SetSightRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewSightRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::SetSightRatio(float InNewSightRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "SetSightRatio");

	Params::NoceAISystem_SetSightRatio Parms{};

	Parms.InNewSightRatio = InNewSightRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.SetSightRatioToController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentSightRatio                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InNewSightRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::SetSightRatioToController(class AAIController* InController, float InCurrentSightRatio, float InNewSightRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "SetSightRatioToController");

	Params::NoceAISystem_SetSightRatioToController Parms{};

	Parms.InController = InController;
	Parms.InCurrentSightRatio = InCurrentSightRatio;
	Parms.InNewSightRatio = InNewSightRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.SetSightRatioToSpawnedControllers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewSightRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::SetSightRatioToSpawnedControllers(float InNewSightRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "SetSightRatioToSpawnedControllers");

	Params::NoceAISystem_SetSightRatioToSpawnedControllers Parms{};

	Parms.InNewSightRatio = InNewSightRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.SpawnEnemies
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::SpawnEnemies(class FName Group, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "SpawnEnemies");

	Params::NoceAISystem_SpawnEnemies Parms{};

	Parms.Group = Group;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.UnregisterEnemyActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::UnregisterEnemyActor(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "UnregisterEnemyActor");

	Params::NoceAISystem_UnregisterEnemyActor Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.UnregisterEnemyController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceAIController*                pController                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::UnregisterEnemyController(class ANoceAIController* pController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "UnregisterEnemyController");

	Params::NoceAISystem_UnregisterEnemyController Parms{};

	Parms.pController = pController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.UnregisterSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceAISpawner*                   pSpawner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::UnregisterSpawner(class FName Group, class ANoceAISpawner* pSpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "UnregisterSpawner");

	Params::NoceAISystem_UnregisterSpawner Parms{};

	Parms.Group = Group;
	Parms.pSpawner = pSpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAISystem.UnRegisterTerritory
// (Final, Native, Public)
// Parameters:
// class ANoceTerritoryVolume*             Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAISystem::UnRegisterTerritory(class ANoceTerritoryVolume* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAISystem", "UnRegisterTerritory");

	Params::NoceAISystem_UnRegisterTerritory Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.ContinueGame
// (Final, Native, Public, BlueprintCallable)

void UNoceAnalyticsInstance::ContinueGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "ContinueGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.Deinitialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceAnalyticsInstance::Deinitialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "Deinitialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceAnalyticsInstance.EndBattle
// (Final, Native, Protected, BlueprintCallable)

void UNoceAnalyticsInstance::EndBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "EndBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.EndSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnalyticsInstance::EndSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "EndSession");

	Params::NoceAnalyticsInstance_EndSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnalyticsInstance.EndSession_BP
// (Event, Protected, BlueprintEvent)

void UNoceAnalyticsInstance::EndSession_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "EndSession_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceAnalyticsInstance.GetAnalyticsState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceAnalyticsInstance::GetAnalyticsState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "GetAnalyticsState");

	Params::NoceAnalyticsInstance_GetAnalyticsState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnalyticsInstance.GetNocePlayerCharacter_Internal
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class ANocePlayerCharacter*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerCharacter* UNoceAnalyticsInstance::GetNocePlayerCharacter_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "GetNocePlayerCharacter_Internal");

	Params::NoceAnalyticsInstance_GetNocePlayerCharacter_Internal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnalyticsInstance.Initialize_BP
// (Event, Protected, BlueprintEvent)

void UNoceAnalyticsInstance::Initialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "Initialize_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceAnalyticsInstance.ManuallyEndSession
// (Final, Native, Public, BlueprintCallable)

void UNoceAnalyticsInstance::ManuallyEndSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "ManuallyEndSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnAddConsumableItem
// (Final, Native, Protected)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InQuantity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnAddConsumableItem(class FName InItemName, int32 InQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnAddConsumableItem");

	Params::NoceAnalyticsInstance_OnAddConsumableItem Parms{};

	Parms.InItemName = InItemName;
	Parms.InQuantity = InQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnAddItem
// (Final, Native, Protected)
// Parameters:
// ENoceInventoryType                      InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnAddItem(ENoceInventoryType InType, class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnAddItem");

	Params::NoceAnalyticsInstance_OnAddItem Parms{};

	Parms.InType = InType;
	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnAddNewWeapon
// (Final, Native, Protected)
// Parameters:
// class FName                             InWeaponID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnAddNewWeapon(class FName InWeaponID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnAddNewWeapon");

	Params::NoceAnalyticsInstance_OnAddNewWeapon Parms{};

	Parms.InWeaponID = InWeaponID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnEnemyDead
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InEnemyActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnEnemyDead(class AActor* InEnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnEnemyDead");

	Params::NoceAnalyticsInstance_OnEnemyDead Parms{};

	Parms.InEnemyActor = InEnemyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnEnemyFakeDead
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InEnemyActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnEnemyFakeDead(class AActor* InEnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnEnemyFakeDead");

	Params::NoceAnalyticsInstance_OnEnemyFakeDead Parms{};

	Parms.InEnemyActor = InEnemyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnFaithChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InDelta                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnFaithChanged(float InDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnFaithChanged");

	Params::NoceAnalyticsInstance_OnFaithChanged Parms{};

	Parms.InDelta = InDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnLoadGameSlot
// (Final, Native, Protected)

void UNoceAnalyticsInstance::OnLoadGameSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnLoadGameSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnPlayerDie
// (Final, Native, Protected)

void UNoceAnalyticsInstance::OnPlayerDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnPlayerDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnPlayerTakeDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InAttacker                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnPlayerTakeDamage(class AActor* InAttacker, class FName InComboName, float InHealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnPlayerTakeDamage");

	Params::NoceAnalyticsInstance_OnPlayerTakeDamage Parms{};

	Parms.InAttacker = InAttacker;
	Parms.InComboName = InComboName;
	Parms.InHealthDamage = InHealthDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnProgressChanged");

	Params::NoceAnalyticsInstance_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnProgressInitialized");

	Params::NoceAnalyticsInstance_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnSanityChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InDelta                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnSanityChanged(float InDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnSanityChanged");

	Params::NoceAnalyticsInstance_OnSanityChanged Parms{};

	Parms.InDelta = InDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnSaveGameSlot
// (Final, Native, Protected)
// Parameters:
// bool                                    InIsAutoSave                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnSaveGameSlot(bool InIsAutoSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnSaveGameSlot");

	Params::NoceAnalyticsInstance_OnSaveGameSlot Parms{};

	Parms.InIsAutoSave = InIsAutoSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnUseConsumableItem
// (Final, Native, Protected)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnUseConsumableItem(class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnUseConsumableItem");

	Params::NoceAnalyticsInstance_OnUseConsumableItem Parms{};

	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.OnWeaponDurabilityChanged
// (Final, Native, Protected)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDelta                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::OnWeaponDurabilityChanged(class FName InWeaponName, float InDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "OnWeaponDurabilityChanged");

	Params::NoceAnalyticsInstance_OnWeaponDurabilityChanged Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDelta = InDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.RegisterSystems_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANoceGameState*                   InNoceGameState                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerState*                 InNocePlayerState                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::RegisterSystems_BP(class ANoceGameState* InNoceGameState, class ANocePlayerState* InNocePlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "RegisterSystems_BP");

	Params::NoceAnalyticsInstance_RegisterSystems_BP Parms{};

	Parms.InNoceGameState = InNoceGameState;
	Parms.InNocePlayerState = InNocePlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceAnalyticsInstance.ResetRecords
// (Final, Native, Public, BlueprintCallable)

void UNoceAnalyticsInstance::ResetRecords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "ResetRecords");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.StartBattle
// (Final, Native, Protected, BlueprintCallable)

void UNoceAnalyticsInstance::StartBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "StartBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.StartSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnalyticsInstance::StartSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "StartSession");

	Params::NoceAnalyticsInstance_StartSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnalyticsInstance.StartSession_BP
// (Event, Protected, BlueprintEvent)

void UNoceAnalyticsInstance::StartSession_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "StartSession_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceAnalyticsInstance.UnregisterSystems_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANoceGameState*                   InNoceGameState                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerState*                 InNocePlayerState                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsInstance::UnregisterSystems_BP(class ANoceGameState* InNoceGameState, class ANocePlayerState* InNocePlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "UnregisterSystems_BP");

	Params::NoceAnalyticsInstance_UnregisterSystems_BP Parms{};

	Parms.InNoceGameState = InNoceGameState;
	Parms.InNocePlayerState = InNocePlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceAnalyticsInstance.WriteRecords
// (Final, Native, Public, BlueprintCallable)

void UNoceAnalyticsInstance::WriteRecords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "WriteRecords");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsInstance.GetAnalyticsDataByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceAnalyticsDataRow            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceAnalyticsDataRow UNoceAnalyticsInstance::GetAnalyticsDataByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "GetAnalyticsDataByName");

	Params::NoceAnalyticsInstance_GetAnalyticsDataByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnalyticsInstance.GetAnalyticsDataRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceAnalyticsInstance::GetAnalyticsDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsInstance", "GetAnalyticsDataRowNames");

	Params::NoceAnalyticsInstance_GetAnalyticsDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSimpleList.ClearSelectionWithoutAnimation
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::ClearSelectionWithoutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "ClearSelectionWithoutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.Confirm
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::Confirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "Confirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.ForceSelectAgain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleList::ForceSelectAgain(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "ForceSelectAgain");

	Params::NoceSimpleList_ForceSelectAgain Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.GetSelectingIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSimpleList::GetSelectingIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "GetSelectingIndex");

	Params::NoceSimpleList_GetSelectingIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSimpleList.GetSelectingSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceSimpleList::GetSelectingSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "GetSelectingSlot");

	Params::NoceSimpleList_GetSelectingSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSimpleList.GetSlotsLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSimpleList::GetSlotsLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "GetSlotsLength");

	Params::NoceSimpleList_GetSlotsLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSimpleList.GetSubMenuPos
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGeometry&                 Container                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 RelativePos                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry*                       Geometry                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D*                       LocalPos                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleList::GetSubMenuPos(class UUserWidget* Menu, const struct FGeometry& Container, const struct FVector2D& RelativePos, struct FGeometry* Geometry, struct FVector2D* LocalPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "GetSubMenuPos");

	Params::NoceSimpleList_GetSubMenuPos Parms{};

	Parms.Menu = Menu;
	Parms.Container = std::move(Container);
	Parms.RelativePos = std::move(RelativePos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Geometry != nullptr)
		*Geometry = std::move(Parms.Geometry);

	if (LocalPos != nullptr)
		*LocalPos = std::move(Parms.LocalPos);
}


// Function GameNoce.NoceSimpleList.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UUserWidget*>&       InSlots                                                (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNoceSimpleList::Initialize(const TArray<class UUserWidget*>& InSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "Initialize");

	Params::NoceSimpleList_Initialize Parms{};

	Parms.InSlots = std::move(InSlots);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  TriggerId                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceSimpleList::PlaySound(const struct FNeoAudioTriggerIdHandle& TriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "PlaySound");

	Params::NoceSimpleList_PlaySound Parms{};

	Parms.TriggerId = std::move(TriggerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.Reset
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.ResetAll
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::ResetAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "ResetAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.SelectIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleList::SelectIndex(int32 Index_0, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "SelectIndex");

	Params::NoceSimpleList_SelectIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GameNoce.NoceSimpleList.SelectNext
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::SelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "SelectNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.SelectPrevious
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleList::SelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "SelectPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.SelectSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleList::SelectSlot(class UUserWidget* Widget, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "SelectSlot");

	Params::NoceSimpleList_SelectSlot Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GameNoce.NoceSimpleList.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  InPreviousSound                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FNeoAudioTriggerIdHandle&  InNextSound                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FNeoAudioTriggerIdHandle&  InMouseHoverSound                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceSimpleList::SetSound(const struct FNeoAudioTriggerIdHandle& InPreviousSound, const struct FNeoAudioTriggerIdHandle& InNextSound, const struct FNeoAudioTriggerIdHandle& InMouseHoverSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "SetSound");

	Params::NoceSimpleList_SetSound Parms{};

	Parms.InPreviousSound = std::move(InPreviousSound);
	Parms.InNextSound = std::move(InNextSound);
	Parms.InMouseHoverSound = std::move(InMouseHoverSound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleList.UpdateInput
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInputEvent&               InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsTriggered                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleList::UpdateInput(const struct FInputEvent& InputEvent, const struct FKey& Key, bool* IsTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleList", "UpdateInput");

	Params::NoceSimpleList_UpdateInput Parms{};

	Parms.InputEvent = std::move(InputEvent);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsTriggered != nullptr)
		*IsTriggered = Parms.IsTriggered;
}


// Function GameNoce.NoceSimpleGrid.SetAnalogValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      Key                                                    (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSimpleGrid::SetAnalogValue(const struct FKey& Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleGrid", "SetAnalogValue");

	Params::NoceSimpleGrid_SetAnalogValue Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSimpleGrid.SetupKeys
// (Final, Native, Public, BlueprintCallable)

void UNoceSimpleGrid::SetupKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSimpleGrid", "SetupKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsBaseRecord.DeepCopyFromSource
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UNoceAnalyticsBaseRecord*   InSource                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnalyticsBaseRecord::DeepCopyFromSource(const class UNoceAnalyticsBaseRecord* InSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsBaseRecord", "DeepCopyFromSource");

	Params::NoceAnalyticsBaseRecord_DeepCopyFromSource Parms{};

	Parms.InSource = InSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsBaseRecord.ResetRecord
// (Native, Public, BlueprintCallable)

void UNoceAnalyticsBaseRecord::ResetRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsBaseRecord", "ResetRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnalyticsBaseRecord.WriteRecord
// (Native, Public, BlueprintCallable)

void UNoceAnalyticsBaseRecord::WriteRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnalyticsBaseRecord", "WriteRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRegistryFunctionLibrary.GetGamepadType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceRegistryFunctionLibrary::GetGamepadType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceRegistryFunctionLibrary", "GetGamepadType");

	Params::NoceRegistryFunctionLibrary_GetGamepadType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceANS_ApplyGEOnAttackTraceHit.OnAttackTraceHit
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&InHitResults                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNoceANS_ApplyGEOnAttackTraceHit::OnAttackTraceHit(const TArray<struct FNoceAttackHitResult>& InHitResults) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceANS_ApplyGEOnAttackTraceHit", "OnAttackTraceHit");

	Params::NoceANS_ApplyGEOnAttackTraceHit_OnAttackTraceHit Parms{};

	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCutsceneWidget.Pause
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceCutsceneWidget::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCutsceneWidget", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCutsceneWidget.Resume
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceCutsceneWidget::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCutsceneWidget", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCutsceneWidget.SetCanSkip
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InCanSkip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCutsceneWidget::SetCanSkip(bool InCanSkip, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCutsceneWidget", "SetCanSkip");

	Params::NoceCutsceneWidget_SetCanSkip Parms{};

	Parms.InCanSkip = InCanSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceCutsceneWidget.SetHasCamera
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InHasCamera                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCutsceneWidget::SetHasCamera(bool InHasCamera, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCutsceneWidget", "SetHasCamera");

	Params::NoceCutsceneWidget_SetHasCamera Parms{};

	Parms.InHasCamera = InHasCamera;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceCutsceneWidget.SetSequenceActor
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALevelSequenceActor*              InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCutsceneWidget::SetSequenceActor(class ALevelSequenceActor* InActor, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCutsceneWidget", "SetSequenceActor");

	Params::NoceCutsceneWidget_SetSequenceActor Parms{};

	Parms.InActor = InActor;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceDialogSoundTableGenerator.AddRowToDataTable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UDataTable*                       InTable                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InTriggerGroup                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           SoundEventRef                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceDialogSoundTableGenerator::AddRowToDataTable(class UDataTable* InTable, class FName InRowName, const struct FGameplayTag& InTriggerGroup, const struct FSoftObjectPath& SoundEventRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSoundTableGenerator", "AddRowToDataTable");

	Params::NoceDialogSoundTableGenerator_AddRowToDataTable Parms{};

	Parms.InTable = InTable;
	Parms.InRowName = InRowName;
	Parms.InTriggerGroup = std::move(InTriggerGroup);
	Parms.SoundEventRef = std::move(SoundEventRef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSoundTableGenerator.ModifyRowInDataTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       InTable                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachJoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Follow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceDialogSoundTableGenerator::ModifyRowInDataTable(class UDataTable* InTable, class FName InRowName, class FName AttachJoint, bool Follow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSoundTableGenerator", "ModifyRowInDataTable");

	Params::NoceDialogSoundTableGenerator_ModifyRowInDataTable Parms{};

	Parms.InTable = InTable;
	Parms.InRowName = InRowName;
	Parms.AttachJoint = AttachJoint;
	Parms.Follow = Follow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDebugCameraController.OnTeleportPawn
// (Native, Event, Public, BlueprintEvent)

void ANoceDebugCameraController::OnTeleportPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugCameraController", "OnTeleportPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDebugCameraController.TeleportPawn
// (Final, Native, Protected)

void ANoceDebugCameraController::TeleportPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugCameraController", "TeleportPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimCancelComponent.CanAnimCanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceAnimCancel                         InAnimCanel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimCancelComponent::CanAnimCanel(ENoceAnimCancel InAnimCanel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimCancelComponent", "CanAnimCanel");

	Params::NoceAnimCancelComponent_CanAnimCanel Parms{};

	Parms.InAnimCanel = InAnimCanel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimCancelComponent.ClearAllAnimCancels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InExcludeStateMachineName                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InExcludeStateName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimCancelComponent::ClearAllAnimCancels(class FName InExcludeStateMachineName, class FName InExcludeStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimCancelComponent", "ClearAllAnimCancels");

	Params::NoceAnimCancelComponent_ClearAllAnimCancels Parms{};

	Parms.InExcludeStateMachineName = InExcludeStateMachineName;
	Parms.InExcludeStateName = InExcludeStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimCancelComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimCancelComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimCancelComponent", "HandleOnPossessed");

	Params::NoceAnimCancelComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.AfterSetDefaultSlotBlending
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::AfterSetDefaultSlotBlending(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "AfterSetDefaultSlotBlending");

	Params::NoceAnimInstance_AfterSetDefaultSlotBlending Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceAnimInstance.CheckIKWhenSeqStop
// (Native, Public, BlueprintCallable)

void UNoceAnimInstance::CheckIKWhenSeqStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "CheckIKWhenSeqStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.GetCanEnterLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::GetCanEnterLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetCanEnterLink");

	Params::NoceAnimInstance_GetCanEnterLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetRolePatternIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceAnimInstance::GetRolePatternIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetRolePatternIndex");

	Params::NoceAnimInstance_GetRolePatternIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.ReplaceSetScarfRigidBodyAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::ReplaceSetScarfRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceSetScarfRigidBodyAlpha");

	Params::NoceAnimInstance_ReplaceSetScarfRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.ReplaceSetShawlKawaiiAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::ReplaceSetShawlKawaiiAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceSetShawlKawaiiAlpha");

	Params::NoceAnimInstance_ReplaceSetShawlKawaiiAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.ReplaceSetShiroFurAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::ReplaceSetShiroFurAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceSetShiroFurAlpha");

	Params::NoceAnimInstance_ReplaceSetShiroFurAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.ReplaceSetSkirtRigidBodyAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::ReplaceSetSkirtRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceSetSkirtRigidBodyAlpha");

	Params::NoceAnimInstance_ReplaceSetSkirtRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.ResetRoleStartTime
// (Final, Native, Public, BlueprintCallable)

void UNoceAnimInstance::ResetRoleStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ResetRoleStartTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetbIsDefaultSlotFixActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetbIsDefaultSlotFixActive(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetbIsDefaultSlotFixActive");

	Params::NoceAnimInstance_SetbIsDefaultSlotFixActive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetBodyMidPhysAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetBodyMidPhysAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetBodyMidPhysAlpha");

	Params::NoceAnimInstance_SetBodyMidPhysAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetCanEnterLinkState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBankID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMotionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetCanEnterLinkState(int32 InBankID, int32 InMotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetCanEnterLinkState");

	Params::NoceAnimInstance_SetCanEnterLinkState Parms{};

	Parms.InBankID = InBankID;
	Parms.InMotionID = InMotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetCharTopPhysAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetCharTopPhysAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetCharTopPhysAlpha");

	Params::NoceAnimInstance_SetCharTopPhysAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetDefaultSlotBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetDefaultSlotBlending(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetDefaultSlotBlending");

	Params::NoceAnimInstance_SetDefaultSlotBlending Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetDefaultSlotFixBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetDefaultSlotFixBlending(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetDefaultSlotFixBlending");

	Params::NoceAnimInstance_SetDefaultSlotFixBlending Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetFootIKInterpScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetFootIKInterpScale(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetFootIKInterpScale");

	Params::NoceAnimInstance_SetFootIKInterpScale Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetForceLeaveLinkState
// (Final, Native, Public, BlueprintCallable)

void UNoceAnimInstance::SetForceLeaveLinkState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetForceLeaveLinkState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetHairKawaiiAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetHairKawaiiAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetHairKawaiiAlpha");

	Params::NoceAnimInstance_SetHairKawaiiAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetHairMidPhysAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetHairMidPhysAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetHairMidPhysAlpha");

	Params::NoceAnimInstance_SetHairMidPhysAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetPhysicsWorldGravity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetPhysicsWorldGravity(const struct FVector& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetPhysicsWorldGravity");

	Params::NoceAnimInstance_SetPhysicsWorldGravity Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetRBWorldCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetRBWorldCollision(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetRBWorldCollision");

	Params::NoceAnimInstance_SetRBWorldCollision Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetRBWorldCollisionChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECollisionChannel                       InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetRBWorldCollisionChannel(ECollisionChannel InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetRBWorldCollisionChannel");

	Params::NoceAnimInstance_SetRBWorldCollisionChannel Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetRolePatternIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetRolePatternIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetRolePatternIndex");

	Params::NoceAnimInstance_SetRolePatternIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetRoleStartTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetRoleStartTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetRoleStartTime");

	Params::NoceAnimInstance_SetRoleStartTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetScarfRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetScarfRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetScarfRigidBodyAlpha");

	Params::NoceAnimInstance_SetScarfRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetShawlKawaiiAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetShawlKawaiiAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetShawlKawaiiAlpha");

	Params::NoceAnimInstance_SetShawlKawaiiAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetShouldDoIKTrace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetShouldDoIKTrace(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetShouldDoIKTrace");

	Params::NoceAnimInstance_SetShouldDoIKTrace Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetSkirtRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetSkirtRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetSkirtRigidBodyAlpha");

	Params::NoceAnimInstance_SetSkirtRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetTransferBoneVelocities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetTransferBoneVelocities(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetTransferBoneVelocities");

	Params::NoceAnimInstance_SetTransferBoneVelocities Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.SetWarmUpRBANAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAnimInstance::SetWarmUpRBANAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "SetWarmUpRBANAlpha");

	Params::NoceAnimInstance_SetWarmUpRBANAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAnimInstance.ShouldDoIKTraceByHeight
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::ShouldDoIKTraceByHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ShouldDoIKTraceByHeight");

	Params::NoceAnimInstance_ShouldDoIKTraceByHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetbIsDefaultSlotFixActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::GetbIsDefaultSlotFixActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetbIsDefaultSlotFixActive");

	Params::NoceAnimInstance_GetbIsDefaultSlotFixActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetBodyBottomPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetBodyBottomPhysAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetBodyBottomPhysAlpha");

	Params::NoceAnimInstance_GetBodyBottomPhysAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetBodyMidPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetBodyMidPhysAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetBodyMidPhysAlpha");

	Params::NoceAnimInstance_GetBodyMidPhysAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetCharTopPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetCharTopPhysAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetCharTopPhysAlpha");

	Params::NoceAnimInstance_GetCharTopPhysAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetDefaultSlotBlending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetDefaultSlotBlending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetDefaultSlotBlending");

	Params::NoceAnimInstance_GetDefaultSlotBlending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetDefaultSlotFixBlending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetDefaultSlotFixBlending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetDefaultSlotFixBlending");

	Params::NoceAnimInstance_GetDefaultSlotFixBlending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetFinalPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InParentAlpha                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetFinalPhysAlpha(float InParentAlpha, float InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetFinalPhysAlpha");

	Params::NoceAnimInstance_GetFinalPhysAlpha Parms{};

	Parms.InParentAlpha = InParentAlpha;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetFootIKInterpScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetFootIKInterpScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetFootIKInterpScale");

	Params::NoceAnimInstance_GetFootIKInterpScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetHairBottomPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetHairBottomPhysAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetHairBottomPhysAlpha");

	Params::NoceAnimInstance_GetHairBottomPhysAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetHairKawaiiAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetHairKawaiiAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetHairKawaiiAlpha");

	Params::NoceAnimInstance_GetHairKawaiiAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetHairMidPhysAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetHairMidPhysAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetHairMidPhysAlpha");

	Params::NoceAnimInstance_GetHairMidPhysAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetPhysAlphaInPendingWarmUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENocePhysType                           InPhysType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetPhysAlphaInPendingWarmUp(float InValue, ENocePhysType InPhysType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetPhysAlphaInPendingWarmUp");

	Params::NoceAnimInstance_GetPhysAlphaInPendingWarmUp Parms{};

	Parms.InValue = InValue;
	Parms.InPhysType = InPhysType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetPhysicsWorldGravity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceAnimInstance::GetPhysicsWorldGravity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetPhysicsWorldGravity");

	Params::NoceAnimInstance_GetPhysicsWorldGravity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetRBWorldCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::GetRBWorldCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetRBWorldCollision");

	Params::NoceAnimInstance_GetRBWorldCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetRBWorldCollisionChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UNoceAnimInstance::GetRBWorldCollisionChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetRBWorldCollisionChannel");

	Params::NoceAnimInstance_GetRBWorldCollisionChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetScarfRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetScarfRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetScarfRigidBodyAlpha");

	Params::NoceAnimInstance_GetScarfRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetShawlKawaiiAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetShawlKawaiiAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetShawlKawaiiAlpha");

	Params::NoceAnimInstance_GetShawlKawaiiAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetSkirtRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetSkirtRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetSkirtRigidBodyAlpha");

	Params::NoceAnimInstance_GetSkirtRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetTransferBoneVelocities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::GetTransferBoneVelocities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetTransferBoneVelocities");

	Params::NoceAnimInstance_GetTransferBoneVelocities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.GetWarmUpRBANAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::GetWarmUpRBANAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "GetWarmUpRBANAlpha");

	Params::NoceAnimInstance_GetWarmUpRBANAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.InternalGetBottomPhysAlpha
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             InMidPhysAlpha                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InBottomValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENocePhysType                     InPhysType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InGamePlayAlpha                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::InternalGetBottomPhysAlpha(const float InMidPhysAlpha, const float InBottomValue, const ENocePhysType InPhysType, const float InGamePlayAlpha) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "InternalGetBottomPhysAlpha");

	Params::NoceAnimInstance_InternalGetBottomPhysAlpha Parms{};

	Parms.InMidPhysAlpha = InMidPhysAlpha;
	Parms.InBottomValue = InBottomValue;
	Parms.InPhysType = InPhysType;
	Parms.InGamePlayAlpha = InGamePlayAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.LerpWithDefaultSlotBlendingForSeamlessOut
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAnimInstance::LerpWithDefaultSlotBlendingForSeamlessOut(float* OutResult, float A, float B) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "LerpWithDefaultSlotBlendingForSeamlessOut");

	Params::NoceAnimInstance_LerpWithDefaultSlotBlendingForSeamlessOut Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.ReplaceGetScarfRigidBodyAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::ReplaceGetScarfRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceGetScarfRigidBodyAlpha");

	Params::NoceAnimInstance_ReplaceGetScarfRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.ReplaceGetShawlKawaiiAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::ReplaceGetShawlKawaiiAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceGetShawlKawaiiAlpha");

	Params::NoceAnimInstance_ReplaceGetShawlKawaiiAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.ReplaceGetShiroFurAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::ReplaceGetShiroFurAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceGetShiroFurAlpha");

	Params::NoceAnimInstance_ReplaceGetShiroFurAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstance.ReplaceGetSkirtRigidBodyAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceAnimInstance::ReplaceGetSkirtRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAnimInstance", "ReplaceGetSkirtRigidBodyAlpha");

	Params::NoceAnimInstance_ReplaceGetSkirtRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAnimInstanceInterface.WarmUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   WarmUpFrames                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceAnimInstanceInterface::WarmUp(int32 WarmUpFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceAnimInstanceInterface", "WarmUp");

	Params::NoceAnimInstanceInterface_WarmUp Parms{};

	Parms.WarmUpFrames = WarmUpFrames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanitySpawnSystem.DeleteSpawnedEnemies
// (Final, Native, Public, BlueprintCallable)

void UNoceSanitySpawnSystem::DeleteSpawnedEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "DeleteSpawnedEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanitySpawnSystem.EnterSpawnVolume_BP
// (Event, Protected, BlueprintEvent)

void UNoceSanitySpawnSystem::EnterSpawnVolume_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "EnterSpawnVolume_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceSanitySpawnSystem.ExitSpawnVolume_BP
// (Event, Protected, BlueprintEvent)

void UNoceSanitySpawnSystem::ExitSpawnVolume_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "ExitSpawnVolume_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceSanitySpawnSystem.ForceSpawn
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FSanitySpawnVolumeSetting& Setting                                                (Parm, NativeAccessSpecifierPublic)

void UNoceSanitySpawnSystem::ForceSpawn(const struct FSanitySpawnVolumeSetting& Setting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "ForceSpawn");

	Params::NoceSanitySpawnSystem_ForceSpawn Parms{};

	Parms.Setting = std::move(Setting);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceSanitySpawnSystem.Initialize_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSanitySpawnSystem::Initialize_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "Initialize_BP");

	Params::NoceSanitySpawnSystem_Initialize_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanitySpawnSystem.Tick_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSanitySpawnSystem::Tick_BP(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "Tick_BP");

	Params::NoceSanitySpawnSystem_Tick_BP Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanitySpawnSystem.UpdateSpawnedEnemies
// (Final, Native, Protected, BlueprintCallable)

void UNoceSanitySpawnSystem::UpdateSpawnedEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnSystem", "UpdateSpawnedEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemMessageWidget.ShowText
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceSystemMessageData&    InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemMessageWidget::ShowText(const struct FNoceSystemMessageData& InData, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemMessageWidget", "ShowText");

	Params::NoceSystemMessageWidget_ShowText Parms{};

	Parms.InData = std::move(InData);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceTeleportTarget.GetPointName
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ANoceTeleportTarget::GetPointName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "GetPointName");

	Params::NoceTeleportTarget_GetPointName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTeleportTarget.GetWorldTriggerGateway
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ANoceTeleportTarget::GetWorldTriggerGateway()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "GetWorldTriggerGateway");

	Params::NoceTeleportTarget_GetWorldTriggerGateway Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTeleportTarget.OnEndTeleport
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ANoceTeleportTarget::OnEndTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "OnEndTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTeleportTarget.OnStartTeleport
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ANoceTeleportTarget::OnStartTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "OnStartTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTeleportTarget.PreActualTeleport
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ANoceTeleportTarget::PreActualTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "PreActualTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTeleportTarget.ReadyForFlush
// (Final, Native, Public, BlueprintCallable)

void ANoceTeleportTarget::ReadyForFlush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "ReadyForFlush");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTeleportTarget.RequestTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPassenger                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ResetCamera                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInstant                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StrictlyStreamingComplete                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TeleportAfterStreaming                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceGCAfterLevelStreamedOut                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreWorldTrigger                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTeleportTarget::RequestTeleport(class APawn* InPassenger, bool ResetCamera, bool IsInstant, bool StrictlyStreamingComplete, bool TeleportAfterStreaming, bool ForceGCAfterLevelStreamedOut, bool IgnoreWorldTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTeleportTarget", "RequestTeleport");

	Params::NoceTeleportTarget_RequestTeleport Parms{};

	Parms.InPassenger = InPassenger;
	Parms.ResetCamera = ResetCamera;
	Parms.IsInstant = IsInstant;
	Parms.StrictlyStreamingComplete = StrictlyStreamingComplete;
	Parms.TeleportAfterStreaming = TeleportAfterStreaming;
	Parms.ForceGCAfterLevelStreamedOut = ForceGCAfterLevelStreamedOut;
	Parms.IgnoreWorldTrigger = IgnoreWorldTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceRBANLibrary.ConvertToRigidBody
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRigidBodyReference              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRigidBodyReference UNoceRBANLibrary::ConvertToRigidBody(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceRBANLibrary", "ConvertToRigidBody");

	Params::NoceRBANLibrary_ConvertToRigidBody Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceRBANLibrary.ConvertToRigidBodyPure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRigidBodyReference*             RigidBody                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRBANLibrary::ConvertToRigidBodyPure(const struct FAnimNodeReference& Node, struct FRigidBodyReference* RigidBody, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceRBANLibrary", "ConvertToRigidBodyPure");

	Params::NoceRBANLibrary_ConvertToRigidBodyPure Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RigidBody != nullptr)
		*RigidBody = std::move(Parms.RigidBody);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GameNoce.NoceSellPopResultWidget.ShowResult
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InTotalValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FNoceOfferingEffectData>&InOfferingEffects                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSellPopResultWidget::ShowResult(int32 InTotalValue, const TArray<struct FNoceOfferingEffectData>& InOfferingEffects, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSellPopResultWidget", "ShowResult");

	Params::NoceSellPopResultWidget_ShowResult Parms{};

	Parms.InTotalValue = InTotalValue;
	Parms.InOfferingEffects = std::move(InOfferingEffects);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceANS_PlayerHairAlpha.SetHairAlpha
// (Final, Native, Protected, Const)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceANS_PlayerHairAlpha::SetHairAlpha(float InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceANS_PlayerHairAlpha", "SetHairAlpha");

	Params::NoceANS_PlayerHairAlpha_SetHairAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceWidget.OnMouseDown
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceReplaceWidget::OnMouseDown(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceWidget", "OnMouseDown");

	Params::NoceReplaceWidget_OnMouseDown Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceWidget.OnPickPreviewClose
// (Final, Native, Protected)

void UNoceReplaceWidget::OnPickPreviewClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceWidget", "OnPickPreviewClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceWidget.OnPopWindowClose
// (Final, Native, Protected)

void UNoceReplaceWidget::OnPopWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceWidget", "OnPopWindowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.ClearAttackBuffAccumulateValue
// (Final, Native, Public, BlueprintCallable)

void UNoceSanityComponent::ClearAttackBuffAccumulateValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "ClearAttackBuffAccumulateValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.CostCurrentMaxSanity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCanEndFocus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::CostCurrentMaxSanity(float InValue, bool InCanEndFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "CostCurrentMaxSanity");

	Params::NoceSanityComponent_CostCurrentMaxSanity Parms{};

	Parms.InValue = InValue;
	Parms.InCanEndFocus = InCanEndFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.CostSanity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InClampByCurrentMaxSanity                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::CostSanity(float InValue, bool InClampByCurrentMaxSanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "CostSanity");

	Params::NoceSanityComponent_CostSanity Parms{};

	Parms.InValue = InValue;
	Parms.InClampByCurrentMaxSanity = InClampByCurrentMaxSanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.EndFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InApplySanityWeak                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::EndFocus(bool InApplySanityWeak)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "EndFocus");

	Params::NoceSanityComponent_EndFocus Parms{};

	Parms.InApplySanityWeak = InApplySanityWeak;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.ForceReset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFillSanityToCurrentMaxSanity                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForceResetTimeDilation                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::ForceReset(bool InFillSanityToCurrentMaxSanity, bool InForceResetTimeDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "ForceReset");

	Params::NoceSanityComponent_ForceReset Parms{};

	Parms.InFillSanityToCurrentMaxSanity = InFillSanityToCurrentMaxSanity;
	Parms.InForceResetTimeDilation = InForceResetTimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.GetActionLevelSanityRegenRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSanityComponent::GetActionLevelSanityRegenRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "GetActionLevelSanityRegenRatio");

	Params::NoceSanityComponent_GetActionLevelSanityRegenRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanityComponent.GetEnableFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSanityComponent::GetEnableFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "GetEnableFocus");

	Params::NoceSanityComponent_GetEnableFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanityComponent.HandleInputAction
// (Final, Native, Protected)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::HandleInputAction(ENoceInputAction InInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "HandleInputAction");

	Params::NoceSanityComponent_HandleInputAction Parms{};

	Parms.InInputAction = InInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.HandleOnHit
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNoceSanityComponent::HandleOnHit(const TArray<struct FNoceAttackHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "HandleOnHit");

	Params::NoceSanityComponent_HandleOnHit Parms{};

	Parms.HitResults = std::move(HitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "HandleOnPossessed");

	Params::NoceSanityComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.HasAttackBuffAccumulateValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSanityComponent::HasAttackBuffAccumulateValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "HasAttackBuffAccumulateValue");

	Params::NoceSanityComponent_HasAttackBuffAccumulateValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanityComponent.IsUsingFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSanityComponent::IsUsingFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "IsUsingFocus");

	Params::NoceSanityComponent_IsUsingFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSanityComponent.PauseAttackBuffAccumulate
// (Final, Native, Public, BlueprintCallable)

void UNoceSanityComponent::PauseAttackBuffAccumulate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "PauseAttackBuffAccumulate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.ResetNoChangeWaitForRecoverTimer
// (Final, Native, Public, BlueprintCallable)

void UNoceSanityComponent::ResetNoChangeWaitForRecoverTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "ResetNoChangeWaitForRecoverTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.ResumeAttackBuffAccumulate
// (Final, Native, Public, BlueprintCallable)

void UNoceSanityComponent::ResumeAttackBuffAccumulate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "ResumeAttackBuffAccumulate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.SetEnableFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityComponent::SetEnableFocus(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "SetEnableFocus");

	Params::NoceSanityComponent_SetEnableFocus Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityComponent.StartFocus
// (Final, Native, Public, BlueprintCallable)

void UNoceSanityComponent::StartFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityComponent", "StartFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointUpgradeDataUIAsset.GetListItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSavePointUpgradeListItemDataReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSavePointUpgradeListItemData UNoceSavePointUpgradeDataUIAsset::GetListItemData(ENoceUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointUpgradeDataUIAsset", "GetListItemData");

	Params::NoceSavePointUpgradeDataUIAsset_GetListItemData Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointUpgradeDataUIAsset.GetPopWindowText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceSavePointUpgradeDataUIAsset::GetPopWindowText(ENoceUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointUpgradeDataUIAsset", "GetPopWindowText");

	Params::NoceSavePointUpgradeDataUIAsset_GetPopWindowText Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceANS_TimedNiagaraEffect.OnAttackTraceHit
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&InHitResults                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNoceANS_TimedNiagaraEffect::OnAttackTraceHit(const TArray<struct FNoceAttackHitResult>& InHitResults) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceANS_TimedNiagaraEffect", "OnAttackTraceHit");

	Params::NoceANS_TimedNiagaraEffect_OnAttackTraceHit Parms{};

	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAdditionalColComponent.CanEnableColHead
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAdditionalColComponent::CanEnableColHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "CanEnableColHead");

	Params::NocePlayerAdditionalColComponent_CanEnableColHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAdditionalColComponent.GetColHead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* UNocePlayerAdditionalColComponent::GetColHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "GetColHead");

	Params::NocePlayerAdditionalColComponent_GetColHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAdditionalColComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAdditionalColComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "HandleOnPossessed");

	Params::NocePlayerAdditionalColComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAdditionalColComponent.OnGameplayTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TagExist                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAdditionalColComponent::OnGameplayTagChanged(const struct FGameplayTag& Tag, bool TagExist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "OnGameplayTagChanged");

	Params::NocePlayerAdditionalColComponent_OnGameplayTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.TagExist = TagExist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAdditionalColComponent.RegisterOnPossessed
// (Final, Native, Protected)

void UNocePlayerAdditionalColComponent::RegisterOnPossessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "RegisterOnPossessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAdditionalColComponent.SetColHeadCollisionEnable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAdditionalColComponent::SetColHeadCollisionEnable(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "SetColHeadCollisionEnable");

	Params::NocePlayerAdditionalColComponent_SetColHeadCollisionEnable Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAdditionalColComponent.ToggleDrawDebug
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerAdditionalColComponent::ToggleDrawDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAdditionalColComponent", "ToggleDrawDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceArrowWidget.OnMouseButtonDownArrow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGeometry&                 InGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UNoceArrowWidget::OnMouseButtonDownArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceArrowWidget", "OnMouseButtonDownArrow");

	Params::NoceArrowWidget_OnMouseButtonDownArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceArrowWidget.OnReset
// (Final, Native, Public, BlueprintCallable)

void UNoceArrowWidget::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceArrowWidget", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceArrowWidget.OnSelect
// (Final, Native, Public, BlueprintCallable)

void UNoceArrowWidget::OnSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceArrowWidget", "OnSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceArrowWidget.OnSelectCompleted
// (Final, Native, Public, BlueprintCallable)

void UNoceArrowWidget::OnSelectCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceArrowWidget", "OnSelectCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAssignLipSyncTool.AssignLipSyncMontageToLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       InTable                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDialogSet&            DialogSet                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   LineIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceAssignLipSyncTool::AssignLipSyncMontageToLine(class UDataTable* InTable, class FName InRowName, const struct FNoceDialogSet& DialogSet, int32 LineIndex, class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAssignLipSyncTool", "AssignLipSyncMontageToLine");

	Params::NoceAssignLipSyncTool_AssignLipSyncMontageToLine Parms{};

	Parms.InTable = InTable;
	Parms.InRowName = InRowName;
	Parms.DialogSet = std::move(DialogSet);
	Parms.LineIndex = LineIndex;
	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacterAttributeSet.SetArmorClamped
// (Native, Protected)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCharacterAttributeSet::SetArmorClamped(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacterAttributeSet", "SetArmorClamped");

	Params::NoceCharacterAttributeSet_SetArmorClamped Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacterAttributeSet.SetHealthClamped
// (Native, Protected)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCharacterAttributeSet::SetHealthClamped(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacterAttributeSet", "SetHealthClamped");

	Params::NoceCharacterAttributeSet_SetHealthClamped Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAttributeSet.SetClawTransformClamped
// (Native, Public)
// Parameters:
// float                                   NewTransfom                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAttributeSet::SetClawTransformClamped(float NewTransfom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAttributeSet", "SetClawTransformClamped");

	Params::NocePlayerAttributeSet_SetClawTransformClamped Parms{};

	Parms.NewTransfom = NewTransfom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAttributeSet.SetCurrentMaxSanityClamped
// (Native, Public)
// Parameters:
// float                                   NewCurrentMaxSanity                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAttributeSet::SetCurrentMaxSanityClamped(float NewCurrentMaxSanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAttributeSet", "SetCurrentMaxSanityClamped");

	Params::NocePlayerAttributeSet_SetCurrentMaxSanityClamped Parms{};

	Parms.NewCurrentMaxSanity = NewCurrentMaxSanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAttributeSet.SetSanityClamped
// (Native, Public)
// Parameters:
// float                                   NewSanity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAttributeSet::SetSanityClamped(float NewSanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAttributeSet", "SetSanityClamped");

	Params::NocePlayerAttributeSet_SetSanityClamped Parms{};

	Parms.NewSanity = NewSanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAttributeSet.SetStaminaClamped
// (Native, Public)
// Parameters:
// float                                   NewStamian                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAttributeSet::SetStaminaClamped(float NewStamian)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAttributeSet", "SetStaminaClamped");

	Params::NocePlayerAttributeSet_SetStaminaClamped Parms{};

	Parms.NewStamian = NewStamian;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAsyncLoadSeqPreloadData.AsyncLoadSeqPreloadData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSeqData&              SeqData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UNoceAsyncLoadSeqPreloadData*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceAsyncLoadSeqPreloadData* UNoceAsyncLoadSeqPreloadData::AsyncLoadSeqPreloadData(class UObject* WorldContextObject, const struct FNoceSeqData& SeqData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAsyncLoadSeqPreloadData", "AsyncLoadSeqPreloadData");

	Params::NoceAsyncLoadSeqPreloadData_AsyncLoadSeqPreloadData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SeqData = std::move(SeqData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSuperArmorComponent.EndSuperArmor
// (Final, Native, Public, BlueprintCallable)

void UNoceSuperArmorComponent::EndSuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSuperArmorComponent", "EndSuperArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSuperArmorComponent.IsSuperArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSuperArmorComponent::IsSuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSuperArmorComponent", "IsSuperArmor");

	Params::NoceSuperArmorComponent_IsSuperArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSuperArmorComponent.StartSuperArmor
// (Final, Native, Public, BlueprintCallable)

void UNoceSuperArmorComponent::StartSuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSuperArmorComponent", "StartSuperArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAsyncTaskAttributeChanged.ListenForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceAsyncTaskAttributeChanged*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceAsyncTaskAttributeChanged* UNoceAsyncTaskAttributeChanged::ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAsyncTaskAttributeChanged", "ListenForAttributeChange");

	Params::NoceAsyncTaskAttributeChanged_ListenForAttributeChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAsyncTaskAttributeChanged.ListenForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGameplayAttribute>&Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNoceAsyncTaskAttributeChanged*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceAsyncTaskAttributeChanged* UNoceAsyncTaskAttributeChanged::ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceAsyncTaskAttributeChanged", "ListenForAttributesChange");

	Params::NoceAsyncTaskAttributeChanged_ListenForAttributesChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAsyncTaskAttributeChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UNoceAsyncTaskAttributeChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAsyncTaskAttributeChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttachmentBaseComponent.DoAttach
// (Native, Public, BlueprintCallable)

void UNoceAttachmentBaseComponent::DoAttach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttachmentBaseComponent", "DoAttach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttachmentBaseComponent.OnOwnerActorDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttachmentBaseComponent::OnOwnerActorDestroyed(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttachmentBaseComponent", "OnOwnerActorDestroyed");

	Params::NoceAttachmentBaseComponent_OnOwnerActorDestroyed Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttachmentBaseComponent.PreviewAttach
// (Final, Native, Protected)

void UNoceAttachmentBaseComponent::PreviewAttach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttachmentBaseComponent", "PreviewAttach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttachmentBaseComponent.SetAttachmentHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Hidden                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttachmentBaseComponent::SetAttachmentHidden(bool Hidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttachmentBaseComponent", "SetAttachmentHidden");

	Params::NoceAttachmentBaseComponent_SetAttachmentHidden Parms{};

	Parms.Hidden = Hidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.AddPushOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::AddPushOffset(const struct FVector& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "AddPushOffset");

	Params::NoceCharacter_AddPushOffset Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.CheckNoHealthLoss
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::CheckNoHealthLoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "CheckNoHealthLoss");

	Params::NoceCharacter_CheckNoHealthLoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.CreateCineActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              InTags                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FNoceCineActorSeqStopData& CineCharSetting                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ANoceCharacter::CreateCineActorComponent(const TArray<class FName>& InTags, const struct FNoceCineActorSeqStopData& CineCharSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "CreateCineActorComponent");

	Params::NoceCharacter_CreateCineActorComponent Parms{};

	Parms.InTags = std::move(InTags);
	Parms.CineCharSetting = std::move(CineCharSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.Die
// (Native, Public, BlueprintCallable)

void ANoceCharacter::Die()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "Die");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.DisplayDebug_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float&                                  YL                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float&                                  YPos                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::DisplayDebug_BP(class UCanvas* Canvas, float& YL, float& YPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "DisplayDebug_BP");

	Params::NoceCharacter_DisplayDebug_BP Parms{};

	Parms.Canvas = Canvas;
	Parms.YL = YL;
	Parms.YPos = YPos;

	UObject::ProcessEvent(Func, &Parms);

	YL = Parms.YL;
	YPos = Parms.YPos;
}


// Function GameNoce.NoceCharacter.GetARandomCharMeshType
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              ForbiddenNames                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANoceCharacter::GetARandomCharMeshType(const TArray<class FName>& ForbiddenNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetARandomCharMeshType");

	Params::NoceCharacter_GetARandomCharMeshType Parms{};

	Parms.ForbiddenNames = std::move(ForbiddenNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCharacterName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ANoceCharacter::GetCharacterName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCharacterName");

	Params::NoceCharacter_GetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCharMeshTypeComment
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InRowName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ANoceCharacter::GetCharMeshTypeComment(const class FName& InRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCharMeshTypeComment");

	Params::NoceCharacter_GetCharMeshTypeComment Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCharMeshTypeRowNames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ANoceCharacter::GetCharMeshTypeRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCharMeshTypeRowNames");

	Params::NoceCharacter_GetCharMeshTypeRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCurrentWeapon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANoceWeapon*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceWeapon* ANoceCharacter::GetCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCurrentWeapon");

	Params::NoceCharacter_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetDieCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceCharacter::GetDieCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetDieCount");

	Params::NoceCharacter_GetDieCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetEnablePushOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::GetEnablePushOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetEnablePushOffset");

	Params::NoceCharacter_GetEnablePushOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetHair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ANoceCharacter::GetHair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetHair");

	Params::NoceCharacter_GetHair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetHead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ANoceCharacter::GetHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetHead");

	Params::NoceCharacter_GetHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetLogicalName
// (Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ANoceCharacter::GetLogicalName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetLogicalName");

	Params::NoceCharacter_GetLogicalName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetSecondsScineBeginPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ANoceCharacter::GetSecondsScineBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetSecondsScineBeginPlay");

	Params::NoceCharacter_GetSecondsScineBeginPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetSoundComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UNeoAudioSoundComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNeoAudioSoundComponent* ANoceCharacter::GetSoundComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetSoundComponent");

	Params::NoceCharacter_GetSoundComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetSpawnerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceCharacter::GetSpawnerLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetSpawnerLocation");

	Params::NoceCharacter_GetSpawnerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetSuicideDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::GetSuicideDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetSuicideDead");

	Params::NoceCharacter_GetSuicideDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.HandleInputAxis
// (Final, Native, Protected)
// Parameters:
// ENoceInputAxis                          InInputAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::HandleInputAxis(ENoceInputAxis InInputAxis, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "HandleInputAxis");

	Params::NoceCharacter_HandleInputAxis Parms{};

	Parms.InInputAxis = InInputAxis;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.HasCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::HasCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "HasCurrentWeapon");

	Params::NoceCharacter_HasCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.InitSkinnedDecal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ANoceCharacter::InitSkinnedDecal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "InitSkinnedDecal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.InitSkinnedDecalForPreview
// (Final, Native, Protected, BlueprintCallable)

void ANoceCharacter::InitSkinnedDecalForPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "InitSkinnedDecalForPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.IsCurrentlyUnderAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsCurrentlyUnderAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsCurrentlyUnderAttack");

	Params::NoceCharacter_IsCurrentlyUnderAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsCurrentWeaponVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsCurrentWeaponVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsCurrentWeaponVisible");

	Params::NoceCharacter_IsCurrentWeaponVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.MoveForward
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::MoveForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "MoveForward");

	Params::NoceCharacter_MoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.MoveRight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::MoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "MoveRight");

	Params::NoceCharacter_MoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.OnDamaged
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceAttackHitResult&      AttackHitResult                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANoceCharacter::OnDamaged(const struct FNoceAttackHitResult& AttackHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnDamaged");

	Params::NoceCharacter_OnDamaged Parms{};

	Parms.AttackHitResult = std::move(AttackHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.OnLoadGameSave_BP
// (Event, Public, BlueprintEvent)

void ANoceCharacter::OnLoadGameSave_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnLoadGameSave_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCharacter.OnLoadRecord
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceCharacterRecord&      InRecord                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ANoceCharacter::OnLoadRecord(const struct FNoceCharacterRecord& InRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnLoadRecord");

	Params::NoceCharacter_OnLoadRecord Parms{};

	Parms.InRecord = std::move(InRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.OnPostSignificance
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ANoceCharacter*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Significance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::OnPostSignificance(class ANoceCharacter* Character, float Significance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnPostSignificance");

	Params::NoceCharacter_OnPostSignificance Parms{};

	Parms.Character = Character;
	Parms.Significance = Significance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.OnSaveRecord
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FNoceCharacterRecord             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceCharacterRecord ANoceCharacter::OnSaveRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnSaveRecord");

	Params::NoceCharacter_OnSaveRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.OnSaveRecord_BP
// (Event, Public, BlueprintEvent)

void ANoceCharacter::OnSaveRecord_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "OnSaveRecord_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceCharacter.PlayHeadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StopAllMontages                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::PlayHeadMontage(class UAnimMontage* MontageToPlay, bool StopAllMontages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "PlayHeadMontage");

	Params::NoceCharacter_PlayHeadMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.StopAllMontages = StopAllMontages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.ProcessCharMeshType_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FNoceCharMeshDataRow&      InDataRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ANoceCharacter::ProcessCharMeshType_BP(const struct FNoceCharMeshDataRow& InDataRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "ProcessCharMeshType_BP");

	Params::NoceCharacter_ProcessCharMeshType_BP Parms{};

	Parms.InDataRow = std::move(InDataRow);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceCharacter.ResetDieCount
// (Final, Native, Public, BlueprintCallable)

void ANoceCharacter::ResetDieCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "ResetDieCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.Revive
// (Native, Public, BlueprintCallable)

void ANoceCharacter::Revive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "Revive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetArmor(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetArmor");

	Params::NoceCharacter_SetArmor Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetAutoAdjustWalkSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetAutoAdjustWalkSpeed(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetAutoAdjustWalkSpeed");

	Params::NoceCharacter_SetAutoAdjustWalkSpeed Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetHeadTracking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetHeadTracking(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetHeadTracking");

	Params::NoceCharacter_SetHeadTracking Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetHealth(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetHealth");

	Params::NoceCharacter_SetHealth Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetHealthByRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetHealthByRatio(float InRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetHealthByRatio");

	Params::NoceCharacter_SetHealthByRatio Parms{};

	Parms.InRatio = InRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetPushOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetPushOffset(const struct FVector& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetPushOffset");

	Params::NoceCharacter_SetPushOffset Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetPushOffsetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetPushOffsetEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetPushOffsetEnable");

	Params::NoceCharacter_SetPushOffsetEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceAISpawner*                   Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetSpawner(class ANoceAISpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetSpawner");

	Params::NoceCharacter_SetSpawner Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetSpawnMontagePlayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPlayed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetSpawnMontagePlayed(bool bPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetSpawnMontagePlayed");

	Params::NoceCharacter_SetSpawnMontagePlayed Parms{};

	Parms.bPlayed = bPlayed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SetSuicideDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SetSuicideDead(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SetSuicideDead");

	Params::NoceCharacter_SetSuicideDead Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.SwitchToRunSpeed
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceCharacter::SwitchToRunSpeed(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "SwitchToRunSpeed");

	Params::NoceCharacter_SwitchToRunSpeed Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceCharacter.TryLoadRecord
// (Native, Public, BlueprintCallable)

void ANoceCharacter::TryLoadRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "TryLoadRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCharacter.UpdateCharMeshType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InRowName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::UpdateCharMeshType(const class FName& InRowName, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "UpdateCharMeshType");

	Params::NoceCharacter_UpdateCharMeshType Parms{};

	Parms.InRowName = InRowName;
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetAbilityLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceAbilityInputID                     AbilityID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetAbilityLevel(ENoceAbilityInputID AbilityID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetAbilityLevel");

	Params::NoceCharacter_GetAbilityLevel Parms{};

	Parms.AbilityID = AbilityID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetArmor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetArmor");

	Params::NoceCharacter_GetArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCharacterLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetCharacterLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCharacterLevel");

	Params::NoceCharacter_GetCharacterLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetCharacterTag
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ANoceCharacter::GetCharacterTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetCharacterTag");

	Params::NoceCharacter_GetCharacterTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetGenericTeamId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGenericTeamId                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGenericTeamId ANoceCharacter::GetGenericTeamId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetGenericTeamId");

	Params::NoceCharacter_GetGenericTeamId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetHealth");

	Params::NoceCharacter_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetHealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetHealthRatio");

	Params::NoceCharacter_GetHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetInitialAttributeLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceCharacter::GetInitialAttributeLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetInitialAttributeLevel");

	Params::NoceCharacter_GetInitialAttributeLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetMaxArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetMaxArmor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetMaxArmor");

	Params::NoceCharacter_GetMaxArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceCharacter::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetMaxHealth");

	Params::NoceCharacter_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.GetMySpawner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANoceAISpawner*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceAISpawner* ANoceCharacter::GetMySpawner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "GetMySpawner");

	Params::NoceCharacter_GetMySpawner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsAlive");

	Params::NoceCharacter_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsInLinkConstPosition
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsInLinkConstPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsInLinkConstPosition");

	Params::NoceCharacter_IsInLinkConstPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsInLinking
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsInLinking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsInLinking");

	Params::NoceCharacter_IsInLinking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsInLinkMotion
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsInLinkMotion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsInLinkMotion");

	Params::NoceCharacter_IsInLinkMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsInLinkMotionCoolDown
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsInLinkMotionCoolDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsInLinkMotionCoolDown");

	Params::NoceCharacter_IsInLinkMotionCoolDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCharacter.IsSpawnMontagePlayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceCharacter::IsSpawnMontagePlayed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCharacter", "IsSpawnMontagePlayed");

	Params::NoceCharacter_IsSpawnMontagePlayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.ApplyDeathType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceDeathType                          InDeathType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ApplyDeathType(ENoceDeathType InDeathType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ApplyDeathType");

	Params::NocePlayerCharacter_ApplyDeathType Parms{};

	Parms.InDeathType = InDeathType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ApplyPlayerOutfit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerOutfit                       InPlayerOutfit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ApplyPlayerOutfit(ENocePlayerOutfit InPlayerOutfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ApplyPlayerOutfit");

	Params::NocePlayerCharacter_ApplyPlayerOutfit Parms{};

	Parms.InPlayerOutfit = InPlayerOutfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.CanAccepInputActionAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InFromRealInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAccepInputActionAttack(bool InFromRealInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAccepInputActionAttack");

	Params::NocePlayerCharacter_CanAccepInputActionAttack Parms{};

	Parms.InFromRealInput = InFromRealInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputActionBasic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputActionBasic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputActionBasic");

	Params::NocePlayerCharacter_CanAcceptInputActionBasic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputActionDodge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputActionDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputActionDodge");

	Params::NocePlayerCharacter_CanAcceptInputActionDodge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputActionInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputActionInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputActionInteract");

	Params::NocePlayerCharacter_CanAcceptInputActionInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputByStaminaStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputByStaminaStatus(ENoceInputAction InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputByStaminaStatus");

	Params::NocePlayerCharacter_CanAcceptInputByStaminaStatus Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputClawTransform
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputClawTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputClawTransform");

	Params::NocePlayerCharacter_CanAcceptInputClawTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptInputFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptInputFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptInputFocus");

	Params::NocePlayerCharacter_CanAcceptInputFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAcceptLinkMotionAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAcceptLinkMotionAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAcceptLinkMotionAttack");

	Params::NocePlayerCharacter_CanAcceptLinkMotionAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanAutoCounter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanAutoCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanAutoCounter");

	Params::NocePlayerCharacter_CanAutoCounter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanShowInteractHint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanShowInteractHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanShowInteractHint");

	Params::NocePlayerCharacter_CanShowInteractHint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CanUseJustDodgeCounter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CanUseJustDodgeCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CanUseJustDodgeCounter");

	Params::NocePlayerCharacter_CanUseJustDodgeCounter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.CheckPlayerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerType                         PlayerType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::CheckPlayerType(ENocePlayerType PlayerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "CheckPlayerType");

	Params::NocePlayerCharacter_CheckPlayerType Parms{};

	Parms.PlayerType = PlayerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.ClearCachedSprintInput
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::ClearCachedSprintInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ClearCachedSprintInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ClearHandleForceClawTransformTimer
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::ClearHandleForceClawTransformTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ClearHandleForceClawTransformTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ClearShiromukuRevive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ClearShiromukuRevive(class FName InToken, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ClearShiromukuRevive");

	Params::NocePlayerCharacter_ClearShiromukuRevive Parms{};

	Parms.InToken = InToken;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.DuringUpperBodyMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::DuringUpperBodyMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "DuringUpperBodyMotion");

	Params::NocePlayerCharacter_DuringUpperBodyMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.DuringUseShortcutItemMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::DuringUseShortcutItemMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "DuringUseShortcutItemMotion");

	Params::NocePlayerCharacter_DuringUseShortcutItemMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.EnableMaterialSlotsClaw_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::EnableMaterialSlotsClaw_BP(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "EnableMaterialSlotsClaw_BP");

	Params::NocePlayerCharacter_EnableMaterialSlotsClaw_BP Parms{};

	Parms.InEnable = InEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.EnableMaterialSlotsClawG_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::EnableMaterialSlotsClawG_BP(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "EnableMaterialSlotsClawG_BP");

	Params::NocePlayerCharacter_EnableMaterialSlotsClawG_BP Parms{};

	Parms.InEnable = InEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.FindCounterTarget_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InCounterHint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFromRealInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ANocePlayerCharacter::FindCounterTarget_BP(bool InCounterHint, bool InFromRealInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "FindCounterTarget_BP");

	Params::NocePlayerCharacter_FindCounterTarget_BP Parms{};

	Parms.InCounterHint = InCounterHint;
	Parms.InFromRealInput = InFromRealInput;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.ForceClawGToClaw
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::ForceClawGToClaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ForceClawGToClaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ForceClawToClawG
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::ForceClawToClawG()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ForceClawToClawG");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.GetCacheInteractionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInteractType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInteractType ANocePlayerCharacter::GetCacheInteractionType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetCacheInteractionType");

	Params::NocePlayerCharacter_GetCacheInteractionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetClawTransform
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetClawTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetClawTransform");

	Params::NocePlayerCharacter_GetClawTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetComboCanBeAxeDefensed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetComboCanBeAxeDefensed(class AActor* InTarget, class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetComboCanBeAxeDefensed");

	Params::NocePlayerCharacter_GetComboCanBeAxeDefensed Parms{};

	Parms.InTarget = InTarget;
	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetComboCanBeKatanaDefensed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetComboCanBeKatanaDefensed(class AActor* InTarget, class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetComboCanBeKatanaDefensed");

	Params::NocePlayerCharacter_GetComboCanBeKatanaDefensed Parms{};

	Parms.InTarget = InTarget;
	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetComboCheckInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckJustDodge                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckInvincible                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckOmamoriKagami                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::GetComboCheckInfo(class AActor* InTarget, class FName InComboName, bool* OutCheckJustDodge, bool* OutCheckInvincible, bool* OutCheckOmamoriKagami)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetComboCheckInfo");

	Params::NocePlayerCharacter_GetComboCheckInfo Parms{};

	Parms.InTarget = InTarget;
	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCheckJustDodge != nullptr)
		*OutCheckJustDodge = Parms.OutCheckJustDodge;

	if (OutCheckInvincible != nullptr)
		*OutCheckInvincible = Parms.OutCheckInvincible;

	if (OutCheckOmamoriKagami != nullptr)
		*OutCheckOmamoriKagami = Parms.OutCheckOmamoriKagami;
}


// Function GameNoce.NocePlayerCharacter.GetCurrentMaxSanityRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetCurrentMaxSanityRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetCurrentMaxSanityRatio");

	Params::NocePlayerCharacter_GetCurrentMaxSanityRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetEnemyInSightDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetEnemyInSightDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetEnemyInSightDistance");

	Params::NocePlayerCharacter_GetEnemyInSightDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetEnemyInSightNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerCharacter::GetEnemyInSightNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetEnemyInSightNumber");

	Params::NocePlayerCharacter_GetEnemyInSightNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetHaveCachedSprintInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetHaveCachedSprintInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetHaveCachedSprintInput");

	Params::NocePlayerCharacter_GetHaveCachedSprintInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetHaveKatanaScabbard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetHaveKatanaScabbard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetHaveKatanaScabbard");

	Params::NocePlayerCharacter_GetHaveKatanaScabbard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetHitAngleCanBeDefensed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHitAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetHitAngleCanBeDefensed(float InHitAngle, float InHalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetHitAngleCanBeDefensed");

	Params::NocePlayerCharacter_GetHitAngleCanBeDefensed Parms{};

	Parms.InHitAngle = InHitAngle;
	Parms.InHalfAngle = InHalfAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsInEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsInEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsInEvent");

	Params::NocePlayerCharacter_GetIsInEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsInExamineMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsInExamineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsInExamineMode");

	Params::NocePlayerCharacter_GetIsInExamineMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsOnSlopeSkirtControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsOnSlopeSkirtControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsOnSlopeSkirtControl");

	Params::NocePlayerCharacter_GetIsOnSlopeSkirtControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsUnpossessed
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsUnpossessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsUnpossessed");

	Params::NocePlayerCharacter_GetIsUnpossessed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsUsingGimmick
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsUsingGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsUsingGimmick");

	Params::NocePlayerCharacter_GetIsUsingGimmick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetLowHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetLowHealthRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetLowHealthRatio");

	Params::NocePlayerCharacter_GetLowHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetMaxClawTransform
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetMaxClawTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetMaxClawTransform");

	Params::NocePlayerCharacter_GetMaxClawTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetNeedCheckSuperArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetNeedCheckSuperArmor(class AActor* InTarget, class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetNeedCheckSuperArmor");

	Params::NocePlayerCharacter_GetNeedCheckSuperArmor Parms{};

	Parms.InTarget = InTarget;
	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetShiromukuReviveFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetShiromukuReviveFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetShiromukuReviveFrequency");

	Params::NocePlayerCharacter_GetShiromukuReviveFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetShiromukuReviveIntenisy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetShiromukuReviveIntenisy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetShiromukuReviveIntenisy");

	Params::NocePlayerCharacter_GetShiromukuReviveIntenisy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetWeaponBreakAttackRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetWeaponBreakAttackRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetWeaponBreakAttackRatio");

	Params::NocePlayerCharacter_GetWeaponBreakAttackRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HandleClawTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InTransformToClawG                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleClawTransform(bool InTransformToClawG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleClawTransform");

	Params::NocePlayerCharacter_HandleClawTransform Parms{};

	Parms.InTransformToClawG = InTransformToClawG;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleClawTransform_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InTransformToClawG                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleClawTransform_BP(bool InTransformToClawG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleClawTransform_BP");

	Params::NocePlayerCharacter_HandleClawTransform_BP Parms{};

	Parms.InTransformToClawG = InTransformToClawG;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.HandleEnemyInSightNumberChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleEnemyInSightNumberChanged(int32 InNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleEnemyInSightNumberChanged");

	Params::NocePlayerCharacter_HandleEnemyInSightNumberChanged Parms{};

	Parms.InNumber = InNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleForceClawTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InToClawG                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleForceClawTransform(bool InToClawG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleForceClawTransform");

	Params::NocePlayerCharacter_HandleForceClawTransform Parms{};

	Parms.InToClawG = InToClawG;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleJustDodge
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceAttackHitResult&      InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleJustDodge(const struct FNoceAttackHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleJustDodge");

	Params::NocePlayerCharacter_HandleJustDodge Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleJustDodge_BP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleJustDodge_BP(const struct FNoceAttackHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleJustDodge_BP");

	Params::NocePlayerCharacter_HandleJustDodge_BP Parms{};

	Parms.InHitResult = std::move(InHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.HandleOnEnemyDamaged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsDead                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::HandleOnEnemyDamaged(class AActor* InHitActor, float InDamage, bool InIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleOnEnemyDamaged");

	Params::NocePlayerCharacter_HandleOnEnemyDamaged Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InDamage = InDamage;
	Parms.InIsDead = InIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleOnHeightFogUpdate
// (Final, Native, Public)

void ANocePlayerCharacter::HandleOnHeightFogUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleOnHeightFogUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleRestartGame
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::HandleRestartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleRestartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleWaitForLevelReady
// (Native, Public, BlueprintCallable)

void ANocePlayerCharacter::HandleWaitForLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleWaitForLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.HandleWaitForLevelReady_BP
// (Event, Public, BlueprintEvent)

void ANocePlayerCharacter::HandleWaitForLevelReady_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HandleWaitForLevelReady_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePlayerCharacter.HasClawAlterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceClawAlterType                      InClawAlterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HasClawAlterType(ENoceClawAlterType InClawAlterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HasClawAlterType");

	Params::NocePlayerCharacter_HasClawAlterType Parms{};

	Parms.InClawAlterType = InClawAlterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HasPlayerBegunPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HasPlayerBegunPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HasPlayerBegunPlayer");

	Params::NocePlayerCharacter_HasPlayerBegunPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HasPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HasPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HasPlayerController");

	Params::NocePlayerCharacter_HasPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HaveCounterTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCounterHint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HaveCounterTarget(bool InCounterHint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HaveCounterTarget");

	Params::NocePlayerCharacter_HaveCounterTarget Parms{};

	Parms.InCounterHint = InCounterHint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HaveCounterTargetBasic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFromRealInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HaveCounterTargetBasic(bool InFromRealInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HaveCounterTargetBasic");

	Params::NocePlayerCharacter_HaveCounterTargetBasic Parms{};

	Parms.InFromRealInput = InFromRealInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InAttackStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InAttackStateMachine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InAttackStateMachine");

	Params::NocePlayerCharacter_InAttackStateMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InCounterState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InCounterState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InCounterState");

	Params::NocePlayerCharacter_InCounterState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InDamageState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InDamageState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InDamageState");

	Params::NocePlayerCharacter_InDamageState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InDeadState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InDeadState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InDeadState");

	Params::NocePlayerCharacter_InDeadState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InFocusAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InFocusAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InFocusAttack");

	Params::NocePlayerCharacter_InFocusAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InFocusCharged
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InFocusCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InFocusCharged");

	Params::NocePlayerCharacter_InFocusCharged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InHeavyAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InHeavyAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InHeavyAttack");

	Params::NocePlayerCharacter_InHeavyAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InitHinaSkirtOverridePhATForPreview
// (Final, Native, Protected, BlueprintCallable)

void ANocePlayerCharacter::InitHinaSkirtOverridePhATForPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InitHinaSkirtOverridePhATForPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.InJustDodge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InJustDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InJustDodge");

	Params::NocePlayerCharacter_InJustDodge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InRealBattleStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InRealBattleStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InRealBattleStatus");

	Params::NocePlayerCharacter_InRealBattleStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InRespawnState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InRespawnState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InRespawnState");

	Params::NocePlayerCharacter_InRespawnState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.InStaminaTired
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::InStaminaTired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "InStaminaTired");

	Params::NocePlayerCharacter_InStaminaTired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsBossFightMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsBossFightMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsBossFightMode");

	Params::NocePlayerCharacter_IsBossFightMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsChangeWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsChangeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsChangeWeapon");

	Params::NocePlayerCharacter_IsChangeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsChaseMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsChaseMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsChaseMode");

	Params::NocePlayerCharacter_IsChaseMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClaw");

	Params::NocePlayerCharacter_IsClaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClawAttrackSoulState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClawAttrackSoulState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClawAttrackSoulState");

	Params::NocePlayerCharacter_IsClawAttrackSoulState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClawG
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClawG()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClawG");

	Params::NocePlayerCharacter_IsClawG Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClawGTransformToClaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClawGTransformToClaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClawGTransformToClaw");

	Params::NocePlayerCharacter_IsClawGTransformToClaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClawTransformFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClawTransformFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClawTransformFull");

	Params::NocePlayerCharacter_IsClawTransformFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsClawTransformState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsClawTransformState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsClawTransformState");

	Params::NocePlayerCharacter_IsClawTransformState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsCorruptionLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsCorruptionLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsCorruptionLink");

	Params::NocePlayerCharacter_IsCorruptionLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsCorruptionLinkExecution
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsCorruptionLinkExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsCorruptionLinkExecution");

	Params::NocePlayerCharacter_IsCorruptionLinkExecution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsCustomUpperBody
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsCustomUpperBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsCustomUpperBody");

	Params::NocePlayerCharacter_IsCustomUpperBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDamageLimitHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDamageLimitHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDamageLimitHealth");

	Params::NocePlayerCharacter_IsDamageLimitHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDamageTriggerJustDodge
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceAttackHitResult&      InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDamageTriggerJustDodge(const struct FNoceAttackHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDamageTriggerJustDodge");

	Params::NocePlayerCharacter_IsDamageTriggerJustDodge Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDamageTriggerJustDodge_BP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDamageTriggerJustDodge_BP(const struct FNoceAttackHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDamageTriggerJustDodge_BP");

	Params::NocePlayerCharacter_IsDamageTriggerJustDodge_BP Parms{};

	Parms.InHitResult = std::move(InHitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDamageWinceToAdditive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDamageWinceToAdditive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDamageWinceToAdditive");

	Params::NocePlayerCharacter_IsDamageWinceToAdditive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDarkHinako
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDarkHinako()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDarkHinako");

	Params::NocePlayerCharacter_IsDarkHinako Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDodgeNoCostStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDodgeNoCostStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDodgeNoCostStamina");

	Params::NocePlayerCharacter_IsDodgeNoCostStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsDuringStateTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsDuringStateTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsDuringStateTransition");

	Params::NocePlayerCharacter_IsDuringStateTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsEnemyInSight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsEnemyInSight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsEnemyInSight");

	Params::NocePlayerCharacter_IsEnemyInSight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsEnemyLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsEnemyLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsEnemyLink");

	Params::NocePlayerCharacter_IsEnemyLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsEnemyLinkExecution
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsEnemyLinkExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsEnemyLinkExecution");

	Params::NocePlayerCharacter_IsEnemyLinkExecution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsForceBattling
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsForceBattling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsForceBattling");

	Params::NocePlayerCharacter_IsForceBattling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsForceRunningNoCostStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsForceRunningNoCostStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsForceRunningNoCostStamina");

	Params::NocePlayerCharacter_IsForceRunningNoCostStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsForceTransformToClaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsForceTransformToClaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsForceTransformToClaw");

	Params::NocePlayerCharacter_IsForceTransformToClaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsHellMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsHellMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsHellMode");

	Params::NocePlayerCharacter_IsHellMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsHellModeDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsHellModeDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsHellModeDamage");

	Params::NocePlayerCharacter_IsHellModeDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInBattling
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInBattling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInBattling");

	Params::NocePlayerCharacter_IsInBattling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInDodge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInDodge");

	Params::NocePlayerCharacter_IsInDodge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInLinkExecution
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInLinkExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInLinkExecution");

	Params::NocePlayerCharacter_IsInLinkExecution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInLocomotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInLocomotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInLocomotion");

	Params::NocePlayerCharacter_IsInLocomotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInLocomotionRun
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInLocomotionRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInLocomotionRun");

	Params::NocePlayerCharacter_IsInLocomotionRun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInLowHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInLowHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInLowHealth");

	Params::NocePlayerCharacter_IsInLowHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInRunning");

	Params::NocePlayerCharacter_IsInRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInSafeZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInSafeZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInSafeZone");

	Params::NocePlayerCharacter_IsInSafeZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInteractForbit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InIsInstantFeedback                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInteractForbit(bool InIsInstantFeedback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInteractForbit");

	Params::NocePlayerCharacter_IsInteractForbit Parms{};

	Parms.InIsInstantFeedback = InIsInstantFeedback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsInteracting");

	Params::NocePlayerCharacter_IsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsJustDodgeCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsJustDodgeCollisionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsJustDodgeCollisionEnabled");

	Params::NocePlayerCharacter_IsJustDodgeCollisionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsJustDodgeCollisionEnabled_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsJustDodgeCollisionEnabled_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsJustDodgeCollisionEnabled_BP");

	Params::NocePlayerCharacter_IsJustDodgeCollisionEnabled_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsLockOnTarget");

	Params::NocePlayerCharacter_IsLockOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsRagdolling
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsRagdolling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsRagdolling");

	Params::NocePlayerCharacter_IsRagdolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsSanityHasAttackBuffAccumulateValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsSanityHasAttackBuffAccumulateValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsSanityHasAttackBuffAccumulateValue");

	Params::NocePlayerCharacter_IsSanityHasAttackBuffAccumulateValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsSeeingEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsSeeingEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsSeeingEnemy");

	Params::NocePlayerCharacter_IsSeeingEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsShortcutItemLeftKeyDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsShortcutItemLeftKeyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsShortcutItemLeftKeyDown");

	Params::NocePlayerCharacter_IsShortcutItemLeftKeyDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsShowShortcutItemUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsShowShortcutItemUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsShowShortcutItemUI");

	Params::NocePlayerCharacter_IsShowShortcutItemUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsTargetCounterable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCounterHint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsTargetCounterable(class AActor* InTargetActor, bool InCounterHint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsTargetCounterable");

	Params::NocePlayerCharacter_IsTargetCounterable Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InCounterHint = InCounterHint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsTargetCounterableBasic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsTargetCounterableBasic(class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsTargetCounterableBasic");

	Params::NocePlayerCharacter_IsTargetCounterableBasic Parms{};

	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsUnderShiromukuRevive2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsUnderShiromukuRevive2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsUnderShiromukuRevive2");

	Params::NocePlayerCharacter_IsUnderShiromukuRevive2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsUseShortcutItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsUseShortcutItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsUseShortcutItem");

	Params::NocePlayerCharacter_IsUseShortcutItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsUsingFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsUsingFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsUsingFocus");

	Params::NocePlayerCharacter_IsUsingFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsWantToDoUpperBodyMotion
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsWantToDoUpperBodyMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsWantToDoUpperBodyMotion");

	Params::NocePlayerCharacter_IsWantToDoUpperBodyMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsWeaponBreakForceKnockBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsWeaponBreakForceKnockBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsWeaponBreakForceKnockBack");

	Params::NocePlayerCharacter_IsWeaponBreakForceKnockBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.IsWeaponBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::IsWeaponBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "IsWeaponBroken");

	Params::NocePlayerCharacter_IsWeaponBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.OnPlayerOutfitChanged
// (Final, Native, Protected)
// Parameters:
// ENocePlayerOutfit                       InPlayerOutfit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::OnPlayerOutfitChanged(ENocePlayerOutfit InPlayerOutfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "OnPlayerOutfitChanged");

	Params::NocePlayerCharacter_OnPlayerOutfitChanged Parms{};

	Parms.InPlayerOutfit = InPlayerOutfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.OnUpdateCharMeshTypeForCineChar
// (Final, Native, Private)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCharMeshRowName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::OnUpdateCharMeshTypeForCineChar(ENocePlayerType InPlayerType, class FName InCharMeshRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "OnUpdateCharMeshTypeForCineChar");

	Params::NocePlayerCharacter_OnUpdateCharMeshTypeForCineChar Parms{};

	Parms.InPlayerType = InPlayerType;
	Parms.InCharMeshRowName = InCharMeshRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.OnWeaponChanged_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANoceWeapon*                      NewWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::OnWeaponChanged_BP(class ANoceWeapon* NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "OnWeaponChanged_BP");

	Params::NocePlayerCharacter_OnWeaponChanged_BP Parms{};

	Parms.NewWeapon = NewWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.RecordCachedSprintInput
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::RecordCachedSprintInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "RecordCachedSprintInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ResetATPCCamera
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::ResetATPCCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ResetATPCCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ResetHinaSkirtOverridePhATForPreview
// (Final, Native, Protected, BlueprintCallable)

void ANocePlayerCharacter::ResetHinaSkirtOverridePhATForPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ResetHinaSkirtOverridePhATForPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetCacheInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceInteractType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetCacheInteractionType(ENoceInteractType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetCacheInteractionType");

	Params::NocePlayerCharacter_SetCacheInteractionType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetCanShowNotebookHintInGimmick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CanShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetCanShowNotebookHintInGimmick(bool CanShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetCanShowNotebookHintInGimmick");

	Params::NocePlayerCharacter_SetCanShowNotebookHintInGimmick Parms{};

	Parms.CanShow = CanShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetClawTransform
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetClawTransform(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetClawTransform");

	Params::NocePlayerCharacter_SetClawTransform Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetControllerDesiredRotationRate
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetControllerDesiredRotationRate(const struct FRotator& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetControllerDesiredRotationRate");

	Params::NocePlayerCharacter_SetControllerDesiredRotationRate Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetCurrentMaxSanity
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetCurrentMaxSanity(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetCurrentMaxSanity");

	Params::NocePlayerCharacter_SetCurrentMaxSanity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetCurrentMaxSanityByRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetCurrentMaxSanityByRatio(float InRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetCurrentMaxSanityByRatio");

	Params::NocePlayerCharacter_SetCurrentMaxSanityByRatio Parms{};

	Parms.InRatio = InRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetCurrentWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceWeapon*                      InNewWeapon                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentDurability                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetCurrentWeapon(class ANoceWeapon* InNewWeapon, float InCurrentDurability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetCurrentWeapon");

	Params::NocePlayerCharacter_SetCurrentWeapon Parms{};

	Parms.InNewWeapon = InNewWeapon;
	Parms.InCurrentDurability = InCurrentDurability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetDebugSeqPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequencePlayer*             InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetDebugSeqPlayer(class ULevelSequencePlayer* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetDebugSeqPlayer");

	Params::NocePlayerCharacter_SetDebugSeqPlayer Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetDefaultRotationRate
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetDefaultRotationRate(const struct FRotator& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetDefaultRotationRate");

	Params::NocePlayerCharacter_SetDefaultRotationRate Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetExamineMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetExamineMode(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetExamineMode");

	Params::NocePlayerCharacter_SetExamineMode Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetForceBattling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetForceBattling(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetForceBattling");

	Params::NocePlayerCharacter_SetForceBattling Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetForceRunningNoCostStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetForceRunningNoCostStamina(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetForceRunningNoCostStamina");

	Params::NocePlayerCharacter_SetForceRunningNoCostStamina Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetHaveKatanaScabbard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetHaveKatanaScabbard(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetHaveKatanaScabbard");

	Params::NocePlayerCharacter_SetHaveKatanaScabbard Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetInGimmickAnimationByKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetInGimmickAnimationByKey(const class FString& InKey, bool IsInAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetInGimmickAnimationByKey");

	Params::NocePlayerCharacter_SetInGimmickAnimationByKey Parms{};

	Parms.InKey = std::move(InKey);
	Parms.IsInAnimation = IsInAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetIsForceOrientRotationToMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnbale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetIsForceOrientRotationToMovement(bool InEnbale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetIsForceOrientRotationToMovement");

	Params::NocePlayerCharacter_SetIsForceOrientRotationToMovement Parms{};

	Parms.InEnbale = InEnbale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetSanity
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetSanity(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetSanity");

	Params::NocePlayerCharacter_SetSanity Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetSanityByRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetSanityByRatio(float InRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetSanityByRatio");

	Params::NocePlayerCharacter_SetSanityByRatio Parms{};

	Parms.InRatio = InRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetStamina
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetStamina(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetStamina");

	Params::NocePlayerCharacter_SetStamina Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.SetUsingGimmick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsUsing                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::SetUsingGimmick(bool IsUsing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "SetUsingGimmick");

	Params::NocePlayerCharacter_SetUsingGimmick Parms{};

	Parms.IsUsing = IsUsing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ShiromukuRevive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PostProcessIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Frequency                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ShiromukuRevive(class FName InToken, int32 InValue, int32 PostProcessIndex, float Intensity, float Frequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ShiromukuRevive");

	Params::NocePlayerCharacter_ShiromukuRevive Parms{};

	Parms.InToken = InToken;
	Parms.InValue = InValue;
	Parms.PostProcessIndex = PostProcessIndex;
	Parms.Intensity = Intensity;
	Parms.Frequency = Frequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ShowHidePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAdjustInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsFromExternal                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ShowHidePlayer(bool InShow, bool InAdjustInput, bool InIsFromExternal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ShowHidePlayer");

	Params::NocePlayerCharacter_ShowHidePlayer Parms{};

	Parms.InShow = InShow;
	Parms.InAdjustInput = InAdjustInput;
	Parms.InIsFromExternal = InIsFromExternal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.ShowHidePlayer_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAdjustInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::ShowHidePlayer_BP(bool InShow, bool InAdjustInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "ShowHidePlayer_BP");

	Params::NocePlayerCharacter_ShowHidePlayer_BP Parms{};

	Parms.InShow = InShow;
	Parms.InAdjustInput = InAdjustInput;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerCharacter.UnEquipCurrentWeapon
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerCharacter::UnEquipCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "UnEquipCurrentWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.UpdateCharacterRotationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPreSetupForLocomotion                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerCharacter::UpdateCharacterRotationMode(bool InPreSetupForLocomotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "UpdateCharacterRotationMode");

	Params::NocePlayerCharacter_UpdateCharacterRotationMode Parms{};

	Parms.InPreSetupForLocomotion = InPreSetupForLocomotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.UpdateEyeLacrimalFluid
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ANocePlayerCharacter::UpdateEyeLacrimalFluid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "UpdateEyeLacrimalFluid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCharacter.WantToDoUpperBodyMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::WantToDoUpperBodyMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "WantToDoUpperBodyMotion");

	Params::NocePlayerCharacter_WantToDoUpperBodyMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.WantToDoUpperBodyMotionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerCharacter::WantToDoUpperBodyMotionCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "WantToDoUpperBodyMotionCount");

	Params::NocePlayerCharacter_WantToDoUpperBodyMotionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetAttack");

	Params::NocePlayerCharacter_GetAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetBattleStatusTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetBattleStatusTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetBattleStatusTime");

	Params::NocePlayerCharacter_GetBattleStatusTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetCanShowNotebookHintInGimmick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetCanShowNotebookHintInGimmick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetCanShowNotebookHintInGimmick");

	Params::NocePlayerCharacter_GetCanShowNotebookHintInGimmick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetCurrentMaxSanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetCurrentMaxSanity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetCurrentMaxSanity");

	Params::NocePlayerCharacter_GetCurrentMaxSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetEnemyBreakDownAttackRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetEnemyBreakDownAttackRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetEnemyBreakDownAttackRatio");

	Params::NocePlayerCharacter_GetEnemyBreakDownAttackRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetExtraAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetExtraAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetExtraAttack");

	Params::NocePlayerCharacter_GetExtraAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetFocusAttackCurrentMaxSanityCostRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetFocusAttackCurrentMaxSanityCostRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetFocusAttackCurrentMaxSanityCostRatio");

	Params::NocePlayerCharacter_GetFocusAttackCurrentMaxSanityCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetFocusAttackRatioHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetFocusAttackRatioHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetFocusAttackRatioHealth");

	Params::NocePlayerCharacter_GetFocusAttackRatioHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetFocusAttackRatioWince
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetFocusAttackRatioWince() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetFocusAttackRatioWince");

	Params::NocePlayerCharacter_GetFocusAttackRatioWince Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetGutsDamageToHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetGutsDamageToHealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetGutsDamageToHealthRatio");

	Params::NocePlayerCharacter_GetGutsDamageToHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetHealthDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetHealthDamageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetHealthDamageRatio");

	Params::NocePlayerCharacter_GetHealthDamageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetIsInGimmickAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::GetIsInGimmickAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetIsInGimmickAnimation");

	Params::NocePlayerCharacter_GetIsInGimmickAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetJustDodgeCounterDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetJustDodgeCounterDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetJustDodgeCounterDistance");

	Params::NocePlayerCharacter_GetJustDodgeCounterDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetLowLowStaminaThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetLowLowStaminaThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetLowLowStaminaThreshold");

	Params::NocePlayerCharacter_GetLowLowStaminaThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetMaxSanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetMaxSanity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetMaxSanity");

	Params::NocePlayerCharacter_GetMaxSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetMaxStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetMaxStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetMaxStamina");

	Params::NocePlayerCharacter_GetMaxStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetMinCurrentMaxSanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetMinCurrentMaxSanity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetMinCurrentMaxSanity");

	Params::NocePlayerCharacter_GetMinCurrentMaxSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSanity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSanity");

	Params::NocePlayerCharacter_GetSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSanityCostRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSanityCostRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSanityCostRatio");

	Params::NocePlayerCharacter_GetSanityCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSanityDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSanityDamageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSanityDamageRatio");

	Params::NocePlayerCharacter_GetSanityDamageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSanityNoChangeWaitForRecoverTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSanityNoChangeWaitForRecoverTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSanityNoChangeWaitForRecoverTime");

	Params::NocePlayerCharacter_GetSanityNoChangeWaitForRecoverTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSanityRegenRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSanityRegenRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSanityRegenRatio");

	Params::NocePlayerCharacter_GetSanityRegenRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetSprintStaminaCostRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetSprintStaminaCostRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetSprintStaminaCostRatio");

	Params::NocePlayerCharacter_GetSprintStaminaCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetStamina");

	Params::NocePlayerCharacter_GetStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetStaminaCostRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetStaminaCostRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetStaminaCostRatio");

	Params::NocePlayerCharacter_GetStaminaCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetStaminaDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetStaminaDamageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetStaminaDamageRatio");

	Params::NocePlayerCharacter_GetStaminaDamageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetStaminaTiredTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetStaminaTiredTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetStaminaTiredTime");

	Params::NocePlayerCharacter_GetStaminaTiredTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetWeaponDurabilityCostRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetWeaponDurabilityCostRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetWeaponDurabilityCostRatio");

	Params::NocePlayerCharacter_GetWeaponDurabilityCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.GetWince
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerCharacter::GetWince() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "GetWince");

	Params::NocePlayerCharacter_GetWince Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCharacter.HasTag
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              TargetTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerCharacter::HasTag(const struct FGameplayTag& TargetTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCharacter", "HasTag");

	Params::NocePlayerCharacter_HasTag Parms{};

	Parms.TargetTag = std::move(TargetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAttackTraceComponent.DoTraceByAttackID
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   InAttackID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAttackTraceName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InStartLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InStartRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   InEndLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InEndRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InRadiusRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttackTraceComponent::DoTraceByAttackID(int32 InAttackID, class FName InComboName, class FName InAttackTraceName, const struct FVector& InStartLocation, const struct FRotator& InStartRotation, const struct FVector& InEndLocation, const struct FRotator& InEndRotation, float InRadiusRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "DoTraceByAttackID");

	Params::NoceAttackTraceComponent_DoTraceByAttackID Parms{};

	Parms.InAttackID = InAttackID;
	Parms.InComboName = InComboName;
	Parms.InAttackTraceName = InAttackTraceName;
	Parms.InStartLocation = std::move(InStartLocation);
	Parms.InStartRotation = std::move(InStartRotation);
	Parms.InEndLocation = std::move(InEndLocation);
	Parms.InEndRotation = std::move(InEndRotation);
	Parms.InRadiusRatio = InRadiusRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttackTraceComponent.EndTraceByAttackID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AttackID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttackTraceComponent::EndTraceByAttackID(int32 AttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "EndTraceByAttackID");

	Params::NoceAttackTraceComponent_EndTraceByAttackID Parms{};

	Parms.AttackID = AttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttackTraceComponent.GetIsEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceAttackTraceComponent::GetIsEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "GetIsEnable");

	Params::NoceAttackTraceComponent_GetIsEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceAttackTraceComponent.SetIsDuringAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttackTraceComponent::SetIsDuringAttack(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "SetIsDuringAttack");

	Params::NoceAttackTraceComponent_SetIsDuringAttack Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttackTraceComponent.SetIsEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttackTraceComponent::SetIsEnable(bool InVale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "SetIsEnable");

	Params::NoceAttackTraceComponent_SetIsEnable Parms{};

	Parms.InVale = InVale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceAttackTraceComponent.StartTraceByAttackID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AttackID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceAttackTraceComponent::StartTraceByAttackID(int32 AttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceAttackTraceComponent", "StartTraceByAttackID");

	Params::NoceAttackTraceComponent_StartTraceByAttackID Parms{};

	Parms.AttackID = AttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTerritoryVolume.IsInVolume
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   CheckLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTerritoryVolume::IsInVolume(const struct FVector& CheckLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTerritoryVolume", "IsInVolume");

	Params::NoceTerritoryVolume_IsInVolume Parms{};

	Parms.CheckLocation = std::move(CheckLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBasePlayerController.IsPlayerReady
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceBasePlayerController::IsPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBasePlayerController", "IsPlayerReady");

	Params::NoceBasePlayerController_IsPlayerReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBasePlayerController.OnSettingChanged
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              SystemSave                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceBasePlayerController::OnSettingChanged(class UNoceSystemSaveGame* SystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBasePlayerController", "OnSettingChanged");

	Params::NoceBasePlayerController_OnSettingChanged Parms{};

	Parms.SystemSave = SystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBattleDialogComponent.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBattleDialogComponent::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattleDialogComponent", "OnGameProgressChanged");

	Params::NoceBattleDialogComponent_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBattleDialogComponent.RequestDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DialogRowName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceBattleDialogComponent::RequestDialog(class FName DialogRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattleDialogComponent", "RequestDialog");

	Params::NoceBattleDialogComponent_RequestDialog Parms{};

	Parms.DialogRowName = DialogRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBattlePositionSubsystem.GetDistanceScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceBattlePositionSubsystem::GetDistanceScore(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "GetDistanceScore");

	Params::NoceBattlePositionSubsystem_GetDistanceScore Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBattlePositionSubsystem.GetDistanceScoreByLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   v1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         v2                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceBattlePositionSubsystem::GetDistanceScoreByLocation(const struct FVector& v1, struct FVector* v2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "GetDistanceScoreByLocation");

	Params::NoceBattlePositionSubsystem_GetDistanceScoreByLocation Parms{};

	Parms.v1 = std::move(v1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (v2 != nullptr)
		*v2 = std::move(Parms.v2);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBattlePositionSubsystem.IsSystemEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceBattlePositionSubsystem::IsSystemEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "IsSystemEnabled");

	Params::NoceBattlePositionSubsystem_IsSystemEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBattlePositionSubsystem.IsSystemOperating
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceBattlePositionSubsystem::IsSystemOperating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "IsSystemOperating");

	Params::NoceBattlePositionSubsystem_IsSystemOperating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBattlePositionSubsystem.OnPlayerEnterEvent
// (Final, Native, Protected)

void UNoceBattlePositionSubsystem::OnPlayerEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "OnPlayerEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBattlePositionSubsystem.OnPlayerExitEvent
// (Final, Native, Protected)

void UNoceBattlePositionSubsystem::OnPlayerExitEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "OnPlayerExitEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBattlePositionSubsystem.OnSystemEnabledChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBattlePositionSubsystem::OnSystemEnabledChanged(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "OnSystemEnabledChanged");

	Params::NoceBattlePositionSubsystem_OnSystemEnabledChanged Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceBattlePositionSubsystem.SetDevForceOperating
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBattlePositionSubsystem::SetDevForceOperating(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "SetDevForceOperating");

	Params::NoceBattlePositionSubsystem_SetDevForceOperating Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBattlePositionSubsystem.SetSystemEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBattlePositionSubsystem::SetSystemEnabled(bool InValue, bool IsForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBattlePositionSubsystem", "SetSystemEnabled");

	Params::NoceBattlePositionSubsystem_SetSystemEnabled Parms{};

	Parms.InValue = InValue;
	Parms.IsForce = IsForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBinkSubsystem.PreloadBinkVideo_BP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FNoceBinkPreloadData&      InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceBinkSubsystem::PreloadBinkVideo_BP(const struct FNoceBinkPreloadData& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBinkSubsystem", "PreloadBinkVideo_BP");

	Params::NoceBinkSubsystem_PreloadBinkVideo_BP Parms{};

	Parms.InData = std::move(InData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceShortcutItemWidget.DirectUse
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceShortcutItemWidget::DirectUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShortcutItemWidget", "DirectUse");

	Params::NoceShortcutItemWidget_DirectUse Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBodyPartGroupComponent.AddActiveGroups
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              InGroupNames                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceBodyPartGroupComponent::AddActiveGroups(const TArray<class FName>& InGroupNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "AddActiveGroups");

	Params::NoceBodyPartGroupComponent_AddActiveGroups Parms{};

	Parms.InGroupNames = std::move(InGroupNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBodyPartGroupComponent.CostBodyPartGroupHealth
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    DebugLog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBodyPartGroupName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsLimitHealth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsBreak                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsDamageToHealth                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBodyPartGroupComponent::CostBodyPartGroupHealth(bool DebugLog, class FName InBodyPartGroupName, float InValue, bool InIsLimitHealth, bool* OutIsBreak, bool* OutIsDamageToHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "CostBodyPartGroupHealth");

	Params::NoceBodyPartGroupComponent_CostBodyPartGroupHealth Parms{};

	Parms.DebugLog = DebugLog;
	Parms.InBodyPartGroupName = InBodyPartGroupName;
	Parms.InValue = InValue;
	Parms.InIsLimitHealth = InIsLimitHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsBreak != nullptr)
		*OutIsBreak = Parms.OutIsBreak;

	if (OutIsDamageToHealth != nullptr)
		*OutIsDamageToHealth = Parms.OutIsDamageToHealth;
}


// Function GameNoce.NoceBodyPartGroupComponent.GetActiveGroupsString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceBodyPartGroupComponent::GetActiveGroupsString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "GetActiveGroupsString");

	Params::NoceBodyPartGroupComponent_GetActiveGroupsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceBodyPartGroupComponent.PrintActiveGroups
// (Final, Native, Public, BlueprintCallable)

void UNoceBodyPartGroupComponent::PrintActiveGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "PrintActiveGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBodyPartGroupComponent.RemoveActiveGroups
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              InGroupNames                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceBodyPartGroupComponent::RemoveActiveGroups(const TArray<class FName>& InGroupNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "RemoveActiveGroups");

	Params::NoceBodyPartGroupComponent_RemoveActiveGroups Parms{};

	Parms.InGroupNames = std::move(InGroupNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBodyPartGroupComponent.RemoveAllActiveGroups
// (Final, Native, Public, BlueprintCallable)

void UNoceBodyPartGroupComponent::RemoveAllActiveGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "RemoveAllActiveGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceBodyPartGroupComponent.ResetBodyPartGroupHealthToMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InBodyPartGroupName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceBodyPartGroupComponent::ResetBodyPartGroupHealthToMax(class FName InBodyPartGroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceBodyPartGroupComponent", "ResetBodyPartGroupHealthToMax");

	Params::NoceBodyPartGroupComponent_ResetBodyPartGroupHealthToMax Parms{};

	Parms.InBodyPartGroupName = InBodyPartGroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceWeaponWidget.OnRefreshSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceReplaceWeaponWidget::OnRefreshSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceWeaponWidget", "OnRefreshSelection");

	Params::NoceReplaceWeaponWidget_OnRefreshSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceWeaponWidget.ShowWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceReplaceWeaponWidget::ShowWeapon(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceWeaponWidget", "ShowWeapon");

	Params::NoceReplaceWeaponWidget_ShowWeapon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetChapterJumpDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetChapterJumpDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetChapterJumpDataTable");

	Params::NoceTableRowHandleLibrary_GetChapterJumpDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetConsumableDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetConsumableDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetConsumableDataTable");

	Params::NoceTableRowHandleLibrary_GetConsumableDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetDarknessDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetDarknessDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetDarknessDataTable");

	Params::NoceTableRowHandleLibrary_GetDarknessDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetDirLightDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetDirLightDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetDirLightDataTable");

	Params::NoceTableRowHandleLibrary_GetDirLightDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetFogNiagaraTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetFogNiagaraTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetFogNiagaraTable");

	Params::NoceTableRowHandleLibrary_GetFogNiagaraTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetHeightFogDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetHeightFogDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetHeightFogDataTable");

	Params::NoceTableRowHandleLibrary_GetHeightFogDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetHinaCharMeshTypeDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetHinaCharMeshTypeDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetHinaCharMeshTypeDataTable");

	Params::NoceTableRowHandleLibrary_GetHinaCharMeshTypeDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetInputActionToKeyDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetInputActionToKeyDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetInputActionToKeyDataTable");

	Params::NoceTableRowHandleLibrary_GetInputActionToKeyDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetKeyItemDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetKeyItemDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetKeyItemDataTable");

	Params::NoceTableRowHandleLibrary_GetKeyItemDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetKeyItemEmaDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetKeyItemEmaDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetKeyItemEmaDataTable");

	Params::NoceTableRowHandleLibrary_GetKeyItemEmaDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetLanternNiagaraTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetLanternNiagaraTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetLanternNiagaraTable");

	Params::NoceTableRowHandleLibrary_GetLanternNiagaraTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetLetterDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetLetterDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetLetterDataTable");

	Params::NoceTableRowHandleLibrary_GetLetterDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetLetterGroupDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetLetterGroupDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetLetterGroupDataTable");

	Params::NoceTableRowHandleLibrary_GetLetterGroupDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetLocationDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetLocationDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetLocationDataTable");

	Params::NoceTableRowHandleLibrary_GetLocationDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetLumenTranslucencyTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetLumenTranslucencyTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetLumenTranslucencyTable");

	Params::NoceTableRowHandleLibrary_GetLumenTranslucencyTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookCharacterContentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookCharacterContentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookCharacterContentDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookCharacterContentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookCharacterNameDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookCharacterNameDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookCharacterNameDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookCharacterNameDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookEnemyContentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookEnemyContentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookEnemyContentDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookEnemyContentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookEnemyNameDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookEnemyNameDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookEnemyNameDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookEnemyNameDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookInfoContentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookInfoContentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookInfoContentDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookInfoContentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookInfoNameDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookInfoNameDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookInfoNameDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookInfoNameDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookPuzzleContentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookPuzzleContentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookPuzzleContentDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookPuzzleContentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookPuzzleNameDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookPuzzleNameDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookPuzzleNameDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookPuzzleNameDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookTutorialContentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookTutorialContentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookTutorialContentDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookTutorialContentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetNotebookTutorialNameDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetNotebookTutorialNameDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetNotebookTutorialNameDataTable");

	Params::NoceTableRowHandleLibrary_GetNotebookTutorialNameDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetOmamoriDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetOmamoriDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetOmamoriDataTable");

	Params::NoceTableRowHandleLibrary_GetOmamoriDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetPickupsDeploymentDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetPickupsDeploymentDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetPickupsDeploymentDataTable");

	Params::NoceTableRowHandleLibrary_GetPickupsDeploymentDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetSkyAtmosphereDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetSkyAtmosphereDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetSkyAtmosphereDataTable");

	Params::NoceTableRowHandleLibrary_GetSkyAtmosphereDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetSkyDomeDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetSkyDomeDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetSkyDomeDataTable");

	Params::NoceTableRowHandleLibrary_GetSkyDomeDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetSkyLightDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetSkyLightDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetSkyLightDataTable");

	Params::NoceTableRowHandleLibrary_GetSkyLightDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetSSFSDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetSSFSDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetSSFSDataTable");

	Params::NoceTableRowHandleLibrary_GetSSFSDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetSweetLightDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetSweetLightDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetSweetLightDataTable");

	Params::NoceTableRowHandleLibrary_GetSweetLightDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetTutorialDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetTutorialDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetTutorialDataTable");

	Params::NoceTableRowHandleLibrary_GetTutorialDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetVolumetricsFogDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetVolumetricsFogDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetVolumetricsFogDataTable");

	Params::NoceTableRowHandleLibrary_GetVolumetricsFogDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetWeaponDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetWeaponDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetWeaponDataTable");

	Params::NoceTableRowHandleLibrary_GetWeaponDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTableRowHandleLibrary.GetWindDataTable
// (Final, Native, Static, Public)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceTableRowHandleLibrary::GetWindDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceTableRowHandleLibrary", "GetWindDataTable");

	Params::NoceTableRowHandleLibrary_GetWindDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWepShortcutItemWidget.SetWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurability                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWepShortcutItemWidget::SetWeapon(class FName ID, float InDurability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWepShortcutItemWidget", "SetWeapon");

	Params::NoceWepShortcutItemWidget_SetWeapon Parms{};

	Parms.ID = ID;
	Parms.InDurability = InDurability;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceCheatActivityExtension.Debug_CancelAndHideActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_CancelAndHideActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_CancelAndHideActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_CompleteAndHideActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_CompleteAndHideActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_CompleteAndHideActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_EndActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_EndActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_EndActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_HideAllActivities
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_HideAllActivities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_HideAllActivities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_ResetAllActivities
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_ResetAllActivities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_ResetAllActivities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_ResumeActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_ResumeActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_ResumeActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_SetActivityAvailabilityChange
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_SetActivityAvailabilityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_SetActivityAvailabilityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_SetUpdateProgressType
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::Debug_SetUpdateProgressType(int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_SetUpdateProgressType");

	Params::NoceCheatActivityExtension_Debug_SetUpdateProgressType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_ShowActivityDebugInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::Debug_ShowActivityDebugInfo(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_ShowActivityDebugInfo");

	Params::NoceCheatActivityExtension_Debug_ShowActivityDebugInfo Parms{};

	Parms.IsShow = IsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_StartActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_StartActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_StartActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_StartAndShowActivity
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_StartAndShowActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_StartAndShowActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_TrimActivityLog
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_TrimActivityLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_TrimActivityLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.Debug_UpdateActivitiesByCurrentProgress
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatActivityExtension::Debug_UpdateActivitiesByCurrentProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "Debug_UpdateActivitiesByCurrentProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.GetActivityAvailibities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatActivityExtension::GetActivityAvailibities(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "GetActivityAvailibities");

	Params::NoceCheatActivityExtension_GetActivityAvailibities Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatActivityExtension.GetActivityIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatActivityExtension::GetActivityIDs(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "GetActivityIDs");

	Params::NoceCheatActivityExtension_GetActivityIDs Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatActivityExtension.GetActivityOutcomes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatActivityExtension::GetActivityOutcomes(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "GetActivityOutcomes");

	Params::NoceCheatActivityExtension_GetActivityOutcomes Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatActivityExtension.GetChapters
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatActivityExtension::GetChapters(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "GetChapters");

	Params::NoceCheatActivityExtension_GetChapters Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatActivityExtension.GetResumeActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatActivityExtension::GetResumeActions(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "GetResumeActions");

	Params::NoceCheatActivityExtension_GetResumeActions Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatActivityExtension.OnCancelAndHideActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnCancelAndHideActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnCancelAndHideActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnCancelAndHideActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnCompleteAndHideActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnCompleteAndHideActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnCompleteAndHideActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnCompleteAndHideActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnEndActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnEndActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnEndActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnEndActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnResumeActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnResumeActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnResumeActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnResumeActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnSetActivityAvailabilityChangeWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnSetActivityAvailabilityChangeWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnSetActivityAvailabilityChangeWindowDecided");

	Params::NoceCheatActivityExtension_OnSetActivityAvailabilityChangeWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnStartActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnStartActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnStartActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnStartActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatActivityExtension.OnStartAndShowActivityWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatActivityExtension::OnStartAndShowActivityWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatActivityExtension", "OnStartAndShowActivityWindowDecided");

	Params::NoceCheatActivityExtension_OnStartAndShowActivityWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.DrawEnvImpactSound
// (Exec, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawEnvImpactSound(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawEnvImpactSound");

	Params::NoceCheatAudioExtension_DrawEnvImpactSound Parms{};

	Parms.Show = Show;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceCheatAudioExtension.DrawEventDistance
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawEventDistance(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawEventDistance");

	Params::NoceCheatAudioExtension_DrawEventDistance Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.DrawEventPosition
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawEventPosition(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawEventPosition");

	Params::NoceCheatAudioExtension_DrawEventPosition Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.DrawEventSphere
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawEventSphere(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawEventSphere");

	Params::NoceCheatAudioExtension_DrawEventSphere Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.DrawListener
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawListener(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawListener");

	Params::NoceCheatAudioExtension_DrawListener Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.DrawPostedEvents
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::DrawPostedEvents(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "DrawPostedEvents");

	Params::NoceCheatAudioExtension_DrawPostedEvents Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.HideInvalidStateValue
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::HideInvalidStateValue(bool Hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "HideInvalidStateValue");

	Params::NoceCheatAudioExtension_HideInvalidStateValue Parms{};

	Parms.Hide = Hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatAudioExtension.ShowStateMonitor
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatAudioExtension::ShowStateMonitor(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatAudioExtension", "ShowStateMonitor");

	Params::NoceCheatAudioExtension_ShowStateMonitor Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.CheckByRowNameAndType
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::CheckByRowNameAndType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "CheckByRowNameAndType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.CheckChunkAndDLC
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::CheckChunkAndDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "CheckChunkAndDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_IsShowDebugDataInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsShow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatChunkExtension::Debug_IsShowDebugDataInfo(bool InIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_IsShowDebugDataInfo");

	Params::NoceCheatChunkExtension_Debug_IsShowDebugDataInfo Parms{};

	Parms.InIsShow = InIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_Login
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::Debug_Login()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_Login");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_Logout
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::Debug_Logout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_Logout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_SetUsingDebugData
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatChunkExtension::Debug_SetUsingDebugData(bool InIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_SetUsingDebugData");

	Params::NoceCheatChunkExtension_Debug_SetUsingDebugData Parms{};

	Parms.InIsEnable = InIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_StartQueryDLC
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::Debug_StartQueryDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_StartQueryDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_StopQueryDLC
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::Debug_StopQueryDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_StopQueryDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.Debug_UpdateDebugChunkData
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatChunkExtension::Debug_UpdateDebugChunkData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "Debug_UpdateDebugChunkData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.GetChunkActionNames
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatChunkExtension::GetChunkActionNames(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "GetChunkActionNames");

	Params::NoceCheatChunkExtension_GetChunkActionNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatChunkExtension.GetChunkRowNames
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatChunkExtension::GetChunkRowNames(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "GetChunkRowNames");

	Params::NoceCheatChunkExtension_GetChunkRowNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatChunkExtension.GetChunkTypeNames
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatChunkExtension::GetChunkTypeNames(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "GetChunkTypeNames");

	Params::NoceCheatChunkExtension_GetChunkTypeNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatChunkExtension.OnCheckByRowNameAndTypeWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatChunkExtension::OnCheckByRowNameAndTypeWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "OnCheckByRowNameAndTypeWindowDecided");

	Params::NoceCheatChunkExtension_OnCheckByRowNameAndTypeWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.OnCheckChunkAndDLCWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatChunkExtension::OnCheckChunkAndDLCWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "OnCheckChunkAndDLCWindowDecided");

	Params::NoceCheatChunkExtension_OnCheckChunkAndDLCWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatChunkExtension.OnUpdateDebugChunkDataWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatChunkExtension::OnUpdateDebugChunkDataWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatChunkExtension", "OnUpdateDebugChunkDataWindowDecided");

	Params::NoceCheatChunkExtension_OnUpdateDebugChunkDataWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatGeneralTextWidget.ShowText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatGeneralTextWidget::ShowText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatGeneralTextWidget", "ShowText");

	Params::NoceCheatGeneralTextWidget_ShowText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllClawAlter
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllClawAlter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllClawAlter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllConsumables
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllConsumables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllConsumables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllKeyItem
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllKeyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllKeyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllLetter
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllLetter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllLetter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllNotebook
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllOmamoris
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllOmamoris()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllOmamoris");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllWeapons
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddAllWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddAllWeaponsCore
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    AddMainWeapon                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_AddAllWeaponsCore(bool AddMainWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddAllWeaponsCore");

	Params::NoceCheatInventoryExtension_Debug_AddAllWeaponsCore Parms{};

	Parms.AddMainWeapon = AddMainWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddConsumableItem
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddConsumableItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddConsumableItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddConsumableItemByID
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_AddConsumableItemByID(class FName ID, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddConsumableItemByID");

	Params::NoceCheatInventoryExtension_Debug_AddConsumableItemByID Parms{};

	Parms.ID = ID;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddFaithValue
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_AddFaithValue(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddFaithValue");

	Params::NoceCheatInventoryExtension_Debug_AddFaithValue Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddKeyItem
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddKeyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddKeyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddLetter
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddLetter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddLetter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddNotebookID
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddNotebookID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddNotebookID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddOmamori
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddShortcutConsumable
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAddQuantity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_AddShortcutConsumable(int32 InIndex, int32 InAddQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddShortcutConsumable");

	Params::NoceCheatInventoryExtension_Debug_AddShortcutConsumable Parms{};

	Parms.InIndex = InIndex;
	Parms.InAddQuantity = InAddQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_AddWeapon
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_AddWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_AddWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ClearErrorHint
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ClearErrorHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ClearErrorHint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_PrintEma
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_PrintEma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_PrintEma");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_RemoveKeyItem
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_RemoveKeyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_RemoveKeyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_RemoveOmamori
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_RemoveOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_RemoveOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ReplaceShortcutConsumables
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InConsumablePageIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAddQuantity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_ReplaceShortcutConsumables(int32 InConsumablePageIndex, int32 InAddQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ReplaceShortcutConsumables");

	Params::NoceCheatInventoryExtension_Debug_ReplaceShortcutConsumables Parms{};

	Parms.InConsumablePageIndex = InConsumablePageIndex;
	Parms.InAddQuantity = InAddQuantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ResetAttributeUpgradeLevels
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ResetAttributeUpgradeLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ResetAttributeUpgradeLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ResetDarkWeaponInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ResetDarkWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ResetDarkWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ResetFogWeaponInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ResetFogWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ResetFogWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ResetInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ResetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ResetInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_ResetWeaponInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_ResetWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_ResetWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_SetConsumableSlotNum
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNewNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_SetConsumableSlotNum(int32 InNewNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_SetConsumableSlotNum");

	Params::NoceCheatInventoryExtension_Debug_SetConsumableSlotNum Parms{};

	Parms.InNewNum = InNewNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_SetOmamoriSlotNum
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNewNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::Debug_SetOmamoriSlotNum(int32 InNewNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_SetOmamoriSlotNum");

	Params::NoceCheatInventoryExtension_Debug_SetOmamoriSlotNum Parms{};

	Parms.InNewNum = InNewNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.Debug_SpawnPickup
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatInventoryExtension::Debug_SpawnPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "Debug_SpawnPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.GetPickupCategories
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatInventoryExtension::GetPickupCategories(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "GetPickupCategories");

	Params::NoceCheatInventoryExtension_GetPickupCategories Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatInventoryExtension.GetPickupsInCategory
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatInventoryExtension::GetPickupsInCategory(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "GetPickupsInCategory");

	Params::NoceCheatInventoryExtension_GetPickupsInCategory Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatInventoryExtension.OnAddItemWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::OnAddItemWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnAddItemWindowDecided");

	Params::NoceCheatInventoryExtension_OnAddItemWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.OnAddLetterWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::OnAddLetterWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnAddLetterWindowDecided");

	Params::NoceCheatInventoryExtension_OnAddLetterWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.OnAddNotebookIDWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::OnAddNotebookIDWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnAddNotebookIDWindowDecided");

	Params::NoceCheatInventoryExtension_OnAddNotebookIDWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.OnRemoveItemWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::OnRemoveItemWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnRemoveItemWindowDecided");

	Params::NoceCheatInventoryExtension_OnRemoveItemWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.OnSpawnPickupWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::OnSpawnPickupWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnSpawnPickupWindowDecided");

	Params::NoceCheatInventoryExtension_OnSpawnPickupWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.OnSpawnPickupWindowDecided_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCheatInventoryExtension::OnSpawnPickupWindowDecided_BP(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "OnSpawnPickupWindowDecided_BP");

	Params::NoceCheatInventoryExtension_OnSpawnPickupWindowDecided_BP Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatInventoryExtension.SetupChapterJumpSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceChapterJumpSettingTableRow&InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    InReset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::SetupChapterJumpSetting(const struct FNoceChapterJumpSettingTableRow& InData, bool InReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "SetupChapterJumpSetting");

	Params::NoceCheatInventoryExtension_SetupChapterJumpSetting Parms{};

	Parms.InData = std::move(InData);
	Parms.InReset = InReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.SetupChapterJumpSettingByRowName
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       RowName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InReset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::SetupChapterJumpSettingByRowName(const class FName RowName, bool InReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "SetupChapterJumpSettingByRowName");

	Params::NoceCheatInventoryExtension_SetupChapterJumpSettingByRowName Parms{};

	Parms.RowName = RowName;
	Parms.InReset = InReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatInventoryExtension.SetupChapterJumpSettingByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InReset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          round                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCheatInventoryExtension::SetupChapterJumpSettingByTag(const struct FGameplayTag& InTag, bool InReset, ENoceRoundType round)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "SetupChapterJumpSettingByTag");

	Params::NoceCheatInventoryExtension_SetupChapterJumpSettingByTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InReset = InReset;
	Parms.round = round;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatInventoryExtension.SetupChapterJumpSettingForStory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InReset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          round                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatInventoryExtension::SetupChapterJumpSettingForStory(const struct FGameplayTag& InTag, bool InReset, ENoceRoundType round)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatInventoryExtension", "SetupChapterJumpSettingForStory");

	Params::NoceCheatInventoryExtension_SetupChapterJumpSettingForStory Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InReset = InReset;
	Parms.round = round;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.ApplyGlobalTimeDilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTimeDilation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTimeManager::ApplyGlobalTimeDilation(float InTimeDilation, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "ApplyGlobalTimeDilation");

	Params::NoceTimeManager_ApplyGlobalTimeDilation Parms{};

	Parms.InTimeDilation = InTimeDilation;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.ApplyTimeDilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceTimeEffectType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeDilation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTimeManager::ApplyTimeDilation(ENoceTimeEffectType InType, float InTimeDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "ApplyTimeDilation");

	Params::NoceTimeManager_ApplyTimeDilation Parms{};

	Parms.InType = InType;
	Parms.InTimeDilation = InTimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.OnExitNotebook
// (Final, Native, Protected)

void ANoceTimeManager::OnExitNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "OnExitNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.OnGlobalTimerUp
// (Final, Native, Protected)

void ANoceTimeManager::OnGlobalTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "OnGlobalTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.OnOpenNotebook
// (Final, Native, Protected)

void ANoceTimeManager::OnOpenNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "OnOpenNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.OnPlayerEnterEvent
// (Final, Native, Protected)

void ANoceTimeManager::OnPlayerEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "OnPlayerEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeManager.RemoveTimeDilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceTimeEffectType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTimeManager::RemoveTimeDilation(ENoceTimeEffectType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeManager", "RemoveTimeDilation");

	Params::NoceTimeManager_RemoveTimeDilation Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_DeleteAllAutoSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_DeleteAllAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_DeleteAllAutoSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_DeleteAllGameSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_DeleteAllGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_DeleteAllGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_DeleteAllMaunalSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_DeleteAllMaunalSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_DeleteAllMaunalSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_DeleteSlot
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_DeleteSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_DeleteSlot");

	Params::NoceCheatTitleLevelExtension_Debug_DeleteSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_DeleteSystemSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_DeleteSystemSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_DeleteSystemSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_JumpLevel
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_JumpLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_JumpLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_NewGameActionLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_NewGameActionLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_NewGameActionLevel");

	Params::NoceCheatTitleLevelExtension_Debug_NewGameActionLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_NewGameClearUFO
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_NewGameClearUFO(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_NewGameClearUFO");

	Params::NoceCheatTitleLevelExtension_Debug_NewGameClearUFO Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_NewGameRiddleLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_NewGameRiddleLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_NewGameRiddleLevel");

	Params::NoceCheatTitleLevelExtension_Debug_NewGameRiddleLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_NewGameSimulateEnding
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_NewGameSimulateEnding(int32 InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_NewGameSimulateEnding");

	Params::NoceCheatTitleLevelExtension_Debug_NewGameSimulateEnding Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_NewGameSimulateRound
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_NewGameSimulateRound(int32 InRound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_NewGameSimulateRound");

	Params::NoceCheatTitleLevelExtension_Debug_NewGameSimulateRound Parms{};

	Parms.InRound = InRound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_PlayerOutfit
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_PlayerOutfit(int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_PlayerOutfit");

	Params::NoceCheatTitleLevelExtension_Debug_PlayerOutfit Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_SetEndingCleared
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_SetEndingCleared(int32 InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_SetEndingCleared");

	Params::NoceCheatTitleLevelExtension_Debug_SetEndingCleared Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_SetEndingNotCleared
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_SetEndingNotCleared(int32 InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_SetEndingNotCleared");

	Params::NoceCheatTitleLevelExtension_Debug_SetEndingNotCleared Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_SetLastEndingType
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_SetLastEndingType(int32 InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_SetLastEndingType");

	Params::NoceCheatTitleLevelExtension_Debug_SetLastEndingType Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_SetTitleCorruptLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::Debug_SetTitleCorruptLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_SetTitleCorruptLevel");

	Params::NoceCheatTitleLevelExtension_Debug_SetTitleCorruptLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.Debug_ToggleStorageInfo
// (Final, Exec, Native, Public, BlueprintCallable)

void UNoceCheatTitleLevelExtension::Debug_ToggleStorageInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "Debug_ToggleStorageInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.GetAllProgressTags
// (Final, Native, Public)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UNoceCheatTitleLevelExtension::GetAllProgressTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "GetAllProgressTags");

	Params::NoceCheatTitleLevelExtension_GetAllProgressTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.GetAllProgressTagsAndNames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatTitleLevelExtension::GetAllProgressTagsAndNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "GetAllProgressTagsAndNames");

	Params::NoceCheatTitleLevelExtension_GetAllProgressTagsAndNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.GetAllTeleportTagsAndNames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatTitleLevelExtension::GetAllTeleportTagsAndNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "GetAllTeleportTagsAndNames");

	Params::NoceCheatTitleLevelExtension_GetAllTeleportTagsAndNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.GetLevels
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatTitleLevelExtension::GetLevels(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "GetLevels");

	Params::NoceCheatTitleLevelExtension_GetLevels Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.GetLevelTags
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNoceCheatTitleLevelExtension::GetLevelTags(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "GetLevelTags");

	Params::NoceCheatTitleLevelExtension_GetLevelTags Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.JumpLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCheatTitleLevelExtension::JumpLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "JumpLevel");

	Params::NoceCheatTitleLevelExtension_JumpLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCheatTitleLevelExtension.OnJumpLevelWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatTitleLevelExtension::OnJumpLevelWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "OnJumpLevelWindowDecided");

	Params::NoceCheatTitleLevelExtension_OnJumpLevelWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatTitleLevelExtension.UpdateCutSceneNamesAndProgressTags
// (Final, Native, Protected, BlueprintCallable)

void UNoceCheatTitleLevelExtension::UpdateCutSceneNamesAndProgressTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatTitleLevelExtension", "UpdateCutSceneNamesAndProgressTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_AutoSwitchInputIcon
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatUIExtension::Debug_AutoSwitchInputIcon(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_AutoSwitchInputIcon");

	Params::NoceCheatUIExtension_Debug_AutoSwitchInputIcon Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_EnableSavePointFixWeapon
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatUIExtension::Debug_EnableSavePointFixWeapon(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_EnableSavePointFixWeapon");

	Params::NoceCheatUIExtension_Debug_EnableSavePointFixWeapon Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_EnableSavePointOffering
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatUIExtension::Debug_EnableSavePointOffering(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_EnableSavePointOffering");

	Params::NoceCheatUIExtension_Debug_EnableSavePointOffering Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_EnableSavePointUpgrade
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCheatUIExtension::Debug_EnableSavePointUpgrade(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_EnableSavePointUpgrade");

	Params::NoceCheatUIExtension_Debug_EnableSavePointUpgrade Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_HideCredit
// (Final, Exec, Native, Public)

void UNoceCheatUIExtension::Debug_HideCredit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_HideCredit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.Debug_TestQuestUI
// (Final, Exec, Native, Public)

void UNoceCheatUIExtension::Debug_TestQuestUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "Debug_TestQuestUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCheatUIExtension.OnTestQuestWindowDecided
// (Final, Native, Public)
// Parameters:
// const struct FNeoCheatPopWindowOutputParam&Result                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceCheatUIExtension::OnTestQuestWindowDecided(const struct FNeoCheatPopWindowOutputParam& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCheatUIExtension", "OnTestQuestWindowDecided");

	Params::NoceCheatUIExtension_OnTestQuestWindowDecided Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.CompleteAllTutorial
// (Final, Native, Public, BlueprintCallable)

void UNoceTutorialSubsystem::CompleteAllTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "CompleteAllTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.EndTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceTutorialType                       TutorialType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::EndTutorial(ENoceTutorialType TutorialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "EndTutorial");

	Params::NoceTutorialSubsystem_EndTutorial Parms{};

	Parms.TutorialType = TutorialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.EndTutorialByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::EndTutorialByName(class FName TutorialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "EndTutorialByName");

	Params::NoceTutorialSubsystem_EndTutorialByName Parms{};

	Parms.TutorialName = TutorialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.EndTutorialByRowHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceTutorialDataRowHandle&RowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::EndTutorialByRowHandle(const struct FNoceTutorialDataRowHandle& RowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "EndTutorialByRowHandle");

	Params::NoceTutorialSubsystem_EndTutorialByRowHandle Parms{};

	Parms.RowHandle = std::move(RowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.InitializeData
// (Final, Native, Public, BlueprintCallable)

void UNoceTutorialSubsystem::InitializeData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "InitializeData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.IsClearAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTutorialSubsystem::IsClearAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "IsClearAll");

	Params::NoceTutorialSubsystem_IsClearAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialSubsystem.IsCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceTutorialType                       TutorialType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTutorialSubsystem::IsCleared(ENoceTutorialType TutorialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "IsCleared");

	Params::NoceTutorialSubsystem_IsCleared Parms{};

	Parms.TutorialType = TutorialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialSubsystem.IsInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceTutorialType                       TutorialType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTutorialSubsystem::IsInProgress(ENoceTutorialType TutorialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "IsInProgress");

	Params::NoceTutorialSubsystem_IsInProgress Parms{};

	Parms.TutorialType = TutorialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialSubsystem.StartTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceTutorialType                       TutorialType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::StartTutorial(ENoceTutorialType TutorialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "StartTutorial");

	Params::NoceTutorialSubsystem_StartTutorial Parms{};

	Parms.TutorialType = TutorialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.StartTutorialByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::StartTutorialByName(class FName TutorialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "StartTutorialByName");

	Params::NoceTutorialSubsystem_StartTutorialByName Parms{};

	Parms.TutorialName = TutorialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialSubsystem.StartTutorialByRowHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceTutorialDataRowHandle&RowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceTutorialSubsystem::StartTutorialByRowHandle(const struct FNoceTutorialDataRowHandle& RowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialSubsystem", "StartTutorialByRowHandle");

	Params::NoceTutorialSubsystem_StartTutorialByRowHandle Parms{};

	Parms.RowHandle = std::move(RowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.BP_GetEntryWidgetFromItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceTileView::BP_GetEntryWidgetFromItem(const class UObject* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "BP_GetEntryWidgetFromItem");

	Params::NoceTileView_BP_GetEntryWidgetFromItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTileView.BP_ItemFromEntryWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UNoceTileView::BP_ItemFromEntryWidget(class UUserWidget* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "BP_ItemFromEntryWidget");

	Params::NoceTileView_BP_ItemFromEntryWidget Parms{};

	Parms.EntryWidget = EntryWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTileView.BP_UpdateScrollbarVisibility
// (Final, Native, Public)

void UNoceTileView::BP_UpdateScrollbarVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "BP_UpdateScrollbarVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.DisableInputs
// (Final, Native, Public, BlueprintCallable)

void UNoceTileView::DisableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "DisableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.EnableInputs
// (Final, Native, Public, BlueprintCallable)

void UNoceTileView::EnableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "EnableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.GetSelectingIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceTileView::GetSelectingIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "GetSelectingIndex");

	Params::NoceTileView_GetSelectingIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTileView.IsUserScrolling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTileView::IsUserScrolling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "IsUserScrolling");

	Params::NoceTileView_IsUserScrolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTileView.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  TriggerId                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceTileView::PlaySound(const struct FNeoAudioTriggerIdHandle& TriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "PlaySound");

	Params::NoceTileView_PlaySound Parms{};

	Parms.TriggerId = std::move(TriggerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  InSelectSound                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FNeoAudioTriggerIdHandle&  InMouseHoverSound                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceTileView::SetSound(const struct FNeoAudioTriggerIdHandle& InSelectSound, const struct FNeoAudioTriggerIdHandle& InMouseHoverSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "SetSound");

	Params::NoceTileView_SetSound Parms{};

	Parms.InSelectSound = std::move(InSelectSound);
	Parms.InMouseHoverSound = std::move(InMouseHoverSound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTileView.UpdateInput
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInputEvent&               InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTileView::UpdateInput(const struct FInputEvent& InputEvent, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTileView", "UpdateInput");

	Params::NoceTileView_UpdateInput Parms{};

	Parms.InputEvent = std::move(InputEvent);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChooserWidget.BP_UpdateSelectionIndex
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    IsLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChooserWidget::BP_UpdateSelectionIndex(bool IsLeft, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "BP_UpdateSelectionIndex");

	Params::NoceChooserWidget_BP_UpdateSelectionIndex Parms{};

	Parms.IsLeft = IsLeft;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceChooserWidget.GetText
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceChooserWidget::GetText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "GetText");

	Params::NoceChooserWidget_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceChooserWidget.OnMouseDownLeftArrow
// (Final, Native, Protected)

void UNoceChooserWidget::OnMouseDownLeftArrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "OnMouseDownLeftArrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserWidget.OnMouseDownRightArrow
// (Final, Native, Protected)

void UNoceChooserWidget::OnMouseDownRightArrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "OnMouseDownRightArrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserWidget.RefreshText
// (Final, Native, Protected, BlueprintCallable)

void UNoceChooserWidget::RefreshText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "RefreshText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserWidget.SetSetting
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          InSetting                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChooserWidget::SetSetting(class UObject* InSetting, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "SetSetting");

	Params::NoceChooserWidget_SetSetting Parms{};

	Parms.InSetting = InSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceChooserWidget.UpdateInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChooserWidget::UpdateInput(bool IsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "UpdateInput");

	Params::NoceChooserWidget_UpdateInput Parms{};

	Parms.IsLeft = IsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserWidget.UpdateIsDisable
// (Final, Native, Public, BlueprintCallable)

void UNoceChooserWidget::UpdateIsDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "UpdateIsDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceChooserWidget.UpdateSelectionIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceChooserWidget::UpdateSelectionIndex(bool IsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceChooserWidget", "UpdateSelectionIndex");

	Params::NoceChooserWidget_UpdateSelectionIndex Parms{};

	Parms.IsLeft = IsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.DisableClothingWeightWhenSeqStart
// (Native, Public)

void INoceCineCharInterface::DisableClothingWeightWhenSeqStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "DisableClothingWeightWhenSeqStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.DisablePropertyForCineChar
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::DisablePropertyForCineChar(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "DisablePropertyForCineChar");

	Params::NoceCineCharInterface_DisablePropertyForCineChar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceCineCharInterface.EnablePropertyForCineChar
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class UNoceCinematicActorComponent*inCineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::EnablePropertyForCineChar(const class UNoceCinematicActorComponent* inCineComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "EnablePropertyForCineChar");

	Params::NoceCineCharInterface_EnablePropertyForCineChar Parms{};

	Parms.inCineComponent = inCineComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.ResetClothingWeightWhenSeqStart
// (Native, Public)

void INoceCineCharInterface::ResetClothingWeightWhenSeqStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "ResetClothingWeightWhenSeqStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.ResetWeaponStateForGameplay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void INoceCineCharInterface::ResetWeaponStateForGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "ResetWeaponStateForGameplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.SetClearCineActorMeshTransform
// (Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::SetClearCineActorMeshTransform(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "SetClearCineActorMeshTransform");

	Params::NoceCineCharInterface_SetClearCineActorMeshTransform Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.SetEnableLastCamBlendStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::SetEnableLastCamBlendStart(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "SetEnableLastCamBlendStart");

	Params::NoceCineCharInterface_SetEnableLastCamBlendStart Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.SetPreSeamlessTrigger
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::SetPreSeamlessTrigger(class AActor* InTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "SetPreSeamlessTrigger");

	Params::NoceCineCharInterface_SetPreSeamlessTrigger Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.ShowWeaponForCinematic
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::ShowWeaponForCinematic(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "ShowWeaponForCinematic");

	Params::NoceCineCharInterface_ShowWeaponForCinematic Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.UpdateHinaMeshTypeByCurrentSeqData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void INoceCineCharInterface::UpdateHinaMeshTypeByCurrentSeqData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "UpdateHinaMeshTypeByCurrentSeqData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.UpdateWhenSequenceStartForReBindingChar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SequenceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::UpdateWhenSequenceStartForReBindingChar(class AActor* SequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "UpdateWhenSequenceStartForReBindingChar");

	Params::NoceCineCharInterface_UpdateWhenSequenceStartForReBindingChar Parms{};

	Parms.SequenceActor = SequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.UpdateWhenSequenceStopForReBindingChar
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SequenceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceCineCharInterface::UpdateWhenSequenceStopForReBindingChar(class AActor* SequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "UpdateWhenSequenceStopForReBindingChar");

	Params::NoceCineCharInterface_UpdateWhenSequenceStopForReBindingChar Parms{};

	Parms.SequenceActor = SequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCineCharInterface.GetCharacterTag
// (Native, Public, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag INoceCineCharInterface::GetCharacterTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "GetCharacterTag");

	Params::NoceCineCharInterface_GetCharacterTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCineCharInterface.GetEnableLastCamBlendStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceCineCharInterface::GetEnableLastCamBlendStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "GetEnableLastCamBlendStart");

	Params::NoceCineCharInterface_GetEnableLastCamBlendStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCineCharInterface.GetPreSeamlessTrigger
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* INoceCineCharInterface::GetPreSeamlessTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "GetPreSeamlessTrigger");

	Params::NoceCineCharInterface_GetPreSeamlessTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCineCharInterface.IsCineChar
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceCineCharInterface::IsCineChar(bool* NoUse) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "IsCineChar");

	Params::NoceCineCharInterface_IsCineChar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCineCharInterface.IsInCinematic
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceCineCharInterface::IsInCinematic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "IsInCinematic");

	Params::NoceCineCharInterface_IsInCinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCineCharInterface.IsUseSeqData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceCineCharInterface::IsUseSeqData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceCineCharInterface", "IsUseSeqData");

	Params::NoceCineCharInterface_IsUseSeqData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.AddForbiddenInputActions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ENoceInputAction>&         InInputActions                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::AddForbiddenInputActions(const TArray<ENoceInputAction>& InInputActions, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "AddForbiddenInputActions");

	Params::NocePlayerController_AddForbiddenInputActions Parms{};

	Parms.InInputActions = std::move(InInputActions);
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.DoFlushPressedKeys
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerController::DoFlushPressedKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "DoFlushPressedKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.DoInteractAction
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerController::DoInteractAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "DoInteractAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.DoSimulateInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceInputAction                        InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::DoSimulateInputAction(ENoceInputAction InputAction, bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "DoSimulateInputAction");

	Params::NocePlayerController_DoSimulateInputAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.DoSprintAction
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerController::DoSprintAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "DoSprintAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.GetAcceptInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::GetAcceptInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetAcceptInputAction");

	Params::NocePlayerController_GetAcceptInputAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.GetAcceptInputAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::GetAcceptInputAxis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetAcceptInputAxis");

	Params::NocePlayerController_GetAcceptInputAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.GetAcceptInputCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::GetAcceptInputCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetAcceptInputCamera");

	Params::NocePlayerController_GetAcceptInputCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.GetAcceptUIInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::GetAcceptUIInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetAcceptUIInputAction");

	Params::NocePlayerController_GetAcceptUIInputAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.GetInputActionDownTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerController::GetInputActionDownTime(class FName InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetInputActionDownTime");

	Params::NocePlayerController_GetInputActionDownTime Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.GetInputActionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANocePlayerController::GetInputActionName(ENoceInputAction InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "GetInputActionName");

	Params::NocePlayerController_GetInputActionName Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.HaveInputAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::HaveInputAxis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "HaveInputAxis");

	Params::NocePlayerController_HaveInputAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.IsInputActionDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::IsInputActionDown(class FName InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "IsInputActionDown");

	Params::NocePlayerController_IsInputActionDown Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.IsInputActionForbidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::IsInputActionForbidden(ENoceInputAction InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "IsInputActionForbidden");

	Params::NocePlayerController_IsInputActionForbidden Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.IsInputActionPressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::IsInputActionPressed(class FName InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "IsInputActionPressed");

	Params::NocePlayerController_IsInputActionPressed Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.IsPlayerInputValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerController::IsPlayerInputValid(class FName InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "IsPlayerInputValid");

	Params::NocePlayerController_IsPlayerInputValid Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerController.RemoveForbiddenInputActions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ENoceInputAction>&         InInputActions                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::RemoveForbiddenInputActions(const TArray<ENoceInputAction>& InInputActions, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "RemoveForbiddenInputActions");

	Params::NocePlayerController_RemoveForbiddenInputActions Parms{};

	Parms.InInputActions = std::move(InInputActions);
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.ResetForbiddenInputActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::ResetForbiddenInputActions(class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "ResetForbiddenInputActions");

	Params::NocePlayerController_ResetForbiddenInputActions Parms{};

	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.SetAcceptInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAcceptAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAcceptAxis                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAcceptUIAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::SetAcceptInputAction(bool InAcceptAction, bool InAcceptAxis, bool InAcceptUIAction, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "SetAcceptInputAction");

	Params::NocePlayerController_SetAcceptInputAction Parms{};

	Parms.InAcceptAction = InAcceptAction;
	Parms.InAcceptAxis = InAcceptAxis;
	Parms.InAcceptUIAction = InAcceptUIAction;
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.SetAcceptInputActionAndCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAcceptAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAcceptAxis                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAcceptUIAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAcceptCamera                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::SetAcceptInputActionAndCamera(bool InAcceptAction, bool InAcceptAxis, bool InAcceptUIAction, bool InAcceptCamera, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "SetAcceptInputActionAndCamera");

	Params::NocePlayerController_SetAcceptInputActionAndCamera Parms{};

	Parms.InAcceptAction = InAcceptAction;
	Parms.InAcceptAxis = InAcceptAxis;
	Parms.InAcceptUIAction = InAcceptUIAction;
	Parms.InAcceptCamera = InAcceptCamera;
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerController.SetNonForbiddenInputActions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ENoceInputAction>&         InInputActions                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerController::SetNonForbiddenInputActions(const TArray<ENoceInputAction>& InInputActions, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerController", "SetNonForbiddenInputActions");

	Params::NocePlayerController_SetNonForbiddenInputActions Parms{};

	Parms.InInputActions = std::move(InInputActions);
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitlePlayerController.OnMainMenuClosed
// (Final, Native, Public)

void ANoceTitlePlayerController::OnMainMenuClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitlePlayerController", "OnMainMenuClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitlePlayerController.OnTitleClose
// (Final, Native, Public)

void ANoceTitlePlayerController::OnTitleClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitlePlayerController", "OnTitleClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitlePlayerController.OnTitleFlowClose
// (Final, Native, Public)

void ANoceTitlePlayerController::OnTitleFlowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitlePlayerController", "OnTitleFlowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitlePlayerController.ShowMainMenu
// (Final, Native, Public, BlueprintCallable)

void ANoceTitlePlayerController::ShowMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitlePlayerController", "ShowMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceClawAttrackSoulWidget.BP_SetBarRatio
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceClawAttrackSoulWidget::BP_SetBarRatio(float InRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceClawAttrackSoulWidget", "BP_SetBarRatio");

	Params::NoceClawAttrackSoulWidget_BP_SetBarRatio Parms{};

	Parms.InRatio = InRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceClawAttrackSoulWidget.BP_SetHoldTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InHoldTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceClawAttrackSoulWidget::BP_SetHoldTime(float InHoldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceClawAttrackSoulWidget", "BP_SetHoldTime");

	Params::NoceClawAttrackSoulWidget_BP_SetHoldTime Parms{};

	Parms.InHoldTime = InHoldTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceClawAttrackSoulWidget.BP_StartPressing
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceClawAttrackSoulWidget::BP_StartPressing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceClawAttrackSoulWidget", "BP_StartPressing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceNotebookPageTabChildWidget.Init
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FNoceUINotebookCategoryData&InData                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InDefaultColor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InSelectColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookPageTabChildWidget::Init(const struct FNoceUINotebookCategoryData& InData, const struct FLinearColor& InDefaultColor, const struct FLinearColor& InSelectColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPageTabChildWidget", "Init");

	Params::NoceNotebookPageTabChildWidget_Init Parms{};

	Parms.InData = std::move(InData);
	Parms.InDefaultColor = std::move(InDefaultColor);
	Parms.InSelectColor = std::move(InSelectColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookPageTabChildWidget.SetViewed
// (Final, Native, Public, BlueprintCallable)

void UNoceNotebookPageTabChildWidget::SetViewed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPageTabChildWidget", "SetViewed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.IsCompleteCondition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTutorialInstructor::IsCompleteCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "IsCompleteCondition");

	Params::NoceTutorialInstructor_IsCompleteCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialInstructor.IsInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTutorialInstructor::IsInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "IsInProgress");

	Params::NoceTutorialInstructor_IsInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialInstructor.IsPreviousTutorialClear
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTutorialInstructor::IsPreviousTutorialClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "IsPreviousTutorialClear");

	Params::NoceTutorialInstructor_IsPreviousTutorialClear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialInstructor.IsStartCondition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceTutorialInstructor::IsStartCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "IsStartCondition");

	Params::NoceTutorialInstructor_IsStartCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTutorialInstructor.OnTutorialClose
// (Native, Event, Public, BlueprintEvent)

void ANoceTutorialInstructor::OnTutorialClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "OnTutorialClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.OnTutorialFinish
// (Native, Event, Public, BlueprintEvent)

void ANoceTutorialInstructor::OnTutorialFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "OnTutorialFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.OnTutorialStart
// (Native, Event, Public, BlueprintEvent)

void ANoceTutorialInstructor::OnTutorialStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "OnTutorialStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.OnTutorialTrigger
// (Native, Event, Public, BlueprintEvent)

void ANoceTutorialInstructor::OnTutorialTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "OnTutorialTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.TickFinish
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTutorialInstructor::TickFinish(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "TickFinish");

	Params::NoceTutorialInstructor_TickFinish Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.TickListening
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTutorialInstructor::TickListening(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "TickListening");

	Params::NoceTutorialInstructor_TickListening Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialInstructor.TickStart
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTutorialInstructor::TickStart(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialInstructor", "TickStart");

	Params::NoceTutorialInstructor_TickStart Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.AddRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::AddRestriction(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "AddRestriction");

	Params::NoceUICommonMessageSubsystem_AddRestriction Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.HideMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUICommonMessageType                InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::HideMessage(ENoceUICommonMessageType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "HideMessage");

	Params::NoceUICommonMessageSubsystem_HideMessage Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.OnConnectionChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    IsConnected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInputDeviceType                    DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::OnConnectionChanged(bool IsConnected, int32 UserId, ENoceInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "OnConnectionChanged");

	Params::NoceUICommonMessageSubsystem_OnConnectionChanged Parms{};

	Parms.IsConnected = IsConnected;
	Parms.UserId = UserId;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.OnPlayerControllerEndPlay
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::OnPlayerControllerEndPlay(class AActor* Player, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "OnPlayerControllerEndPlay");

	Params::NoceUICommonMessageSubsystem_OnPlayerControllerEndPlay Parms{};

	Parms.Player = Player;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.RemoveRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::RemoveRestriction(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "RemoveRestriction");

	Params::NoceUICommonMessageSubsystem_RemoveRestriction Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUICommonMessageSubsystem.ShowMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUICommonMessageType                InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUICommonMessageSubsystem::ShowMessage(ENoceUICommonMessageType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUICommonMessageSubsystem", "ShowMessage");

	Params::NoceUICommonMessageSubsystem_ShowMessage Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommandCreditWidget.AddDeltaTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCommandCreditWidget::AddDeltaTime(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommandCreditWidget", "AddDeltaTime");

	Params::NoceCommandCreditWidget_AddDeltaTime Parms{};

	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommandCreditWidget.ResetDeltaTime
// (Final, Native, Public, BlueprintCallable)

void UNoceCommandCreditWidget::ResetDeltaTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommandCreditWidget", "ResetDeltaTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommandCreditWidget.UpdateDebugSpeed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceCommandCreditWidget::UpdateDebugSpeed(float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommandCreditWidget", "UpdateDebugSpeed");

	Params::NoceCommandCreditWidget_UpdateDebugSpeed Parms{};

	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCommonGuideItemWidget.SetData
// (Final, Native, Public, BlueprintCallable)

void UNoceCommonGuideItemWidget::SetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonGuideItemWidget", "SetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommonGuideItemWidget.UpdateIcons
// (Final, Native, Public)
// Parameters:
// const TArray<class FName>&              IconNames                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceCommonGuideItemWidget::UpdateIcons(const TArray<class FName>& IconNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonGuideItemWidget", "UpdateIcons");

	Params::NoceCommonGuideItemWidget_UpdateIcons Parms{};

	Parms.IconNames = std::move(IconNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommonMessageWidget.OnGuideChanged
// (Final, Native, Protected)

void UNoceCommonMessageWidget::OnGuideChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonMessageWidget", "OnGuideChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommonMessageWidget.OnTopWidgetChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCommonMessageWidget::OnTopWidgetChanged(int32 Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonMessageWidget", "OnTopWidgetChanged");

	Params::NoceCommonMessageWidget_OnTopWidgetChanged Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceCommonWindowWidget.ShowText
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCommonWindowWidget::ShowText(const class FText& InText, const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCommonWindowWidget", "ShowText");

	Params::NoceCommonWindowWidget_ShowText Parms{};

	Parms.InText = std::move(InText);
	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveGame.AnyEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveGame::AnyEndingCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "AnyEndingCleared");

	Params::NoceSaveGame_AnyEndingCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetCurrentRound
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveGame::GetCurrentRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetCurrentRound");

	Params::NoceSaveGame_GetCurrentRound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetCurrentRoundType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType UNoceSaveGame::GetCurrentRoundType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetCurrentRoundType");

	Params::NoceSaveGame_GetCurrentRoundType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetDefiniteEndingType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEndingType UNoceSaveGame::GetDefiniteEndingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetDefiniteEndingType");

	Params::NoceSaveGame_GetDefiniteEndingType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetEndingClearedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveGame::GetEndingClearedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetEndingClearedCount");

	Params::NoceSaveGame_GetEndingClearedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetPlayerOutfitValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerOutfit                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePlayerOutfit UNoceSaveGame::GetPlayerOutfitValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetPlayerOutfitValue");

	Params::NoceSaveGame_GetPlayerOutfitValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.GetPlayerStartTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UNoceSaveGame::GetPlayerStartTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "GetPlayerStartTransform");

	Params::NoceSaveGame_GetPlayerStartTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.HandleInheritToNextRound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ClearProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveGame::HandleInheritToNextRound(bool ClearProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "HandleInheritToNextRound");

	Params::NoceSaveGame_HandleInheritToNextRound Parms{};

	Parms.ClearProgress = ClearProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveGame.HasSaveRecord
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveGame::HasSaveRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "HasSaveRecord");

	Params::NoceSaveGame_HasSaveRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.IsEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveGame::IsEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "IsEndingCleared");

	Params::NoceSaveGame_IsEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveGame.RemoveEndingFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveGame::RemoveEndingFlag(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "RemoveEndingFlag");

	Params::NoceSaveGame_RemoveEndingFlag Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveGame.SetDefiniteEndingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveGame::SetDefiniteEndingType(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "SetDefiniteEndingType");

	Params::NoceSaveGame_SetDefiniteEndingType Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveGame.SetEndingCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveGame::SetEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "SetEndingCleared");

	Params::NoceSaveGame_SetEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveGame.SetPlayerOutfitValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerOutfit                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveGame::SetPlayerOutfitValue(ENocePlayerOutfit InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveGame", "SetPlayerOutfitValue");

	Params::NoceSaveGame_SetPlayerOutfitValue Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.CompleteExecutingActions
// (Native, Public, BlueprintCallable)

void UNoceConditionHandler::CompleteExecutingActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "CompleteExecutingActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.ExecuteAction
// (Native, Public, BlueprintCallable)
// Parameters:
// class UNoceActionBase*                  Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceConditionHandler::ExecuteAction(class UNoceActionBase* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "ExecuteAction");

	Params::NoceConditionHandler_ExecuteAction Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.ExecuteFailedActions
// (Native, Public, BlueprintCallable)

void UNoceConditionHandler::ExecuteFailedActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "ExecuteFailedActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.ExecuteNextAction
// (Native, Public, BlueprintCallable)

void UNoceConditionHandler::ExecuteNextAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "ExecuteNextAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.ExecuteSuccessActions
// (Native, Public, BlueprintCallable)

void UNoceConditionHandler::ExecuteSuccessActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "ExecuteSuccessActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.GetCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceConditionBase*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceConditionBase* UNoceConditionHandler::GetCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "GetCondition");

	Params::NoceConditionHandler_GetCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceConditionHandler.HandleCondition
// (Native, Public, BlueprintCallable)

void UNoceConditionHandler::HandleCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "HandleCondition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceConditionHandler.IsConditionMatch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceConditionHandler::IsConditionMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceConditionHandler", "IsConditionMatch");

	Params::NoceConditionHandler_IsConditionMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCreditListItemWidget.SetData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FNoceUICreditData&         Data                                                   (Parm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceCreditListItemWidget::SetData(const struct FNoceUICreditData& Data, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCreditListItemWidget", "SetData");

	Params::NoceCreditListItemWidget_SetData Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceSaveSubsystem.AddGameOverCount
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::AddGameOverCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "AddGameOverCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.AnyGameSlotExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::AnyGameSlotExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "AnyGameSlotExist");

	Params::NoceSaveSubsystem_AnyGameSlotExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.AutoLoadContinueGameSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::AutoLoadContinueGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "AutoLoadContinueGameSave");

	Params::NoceSaveSubsystem_AutoLoadContinueGameSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.AutoLoadGameData_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::AutoLoadGameData_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "AutoLoadGameData_BP");

	Params::NoceSaveSubsystem_AutoLoadGameData_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.AutoSaveGameData_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LocationName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::AutoSaveGameData_BP(class FName LocationName, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "AutoSaveGameData_BP");

	Params::NoceSaveSubsystem_AutoSaveGameData_BP Parms{};

	Parms.LocationName = LocationName;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.CacheCheckPointActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocationName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::CacheCheckPointActor(class AActor* Actor, class FName LocationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "CacheCheckPointActor");

	Params::NoceSaveSubsystem_CacheCheckPointActor Parms{};

	Parms.Actor = Actor;
	Parms.LocationName = LocationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.CacheSpecifyStartTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                InTransform                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              WorldTriggerSetting                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::CacheSpecifyStartTransform(const struct FTransform& InTransform, const TArray<class FName>& WorldTriggerSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "CacheSpecifyStartTransform");

	Params::NoceSaveSubsystem_CacheSpecifyStartTransform Parms{};

	Parms.InTransform = std::move(InTransform);
	Parms.WorldTriggerSetting = std::move(WorldTriggerSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.ClearCheckPointActor
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::ClearCheckPointActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "ClearCheckPointActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.ClearCurrentGameData
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::ClearCurrentGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "ClearCurrentGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.ClearTemporarySaveGame
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::ClearTemporarySaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "ClearTemporarySaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.DeleteAllAutoSaveGameData
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::DeleteAllAutoSaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeleteAllAutoSaveGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.DeleteAllGameData
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::DeleteAllGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeleteAllGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.DeleteAllManualSaveGameData
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::DeleteAllManualSaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeleteAllManualSaveGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.DeleteGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DeleteGameData(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeleteGameData");

	Params::NoceSaveSubsystem_DeleteGameData Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.DeleteSystemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DeleteSystemData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeleteSystemData");

	Params::NoceSaveSubsystem_DeleteSystemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.DeserializeGameDataBeforeOpenLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DeserializeGameDataBeforeOpenLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeserializeGameDataBeforeOpenLevel");

	Params::NoceSaveSubsystem_DeserializeGameDataBeforeOpenLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.DeserializeGameDataOnStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DeserializeGameDataOnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DeserializeGameDataOnStart");

	Params::NoceSaveSubsystem_DeserializeGameDataOnStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.DoesGameSlotExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DoesGameSlotExist(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DoesGameSlotExist");

	Params::NoceSaveSubsystem_DoesGameSlotExist Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.DoesSystemSlotExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::DoesSystemSlotExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "DoesSystemSlotExist");

	Params::NoceSaveSubsystem_DoesSystemSlotExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetAutoSaveCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetAutoSaveCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetAutoSaveCount");

	Params::NoceSaveSubsystem_GetAutoSaveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetAutoSaveLastIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetAutoSaveLastIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetAutoSaveLastIndex");

	Params::NoceSaveSubsystem_GetAutoSaveLastIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetAutoSaveSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetAutoSaveSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetAutoSaveSlotIndex");

	Params::NoceSaveSubsystem_GetAutoSaveSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetAutoSaveStartIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetAutoSaveStartIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetAutoSaveStartIndex");

	Params::NoceSaveSubsystem_GetAutoSaveStartIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetCurrentSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceSaveGame*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSaveGame* UNoceSaveSubsystem::GetCurrentSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetCurrentSaveGame");

	Params::NoceSaveSubsystem_GetCurrentSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetCurrentSaveGameSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetCurrentSaveGameSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetCurrentSaveGameSlotIndex");

	Params::NoceSaveSubsystem_GetCurrentSaveGameSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetGameSaveMaxIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetGameSaveMaxIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetGameSaveMaxIndex");

	Params::NoceSaveSubsystem_GetGameSaveMaxIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetLastLoadGameSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetLastLoadGameSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetLastLoadGameSlotIndex");

	Params::NoceSaveSubsystem_GetLastLoadGameSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetLastManualSaveSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetLastManualSaveSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetLastManualSaveSlotIndex");

	Params::NoceSaveSubsystem_GetLastManualSaveSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetLastTimeStampSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    StartFromAutoSlot                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetLastTimeStampSlotIndex(bool StartFromAutoSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetLastTimeStampSlotIndex");

	Params::NoceSaveSubsystem_GetLastTimeStampSlotIndex Parms{};

	Parms.StartFromAutoSlot = StartFromAutoSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetManualSaveStartIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetManualSaveStartIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetManualSaveStartIndex");

	Params::NoceSaveSubsystem_GetManualSaveStartIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSaveGameByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceSaveGame*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSaveGame* UNoceSaveSubsystem::GetSaveGameByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSaveGameByIndex");

	Params::NoceSaveSubsystem_GetSaveGameByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSaveGameBySlot
// (Final, Native, Public)
// Parameters:
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceSaveGame*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSaveGame* UNoceSaveSubsystem::GetSaveGameBySlot(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSaveGameBySlot");

	Params::NoceSaveSubsystem_GetSaveGameBySlot Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSaveGameList
// (Final, Native, Public)
// Parameters:
// bool                                    StartFromAutoSlot                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNoceSaveGame*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UNoceSaveGame*> UNoceSaveSubsystem::GetSaveGameList(bool StartFromAutoSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSaveGameList");

	Params::NoceSaveSubsystem_GetSaveGameList Parms{};

	Parms.StartFromAutoSlot = StartFromAutoSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSaveLoadObjectList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StartFromAutoSlot                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USaveLoadUIObject*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class USaveLoadUIObject*> UNoceSaveSubsystem::GetSaveLoadObjectList(bool StartFromAutoSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSaveLoadObjectList");

	Params::NoceSaveSubsystem_GetSaveLoadObjectList Parms{};

	Parms.StartFromAutoSlot = StartFromAutoSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSuitableManualSaveSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetSuitableManualSaveSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSuitableManualSaveSlot");

	Params::NoceSaveSubsystem_GetSuitableManualSaveSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetSystemSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceSystemSaveGame*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSystemSaveGame* UNoceSaveSubsystem::GetSystemSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetSystemSaveGame");

	Params::NoceSaveSubsystem_GetSystemSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.HasLoadedGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::HasLoadedGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "HasLoadedGame");

	Params::NoceSaveSubsystem_HasLoadedGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsAutoSaveSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsAutoSaveSlot(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsAutoSaveSlot");

	Params::NoceSaveSubsystem_IsAutoSaveSlot Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsBusy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsBusy");

	Params::NoceSaveSubsystem_IsBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsCheckPointAlreadySaved
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InProgressTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsCheckPointAlreadySaved(const struct FGameplayTag& InProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsCheckPointAlreadySaved");

	Params::NoceSaveSubsystem_IsCheckPointAlreadySaved Parms{};

	Parms.InProgressTag = std::move(InProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsManualSaveSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsManualSaveSlot(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsManualSaveSlot");

	Params::NoceSaveSubsystem_IsManualSaveSlot Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsPlayGoRangeTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InProgressTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsPlayGoRangeTag(const struct FGameplayTag& InProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsPlayGoRangeTag");

	Params::NoceSaveSubsystem_IsPlayGoRangeTag Parms{};

	Parms.InProgressTag = std::move(InProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.IsTemporarySaveExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::IsTemporarySaveExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "IsTemporarySaveExist");

	Params::NoceSaveSubsystem_IsTemporarySaveExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.LoadGameData_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::LoadGameData_BP(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "LoadGameData_BP");

	Params::NoceSaveSubsystem_LoadGameData_BP Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.LoadTemporarySaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::LoadTemporarySaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "LoadTemporarySaveGameData");

	Params::NoceSaveSubsystem_LoadTemporarySaveGameData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.MakeClearGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         ClearEndingType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::MakeClearGameData(const int32 Index_0, ENoceEndingType ClearEndingType, bool ClearProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "MakeClearGameData");

	Params::NoceSaveSubsystem_MakeClearGameData Parms{};

	Parms.Index_0 = Index_0;
	Parms.ClearEndingType = ClearEndingType;
	Parms.ClearProgress = ClearProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.MakeSaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocationName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::MakeSaveGameData(int32 Index_0, class FName LocationName, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "MakeSaveGameData");

	Params::NoceSaveSubsystem_MakeSaveGameData Parms{};

	Parms.Index_0 = Index_0;
	Parms.LocationName = LocationName;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.MakeTemporarySaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::MakeTemporarySaveGameData(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "MakeTemporarySaveGameData");

	Params::NoceSaveSubsystem_MakeTemporarySaveGameData Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.RequestLoadGeneralActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RestoreTransform                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::RequestLoadGeneralActor(class AActor* InActor, bool RestoreTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "RequestLoadGeneralActor");

	Params::NoceSaveSubsystem_RequestLoadGeneralActor Parms{};

	Parms.InActor = InActor;
	Parms.RestoreTransform = RestoreTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.RequestLoadSubsystem
// (Final, Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::RequestLoadSubsystem(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "RequestLoadSubsystem");

	Params::NoceSaveSubsystem_RequestLoadSubsystem Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.RequestSaveGeneralActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InExistForever                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::RequestSaveGeneralActor(class AActor* InActor, bool InExistForever)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "RequestSaveGeneralActor");

	Params::NoceSaveSubsystem_RequestSaveGeneralActor Parms{};

	Parms.InActor = InActor;
	Parms.InExistForever = InExistForever;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.RequestSaveSubsystem
// (Final, Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveSubsystem::RequestSaveSubsystem(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "RequestSaveSubsystem");

	Params::NoceSaveSubsystem_RequestSaveSubsystem Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.ResetSpecifyTransform
// (Final, Native, Public, BlueprintCallable)

void UNoceSaveSubsystem::ResetSpecifyTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "ResetSpecifyTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSaveSubsystem.SaveClearGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         ClearEndingType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::SaveClearGame(const int32 Index_0, ENoceEndingType ClearEndingType, bool ClearProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "SaveClearGame");

	Params::NoceSaveSubsystem_SaveClearGame Parms{};

	Parms.Index_0 = Index_0;
	Parms.ClearEndingType = ClearEndingType;
	Parms.ClearProgress = ClearProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.SaveGameData_BP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocationName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::SaveGameData_BP(int32 Index_0, class FName LocationName, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "SaveGameData_BP");

	Params::NoceSaveSubsystem_SaveGameData_BP Parms{};

	Parms.Index_0 = Index_0;
	Parms.LocationName = LocationName;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.SaveSystemSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveSubsystem::SaveSystemSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "SaveSystemSave");

	Params::NoceSaveSubsystem_SaveSystemSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.TransferToUIObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UNoceSaveGame*              SaveGame                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveLoadUIObject*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveLoadUIObject* UNoceSaveSubsystem::TransferToUIObject(const class UNoceSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "TransferToUIObject");

	Params::NoceSaveSubsystem_TransferToUIObject Parms{};

	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveSubsystem.GetPlatformUserIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSaveSubsystem::GetPlatformUserIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveSubsystem", "GetPlatformUserIndex");

	Params::NoceSaveSubsystem_GetPlatformUserIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceCustomGrid.SetupNavigationSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FNoceUICustomGridNavigationSetting>&InSetting                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceCustomGrid::SetupNavigationSetting(const TArray<struct FNoceUICustomGridNavigationSetting>& InSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceCustomGrid", "SetupNavigationSetting");

	Params::NoceCustomGrid_SetupNavigationSetting Parms{};

	Parms.InSetting = std::move(InSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKeyMappingText.SetTextStyleKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIKeyMappingText::SetTextStyleKey(int32 Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKeyMappingText", "SetTextStyleKey");

	Params::NoceUIKeyMappingText_SetTextStyleKey Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKeyMappingText.SetWrapTextAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWrapTextAt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIKeyMappingText::SetWrapTextAt(float InWrapTextAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKeyMappingText", "SetWrapTextAt");

	Params::NoceUIKeyMappingText_SetWrapTextAt Parms{};

	Parms.InWrapTextAt = InWrapTextAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDamageHandleComponent.NotifyOnDamageEvent
// (Final, Native, Public)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComboName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDamageHandleComponent::NotifyOnDamageEvent(class AActor* Attacker, class FName ComboName, float InHealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDamageHandleComponent", "NotifyOnDamageEvent");

	Params::NoceDamageHandleComponent_NotifyOnDamageEvent Parms{};

	Parms.Attacker = Attacker;
	Parms.ComboName = ComboName;
	Parms.InHealthDamage = InHealthDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDamageHandleComponent.NotifyPreDamageEvent
// (Final, Native, Public)
// Parameters:
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSanityDamage                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDamageHandleComponent::NotifyPreDamageEvent(float InHealthDamage, float InMaxSanityDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDamageHandleComponent", "NotifyPreDamageEvent");

	Params::NoceDamageHandleComponent_NotifyPreDamageEvent Parms{};

	Parms.InHealthDamage = InHealthDamage;
	Parms.InMaxSanityDamage = InMaxSanityDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISelectableWidgetInterface.OnDecide
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::OnDecide(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "OnDecide");

	Params::NoceUISelectableWidgetInterface_OnDecide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUISelectableWidgetInterface.OnFocus
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::OnFocus(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "OnFocus");

	Params::NoceUISelectableWidgetInterface_OnFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUISelectableWidgetInterface.OnReset
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::OnReset(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "OnReset");

	Params::NoceUISelectableWidgetInterface_OnReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUISelectableWidgetInterface.OnSelect
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::OnSelect(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "OnSelect");

	Params::NoceUISelectableWidgetInterface_OnSelect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUISelectableWidgetInterface.OnUnfocus
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::OnUnfocus(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "OnUnfocus");

	Params::NoceUISelectableWidgetInterface_OnUnfocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceUISelectableWidgetInterface.SetContainer
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          NewContainer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceUISelectableWidgetInterface::SetContainer(class UObject* NewContainer, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUISelectableWidgetInterface", "SetContainer");

	Params::NoceUISelectableWidgetInterface_SetContainer Parms{};

	Parms.NewContainer = NewContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceDebugDrawComponent.AddText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    InStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDebugDrawComponent::AddText(const class FString& InStr, const struct FColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugDrawComponent", "AddText");

	Params::NoceDebugDrawComponent_AddText Parms{};

	Parms.InStr = std::move(InStr);
	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDebugDrawComponent.ClearPendingText
// (Final, Native, Public, BlueprintCallable)

void UNoceDebugDrawComponent::ClearPendingText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugDrawComponent", "ClearPendingText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDebugDrawComponent.DrawBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDebugDrawComponent::DrawBox(const struct FVector2D& Pos, const struct FVector2D& Extent, const struct FColor& LineColor, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugDrawComponent", "DrawBox");

	Params::NoceDebugDrawComponent_DrawBox Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Extent = std::move(Extent);
	Parms.LineColor = std::move(LineColor);
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDebugDrawComponent.DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDebugDrawComponent::DrawLine(const struct FVector2D& Start, const struct FVector2D& End, const struct FColor& LineColor, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDebugDrawComponent", "DrawLine");

	Params::NoceDebugDrawComponent_DrawLine Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.LineColor = std::move(LineColor);
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDecalStreamingHelperComponent.SetTrackedDecal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDecalComponent*                  InDecal                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDecalStreamingHelperComponent::SetTrackedDecal(class UDecalComponent* InDecal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDecalStreamingHelperComponent", "SetTrackedDecal");

	Params::NoceDecalStreamingHelperComponent_SetTrackedDecal Parms{};

	Parms.InDecal = InDecal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleWidget.OnLogoDefaultFinished
// (Final, Native, Protected)

void UNoceTitleWidget::OnLogoDefaultFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleWidget", "OnLogoDefaultFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleWidget.OnLogoToPressCompleted
// (Final, Native, Protected)

void UNoceTitleWidget::OnLogoToPressCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleWidget", "OnLogoToPressCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.CancelSerialDialogSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::CancelSerialDialogSet(class FName TagOrId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "CancelSerialDialogSet");

	Params::NoceDialogSubsystem_CancelSerialDialogSet Parms{};

	Parms.TagOrId = TagOrId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.ClearCurrentDialog
// (Final, Native, Public, BlueprintCallable)

void UNoceDialogSubsystem::ClearCurrentDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "ClearCurrentDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.GetSpeakerDataHolderAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceSpeakerDataHolderAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSpeakerDataHolderAsset* UNoceDialogSubsystem::GetSpeakerDataHolderAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "GetSpeakerDataHolderAsset");

	Params::NoceDialogSubsystem_GetSpeakerDataHolderAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.HasAnyDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::HasAnyDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "HasAnyDialog");

	Params::NoceDialogSubsystem_HasAnyDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.IsDialogLineOrSetOnScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::IsDialogLineOrSetOnScreen(class FName TagOrId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "IsDialogLineOrSetOnScreen");

	Params::NoceDialogSubsystem_IsDialogLineOrSetOnScreen Parms{};

	Parms.TagOrId = TagOrId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.IsDialogOnScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::IsDialogOnScreen(class FName TagOrId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "IsDialogOnScreen");

	Params::NoceDialogSubsystem_IsDialogOnScreen Parms{};

	Parms.TagOrId = TagOrId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.IsDialogSetOnScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::IsDialogSetOnScreen(class FName TagOrId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "IsDialogSetOnScreen");

	Params::NoceDialogSubsystem_IsDialogSetOnScreen Parms{};

	Parms.TagOrId = TagOrId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.MuteDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    RequestID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MuteImportantDialog                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedClearCurrentDialog                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::MuteDialog(const class FString& RequestID, bool MuteImportantDialog, bool NeedClearCurrentDialog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "MuteDialog");

	Params::NoceDialogSubsystem_MuteDialog Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.MuteImportantDialog = MuteImportantDialog;
	Parms.NeedClearCurrentDialog = NeedClearCurrentDialog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnDialogAudioEventEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayingID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::OnDialogAudioEventEnd(int32 PlayingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnDialogAudioEventEnd");

	Params::NoceDialogSubsystem_OnDialogAudioEventEnd Parms{};

	Parms.PlayingID = PlayingID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnEnterEvent
// (Final, Native, Protected)

void UNoceDialogSubsystem::OnEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnExitEvent
// (Final, Native, Protected)

void UNoceDialogSubsystem::OnExitEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnExitEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnProgressChanged");

	Params::NoceDialogSubsystem_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnProgressInitialized");

	Params::NoceDialogSubsystem_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnSettingChanged
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::OnSettingChanged(class UNoceSystemSaveGame* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnSettingChanged");

	Params::NoceDialogSubsystem_OnSettingChanged Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.OnSystemSaveLoaded
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              InSystemSave                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::OnSystemSaveLoaded(class UNoceSystemSaveGame* InSystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "OnSystemSaveLoaded");

	Params::NoceDialogSubsystem_OnSystemSaveLoaded Parms{};

	Parms.InSystemSave = InSystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.RegisterDialogToSpeaker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceDialogSpeaker                      Speaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::RegisterDialogToSpeaker(ENoceDialogSpeaker Speaker, class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "RegisterDialogToSpeaker");

	Params::NoceDialogSubsystem_RegisterDialogToSpeaker Parms{};

	Parms.Speaker = Speaker;
	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.RequestDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDialogLine&           InDialogLine                                           (Parm, NativeAccessSpecifierPublic)
// const struct FNoceDialogAnimSetting&    AnimSetting                                            (Parm, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::RequestDialog(class FName TagOrId, const struct FNoceDialogLine& InDialogLine, const struct FNoceDialogAnimSetting& AnimSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "RequestDialog");

	Params::NoceDialogSubsystem_RequestDialog Parms{};

	Parms.TagOrId = TagOrId;
	Parms.InDialogLine = std::move(InDialogLine);
	Parms.AnimSetting = std::move(AnimSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.RequestDialogByRowHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceDialogDataRowHandle&  DialogRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::RequestDialogByRowHandle(const struct FNoceDialogDataRowHandle& DialogRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "RequestDialogByRowHandle");

	Params::NoceDialogSubsystem_RequestDialogByRowHandle Parms{};

	Parms.DialogRowHandle = std::move(DialogRowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.RequestDialogOrSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       DialogRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceDialogSubsystem::RequestDialogOrSet(const struct FDataTableRowHandle& DialogRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "RequestDialogOrSet");

	Params::NoceDialogSubsystem_RequestDialogOrSet Parms{};

	Parms.DialogRowHandle = std::move(DialogRowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceDialogSubsystem.RequestDialogSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDialogSet&            InDialogSet                                            (Parm, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::RequestDialogSet(class FName TagOrId, const struct FNoceDialogSet& InDialogSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "RequestDialogSet");

	Params::NoceDialogSubsystem_RequestDialogSet Parms{};

	Parms.TagOrId = TagOrId;
	Parms.InDialogSet = std::move(InDialogSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.SetForbitChangeVoiceLanguage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InForbit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::SetForbitChangeVoiceLanguage(bool InForbit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "SetForbitChangeVoiceLanguage");

	Params::NoceDialogSubsystem_SetForbitChangeVoiceLanguage Parms{};

	Parms.InForbit = InForbit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.SetSpeakerDataHolderAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceSpeakerDataHolderAsset*      SpeakerData                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::SetSpeakerDataHolderAsset(class UNoceSpeakerDataHolderAsset* SpeakerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "SetSpeakerDataHolderAsset");

	Params::NoceDialogSubsystem_SetSpeakerDataHolderAsset Parms{};

	Parms.SpeakerData = SpeakerData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.UnmuteDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    RequestID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::UnmuteDialog(const class FString& RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "UnmuteDialog");

	Params::NoceDialogSubsystem_UnmuteDialog Parms{};

	Parms.RequestID = std::move(RequestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDialogSubsystem.UnregisterDialogFromSpeaker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceDialogSpeaker                      Speaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDialogSubsystem::UnregisterDialogFromSpeaker(ENoceDialogSpeaker Speaker, class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDialogSubsystem", "UnregisterDialogFromSpeaker");

	Params::NoceDialogSubsystem_UnregisterDialogFromSpeaker Parms{};

	Parms.Speaker = Speaker;
	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDurabilityBallWidget.SetProperty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsBroken                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFull                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDurabilityBallWidget::SetProperty(bool IsBroken, bool IsFull)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDurabilityBallWidget", "SetProperty");

	Params::NoceDurabilityBallWidget_SetProperty Parms{};

	Parms.IsBroken = IsBroken;
	Parms.IsFull = IsFull;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDurabilityWidget.PlayStopDanger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsPlay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDurabilityWidget::PlayStopDanger(bool IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDurabilityWidget", "PlayStopDanger");

	Params::NoceDurabilityWidget_PlayStopDanger Parms{};

	Parms.IsPlay = IsPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDurabilityWidget.SetDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             WeaponName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDurabilityWidget::SetDurability(class FName WeaponName, float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDurabilityWidget", "SetDurability");

	Params::NoceDurabilityWidget_SetDurability Parms{};

	Parms.WeaponName = WeaponName;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapLocationWidget.SetAlwaysLoaded
// (Final, Native, Public, BlueprintCallable)

void UNoceMapLocationWidget::SetAlwaysLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapLocationWidget", "SetAlwaysLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapLocationWidget.UpdateVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapLocationWidget::UpdateVisibility(class ANocePlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapLocationWidget", "UpdateVisibility");

	Params::NoceMapLocationWidget_UpdateVisibility Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDynamicMapIconWidget.LoadTexture
// (Native, Event, Protected, BlueprintEvent)

void UNoceDynamicMapIconWidget::LoadTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDynamicMapIconWidget", "LoadTexture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceDynamicMapIconWidget.UpdateVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ForceUpdate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceDynamicMapIconWidget::UpdateVisibility(bool ForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceDynamicMapIconWidget", "UpdateVisibility");

	Params::NoceDynamicMapIconWidget_UpdateVisibility Parms{};

	Parms.ForceUpdate = ForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.CanPlayerLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLockOnTargetComponent::CanPlayerLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "CanPlayerLockOnTarget");

	Params::NoceLockOnTargetComponent_CanPlayerLockOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockOnTargetComponent.GetCanLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLockOnTargetComponent::GetCanLockOnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "GetCanLockOnTarget");

	Params::NoceLockOnTargetComponent_GetCanLockOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockOnTargetComponent.GetLockOnTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceLockOnTargetComponent::GetLockOnTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "GetLockOnTargetActor");

	Params::NoceLockOnTargetComponent_GetLockOnTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockOnTargetComponent.HandleInputAction
// (Final, Native, Protected)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::HandleInputAction(ENoceInputAction InInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "HandleInputAction");

	Params::NoceLockOnTargetComponent_HandleInputAction Parms{};

	Parms.InInputAction = InInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.HandleInputAxis
// (Final, Native, Protected)
// Parameters:
// ENoceInputAxis                          InInputAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::HandleInputAxis(ENoceInputAxis InInputAxis, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "HandleInputAxis");

	Params::NoceLockOnTargetComponent_HandleInputAxis Parms{};

	Parms.InInputAxis = InInputAxis;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "HandleOnPossessed");

	Params::NoceLockOnTargetComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.IsLockingOnTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLockOnTargetComponent::IsLockingOnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "IsLockingOnTarget");

	Params::NoceLockOnTargetComponent_IsLockingOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockOnTargetComponent.OnDelayFadeOutTimerUp
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::OnDelayFadeOutTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnDelayFadeOutTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnEndLockOn
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::OnEndLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnEndLockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerDie
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::OnPlayerDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerEndLinked
// (Final, Native, Protected)
// Parameters:
// class ULinkRequest*                     LinkRequest                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::OnPlayerEndLinked(class ULinkRequest* LinkRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerEndLinked");

	Params::NoceLockOnTargetComponent_OnPlayerEndLinked Parms{};

	Parms.LinkRequest = LinkRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerEnterEvent
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::OnPlayerEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerFSMInteractTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::OnPlayerFSMInteractTagChanged(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerFSMInteractTagChanged");

	Params::NoceLockOnTargetComponent_OnPlayerFSMInteractTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerStartLinked
// (Final, Native, Protected)
// Parameters:
// class ULinkRequest*                     LinkRequest                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::OnPlayerStartLinked(class ULinkRequest* LinkRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerStartLinked");

	Params::NoceLockOnTargetComponent_OnPlayerStartLinked Parms{};

	Parms.LinkRequest = LinkRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnPlayerUsingGimmick
// (Final, Native, Protected)
// Parameters:
// bool                                    IsUsing                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::OnPlayerUsingGimmick(bool IsUsing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnPlayerUsingGimmick");

	Params::NoceLockOnTargetComponent_OnPlayerUsingGimmick Parms{};

	Parms.IsUsing = IsUsing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnStartLockOn
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::OnStartLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnStartLockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.OnTargetChangeDelegate
// (Final, Native, Protected)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATPCChangeTargetReason                 ChangeTargetReason                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::OnTargetChangeDelegate(class AActor* NewTarget, EATPCChangeTargetReason ChangeTargetReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "OnTargetChangeDelegate");

	Params::NoceLockOnTargetComponent_OnTargetChangeDelegate Parms{};

	Parms.NewTarget = NewTarget;
	Parms.ChangeTargetReason = ChangeTargetReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.RegisterOnPossessed
// (Final, Native, Protected)

void UNoceLockOnTargetComponent::RegisterOnPossessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "RegisterOnPossessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.SetCanLockOnTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::SetCanLockOnTarget(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "SetCanLockOnTarget");

	Params::NoceLockOnTargetComponent_SetCanLockOnTarget Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.UnlockCurrentLockTarget
// (Final, Native, Public, BlueprintCallable)

void UNoceLockOnTargetComponent::UnlockCurrentLockTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "UnlockCurrentLockTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockOnTargetComponent.UnlockLockTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UATPCLockOnTargetLocationComponent*InLockTarget                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockOnTargetComponent::UnlockLockTarget(class UATPCLockOnTargetLocationComponent* InLockTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockOnTargetComponent", "UnlockLockTarget");

	Params::NoceLockOnTargetComponent_UnlockLockTarget Parms{};

	Parms.InLockTarget = InLockTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFadeComponentBase.EndLightFade
// (Native, Protected, BlueprintCallable)

void UNoceFadeComponentBase::EndLightFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFadeComponentBase", "EndLightFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFadeComponentBase.InitializeLightFade
// (Final, Native, Protected, BlueprintCallable)

void UNoceFadeComponentBase::InitializeLightFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFadeComponentBase", "InitializeLightFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFadeComponentBase.RestartLightFade
// (Native, Protected, BlueprintCallable)

void UNoceFadeComponentBase::RestartLightFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFadeComponentBase", "RestartLightFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseListItemWidget.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseListItemWidget::Init(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListItemWidget", "Init");

	Params::NocePauseListItemWidget_Init Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseListItemWidget.UpdateDescription
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InDescriptionText                                      (Parm, NativeAccessSpecifierPublic)

void UNocePauseListItemWidget::UpdateDescription(const class FText& InDescriptionText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListItemWidget", "UpdateDescription");

	Params::NocePauseListItemWidget_UpdateDescription Parms{};

	Parms.InDescriptionText = std::move(InDescriptionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.ApplyGameplayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      InGameplayEffect                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::ApplyGameplayEffect(TSubclassOf<class UGameplayEffect> InGameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "ApplyGameplayEffect");

	Params::NoceEnemyAnimInstance_ApplyGameplayEffect Parms{};

	Parms.InGameplayEffect = InGameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.CancelEnterDamageState
// (Final, Native, Public, BlueprintCallable)

void UNoceEnemyAnimInstance::CancelEnterDamageState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "CancelEnterDamageState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.HandleGameplayEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::HandleGameplayEvent(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "HandleGameplayEvent");

	Params::NoceEnemyAnimInstance_HandleGameplayEvent Parms{};

	Parms.EventTag = std::move(EventTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceEnemyAnimInstance.HandleHitPoint
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InHitPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   AttackDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::HandleHitPoint(const struct FVector& InHitPoint, const struct FVector& AttackDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "HandleHitPoint");

	Params::NoceEnemyAnimInstance_HandleHitPoint Parms{};

	Parms.InHitPoint = std::move(InHitPoint);
	Parms.AttackDirection = std::move(AttackDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.IsForwardPose
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAnimInstance::IsForwardPose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "IsForwardPose");

	Params::NoceEnemyAnimInstance_IsForwardPose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAnimInstance.OnAnimFakeDead_BP
// (Event, Protected, BlueprintEvent)

void UNoceEnemyAnimInstance::OnAnimFakeDead_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnAnimFakeDead_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyAnimInstance.OnAnimResurrectBegin_BP
// (Event, Protected, BlueprintEvent)

void UNoceEnemyAnimInstance::OnAnimResurrectBegin_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnAnimResurrectBegin_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyAnimInstance.OnAnimResurrectExit
// (Final, Native, Protected)

void UNoceEnemyAnimInstance::OnAnimResurrectExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnAnimResurrectExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.OnAnimResurrectExit_BP
// (Event, Protected, BlueprintEvent)

void UNoceEnemyAnimInstance::OnAnimResurrectExit_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnAnimResurrectExit_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDamageCheckAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWinceType                          InWinceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDamageCheckAngle(ENoceWinceType InWinceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDamageCheckAngle");

	Params::NoceEnemyAnimInstance_OnDamageCheckAngle Parms{};

	Parms.InWinceType = InWinceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.OnDamageStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDamageStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDamageStateEntry");

	Params::NoceEnemyAnimInstance_OnDamageStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDamageStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDamageStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDamageStateExit");

	Params::NoceEnemyAnimInstance_OnDamageStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDeadStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDeadStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDeadStateEntry");

	Params::NoceEnemyAnimInstance_OnDeadStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDeadStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDeadStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDeadStateExit");

	Params::NoceEnemyAnimInstance_OnDeadStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDie_BP
// (Event, Protected, BlueprintEvent)

void UNoceEnemyAnimInstance::OnDie_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDie_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDownStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDownStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDownStateEntry");

	Params::NoceEnemyAnimInstance_OnDownStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnDownStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnDownStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnDownStateExit");

	Params::NoceEnemyAnimInstance_OnDownStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnIdleStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnIdleStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnIdleStateEntry");

	Params::NoceEnemyAnimInstance_OnIdleStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnIdleStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnIdleStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnIdleStateExit");

	Params::NoceEnemyAnimInstance_OnIdleStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnLinkStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnLinkStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnLinkStateEntry");

	Params::NoceEnemyAnimInstance_OnLinkStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnLinkStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnLinkStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnLinkStateExit");

	Params::NoceEnemyAnimInstance_OnLinkStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnResurrectStateEntry
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnResurrectStateEntry(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnResurrectStateEntry");

	Params::NoceEnemyAnimInstance_OnResurrectStateEntry Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.OnResurrectStateExit
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimUpdateContext&              Content                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAnimNodeReference&              Node                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::OnResurrectStateExit(struct FAnimUpdateContext& Content, struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "OnResurrectStateExit");

	Params::NoceEnemyAnimInstance_OnResurrectStateExit Parms{};

	Parms.Content = std::move(Content);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Content = std::move(Parms.Content);
	Node = std::move(Parms.Node);
}


// Function GameNoce.NoceEnemyAnimInstance.ReceiveDeathEvent
// (Final, Native, Protected)

void UNoceEnemyAnimInstance::ReceiveDeathEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "ReceiveDeathEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.ReceiveFakeDeadEvent
// (Final, Native, Protected)

void UNoceEnemyAnimInstance::ReceiveFakeDeadEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "ReceiveFakeDeadEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.ReceiveResurrectionEvent
// (Final, Native, Protected)

void UNoceEnemyAnimInstance::ReceiveResurrectionEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "ReceiveResurrectionEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.RemoveGameplayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      InGameplayEffect                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::RemoveGameplayEffect(TSubclassOf<class UGameplayEffect> InGameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "RemoveGameplayEffect");

	Params::NoceEnemyAnimInstance_RemoveGameplayEffect Parms{};

	Parms.InGameplayEffect = InGameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.SetCanEnterDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::SetCanEnterDown(bool InEnable, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "SetCanEnterDown");

	Params::NoceEnemyAnimInstance_SetCanEnterDown Parms{};

	Parms.InEnable = InEnable;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.SetEnterDamageState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWinceType                          WinceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::SetEnterDamageState(ENoceWinceType WinceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "SetEnterDamageState");

	Params::NoceEnemyAnimInstance_SetEnterDamageState Parms{};

	Parms.WinceType = WinceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.UpdateFullBodyIk
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAnimInstance::UpdateFullBodyIk(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "UpdateFullBodyIk");

	Params::NoceEnemyAnimInstance_UpdateFullBodyIk Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAnimInstance.UpdateIsFaceUpFlag
// (Final, Native, Public, BlueprintCallable)

void UNoceEnemyAnimInstance::UpdateIsFaceUpFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAnimInstance", "UpdateIsFaceUpFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeHealthDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeHealthDamage(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeHealthDamage");

	Params::NoceEnemyAttackInfoComponent_ComputeHealthDamage Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeHealthDamageValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloatRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeHealthDamageValue(float Damage, float FloatRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeHealthDamageValue");

	Params::NoceEnemyAttackInfoComponent_ComputeHealthDamageValue Parms{};

	Parms.Damage = Damage;
	Parms.FloatRate = FloatRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeMaxSanityDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFinalHealthDamage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeMaxSanityDamage(class FName InComboName, float InFinalHealthDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeMaxSanityDamage");

	Params::NoceEnemyAttackInfoComponent_ComputeMaxSanityDamage Parms{};

	Parms.InComboName = InComboName;
	Parms.InFinalHealthDamage = InFinalHealthDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeMaxSanityDamageValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFinalHealthDamage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSanityDamage                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloatRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeMaxSanityDamageValue(float InFinalHealthDamage, float InMaxSanityDamage, float FloatRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeMaxSanityDamageValue");

	Params::NoceEnemyAttackInfoComponent_ComputeMaxSanityDamageValue Parms{};

	Parms.InFinalHealthDamage = InFinalHealthDamage;
	Parms.InMaxSanityDamage = InMaxSanityDamage;
	Parms.FloatRate = FloatRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeStaminaDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeStaminaDamage(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeStaminaDamage");

	Params::NoceEnemyAttackInfoComponent_ComputeStaminaDamage Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeStaminaDamageValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloatRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeStaminaDamageValue(float Damage, float FloatRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeStaminaDamageValue");

	Params::NoceEnemyAttackInfoComponent_ComputeStaminaDamageValue Parms{};

	Parms.Damage = Damage;
	Parms.FloatRate = FloatRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeWinceDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeWinceDamage(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeWinceDamage");

	Params::NoceEnemyAttackInfoComponent_ComputeWinceDamage Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.ComputeWinceDamageValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloatRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::ComputeWinceDamageValue(float Damage, float FloatRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "ComputeWinceDamageValue");

	Params::NoceEnemyAttackInfoComponent_ComputeWinceDamageValue Parms{};

	Parms.Damage = Damage;
	Parms.FloatRate = FloatRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetAttackInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ComboName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  HealthDamage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  WinceDamage                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  MaxSanityDamage                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  StaminaDamage                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsForceWince                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType*                         WinceType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceDeathType*                         DeathType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>*     DebuffEffect                                           (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAttackInfoComponent::GetAttackInfo(class FName ComboName, float* HealthDamage, float* WinceDamage, float* MaxSanityDamage, float* StaminaDamage, bool* IsForceWince, ENoceWinceType* WinceType, ENoceDeathType* DeathType, TSubclassOf<class UGameplayEffect>* DebuffEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetAttackInfo");

	Params::NoceEnemyAttackInfoComponent_GetAttackInfo Parms{};

	Parms.ComboName = ComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HealthDamage != nullptr)
		*HealthDamage = Parms.HealthDamage;

	if (WinceDamage != nullptr)
		*WinceDamage = Parms.WinceDamage;

	if (MaxSanityDamage != nullptr)
		*MaxSanityDamage = Parms.MaxSanityDamage;

	if (StaminaDamage != nullptr)
		*StaminaDamage = Parms.StaminaDamage;

	if (IsForceWince != nullptr)
		*IsForceWince = Parms.IsForceWince;

	if (WinceType != nullptr)
		*WinceType = Parms.WinceType;

	if (DeathType != nullptr)
		*DeathType = Parms.DeathType;

	if (DebuffEffect != nullptr)
		*DebuffEffect = Parms.DebuffEffect;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetCanBeAxeDefensed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetCanBeAxeDefensed(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetCanBeAxeDefensed");

	Params::NoceEnemyAttackInfoComponent_GetCanBeAxeDefensed Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetCanBeKatanaDefensed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetCanBeKatanaDefensed(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetCanBeKatanaDefensed");

	Params::NoceEnemyAttackInfoComponent_GetCanBeKatanaDefensed Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetCheckJustDodgeCounterDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetCheckJustDodgeCounterDistance(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetCheckJustDodgeCounterDistance");

	Params::NoceEnemyAttackInfoComponent_GetCheckJustDodgeCounterDistance Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetComboCheckInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckJustDodge                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckInvincible                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutCheckOmamoriKagami                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyAttackInfoComponent::GetComboCheckInfo(class FName InComboName, bool* OutCheckJustDodge, bool* OutCheckInvincible, bool* OutCheckOmamoriKagami)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetComboCheckInfo");

	Params::NoceEnemyAttackInfoComponent_GetComboCheckInfo Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCheckJustDodge != nullptr)
		*OutCheckJustDodge = Parms.OutCheckJustDodge;

	if (OutCheckInvincible != nullptr)
		*OutCheckInvincible = Parms.OutCheckInvincible;

	if (OutCheckOmamoriKagami != nullptr)
		*OutCheckOmamoriKagami = Parms.OutCheckOmamoriKagami;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetDeathType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceDeathType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceDeathType UNoceEnemyAttackInfoComponent::GetDeathType(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetDeathType");

	Params::NoceEnemyAttackInfoComponent_GetDeathType Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetDebuffEffectData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayEffect> UNoceEnemyAttackInfoComponent::GetDebuffEffectData(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetDebuffEffectData");

	Params::NoceEnemyAttackInfoComponent_GetDebuffEffectData Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetIsChannelingAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetIsChannelingAttack(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetIsChannelingAttack");

	Params::NoceEnemyAttackInfoComponent_GetIsChannelingAttack Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetIsForceWince
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetIsForceWince(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetIsForceWince");

	Params::NoceEnemyAttackInfoComponent_GetIsForceWince Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetMaxSanityDamageToHealthDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyAttackInfoComponent::GetMaxSanityDamageToHealthDamageRatio(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetMaxSanityDamageToHealthDamageRatio");

	Params::NoceEnemyAttackInfoComponent_GetMaxSanityDamageToHealthDamageRatio Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetNeedCheckSuperArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnemyAttackInfoComponent::GetNeedCheckSuperArmor(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetNeedCheckSuperArmor");

	Params::NoceEnemyAttackInfoComponent_GetNeedCheckSuperArmor Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyAttackInfoComponent.GetWinceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWinceType UNoceEnemyAttackInfoComponent::GetWinceType(class FName InComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyAttackInfoComponent", "GetWinceType");

	Params::NoceEnemyAttackInfoComponent_GetWinceType Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.AddDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::AddDurability(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "AddDurability");

	Params::NoceWeapon_AddDurability Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.ApplyCurrentEffects
// (Final, Native, Public, BlueprintCallable)

void ANoceWeapon::ApplyCurrentEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "ApplyCurrentEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.CostDurability
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InLimitDurability                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutForceDeflect                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::CostDurability(float InValue, bool InIsAdd, bool InLimitDurability, bool* OutForceDeflect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "CostDurability");

	Params::NoceWeapon_CostDurability Parms{};

	Parms.InValue = InValue;
	Parms.InIsAdd = InIsAdd;
	Parms.InLimitDurability = InLimitDurability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutForceDeflect != nullptr)
		*OutForceDeflect = Parms.OutForceDeflect;
}


// Function GameNoce.NoceWeapon.CostDurabilityByDefesne
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InLimitDurability                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::CostDurabilityByDefesne(float InValue, bool InLimitDurability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "CostDurabilityByDefesne");

	Params::NoceWeapon_CostDurabilityByDefesne Parms{};

	Parms.InValue = InValue;
	Parms.InLimitDurability = InLimitDurability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.Equip
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InCurrentDurability                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InWeaponMeshForceSetVisibility                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InWeaponMeshForceShow                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::Equip(float InCurrentDurability, bool InWeaponMeshForceSetVisibility, bool InWeaponMeshForceShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "Equip");

	Params::NoceWeapon_Equip Parms{};

	Parms.InCurrentDurability = InCurrentDurability;
	Parms.InWeaponMeshForceSetVisibility = InWeaponMeshForceSetVisibility;
	Parms.InWeaponMeshForceShow = InWeaponMeshForceShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.Equip_BP
// (Native, Event, Public, BlueprintEvent)

void ANoceWeapon::Equip_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "Equip_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.ForceDeflectPostCostDurablity_BP
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::ForceDeflectPostCostDurablity_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "ForceDeflectPostCostDurablity_BP");

	Params::NoceWeapon_ForceDeflectPostCostDurablity_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetActionLevelDurabilityCostRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetActionLevelDurabilityCostRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetActionLevelDurabilityCostRatio");

	Params::NoceWeapon_GetActionLevelDurabilityCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetAttackInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   InWeaponDurability                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  AttackMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  ExtraAttackMultiplier                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  WinceMultiplier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::GetAttackInfo(float InWeaponDurability, float* AttackMultiplier, float* ExtraAttackMultiplier, float* WinceMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetAttackInfo");

	Params::NoceWeapon_GetAttackInfo Parms{};

	Parms.InWeaponDurability = InWeaponDurability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AttackMultiplier != nullptr)
		*AttackMultiplier = Parms.AttackMultiplier;

	if (ExtraAttackMultiplier != nullptr)
		*ExtraAttackMultiplier = Parms.ExtraAttackMultiplier;

	if (WinceMultiplier != nullptr)
		*WinceMultiplier = Parms.WinceMultiplier;
}


// Function GameNoce.NoceWeapon.GetCanBeBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetCanBeBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetCanBeBroken");

	Params::NoceWeapon_GetCanBeBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetCanCostDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetCanCostDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetCanCostDurability");

	Params::NoceWeapon_GetCanCostDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetCanDiscard
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetCanDiscard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetCanDiscard");

	Params::NoceWeapon_GetCanDiscard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetCanFocusAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetCanFocusAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetCanFocusAttack");

	Params::NoceWeapon_GetCanFocusAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetDefenseCostRatio
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetDefenseCostRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetDefenseCostRatio");

	Params::NoceWeapon_GetDefenseCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetDeflectRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetDeflectRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetDeflectRate");

	Params::NoceWeapon_GetDeflectRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetDurabilityRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetDurabilityRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetDurabilityRatio");

	Params::NoceWeapon_GetDurabilityRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetEasyModeCostRatio
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetEasyModeCostRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetEasyModeCostRatio");

	Params::NoceWeapon_GetEasyModeCostRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetIsDiscarded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetIsDiscarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetIsDiscarded");

	Params::NoceWeapon_GetIsDiscarded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ANoceWeapon::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetMesh");

	Params::NoceWeapon_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetOverrideComboInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceWeaponInfoOverride*         OutComboInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ANoceWeapon::GetOverrideComboInfo(class FName InComboName, bool* OutFound, struct FNoceWeaponInfoOverride* OutComboInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetOverrideComboInfo");

	Params::NoceWeapon_GetOverrideComboInfo Parms{};

	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = Parms.OutFound;

	if (OutComboInfo != nullptr)
		*OutComboInfo = std::move(Parms.OutComboInfo);
}


// Function GameNoce.NoceWeapon.GetOverrideStaminaKeyCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InStaminaKey                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutStaminaCost                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::GetOverrideStaminaKeyCost(class FName InStaminaKey, bool* OutFound, float* OutStaminaCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetOverrideStaminaKeyCost");

	Params::NoceWeapon_GetOverrideStaminaKeyCost Parms{};

	Parms.InStaminaKey = InStaminaKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = Parms.OutFound;

	if (OutStaminaCost != nullptr)
		*OutStaminaCost = Parms.OutStaminaCost;
}


// Function GameNoce.NoceWeapon.GetUseFocusAttackWhenFullCharged
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::GetUseFocusAttackWhenFullCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetUseFocusAttackWhenFullCharged");

	Params::NoceWeapon_GetUseFocusAttackWhenFullCharged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetWeaponMotionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWeaponMotionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWeaponMotionType ANoceWeapon::GetWeaponMotionType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetWeaponMotionType");

	Params::NoceWeapon_GetWeaponMotionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetWeaponType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWeaponType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWeaponType ANoceWeapon::GetWeaponType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetWeaponType");

	Params::NoceWeapon_GetWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.HandleClawTransform_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InTransformToClawG                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::HandleClawTransform_BP(bool InTransformToClawG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "HandleClawTransform_BP");

	Params::NoceWeapon_HandleClawTransform_BP Parms{};

	Parms.InTransformToClawG = InTransformToClawG;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceWeapon.HideWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::HideWeapon(class FName InWeaponName, bool InHide, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "HideWeapon");

	Params::NoceWeapon_HideWeapon Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InHide = InHide;
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.IsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::IsBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "IsBroken");

	Params::NoceWeapon_IsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.IsInLowDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::IsInLowDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "IsInLowDurability");

	Params::NoceWeapon_IsInLowDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.RemoveCurrentEffects
// (Final, Native, Public, BlueprintCallable)

void ANoceWeapon::RemoveCurrentEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "RemoveCurrentEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetCounterComboName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCounterComboName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetCounterComboName(class FName InCounterComboName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetCounterComboName");

	Params::NoceWeapon_SetCounterComboName Parms{};

	Parms.InCounterComboName = InCounterComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetDurability(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetDurability");

	Params::NoceWeapon_SetDurability Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetIsDiscarded
// (Final, Native, Public, BlueprintCallable)

void ANoceWeapon::SetIsDiscarded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetIsDiscarded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetWeaponAudioType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetWeaponAudioType(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetWeaponAudioType");

	Params::NoceWeapon_SetWeaponAudioType Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetWeaponMotionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWeaponMotionType                   InWeaponMotionType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetWeaponMotionType(ENoceWeaponMotionType InWeaponMotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetWeaponMotionType");

	Params::NoceWeapon_SetWeaponMotionType Parms{};

	Parms.InWeaponMotionType = InWeaponMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetWeaponName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetWeaponName(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetWeaponName");

	Params::NoceWeapon_SetWeaponName Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.SetWeaponType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWeaponType                         InWeaponType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWeapon::SetWeaponType(ENoceWeaponType InWeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "SetWeaponType");

	Params::NoceWeapon_SetWeaponType Parms{};

	Parms.InWeaponType = InWeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.Unequip
// (Native, Public, BlueprintCallable)

void ANoceWeapon::Unequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "Unequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.UnEquip_BP
// (Native, Event, Public, BlueprintEvent)

void ANoceWeapon::UnEquip_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "UnEquip_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeapon.GetDurability
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetDurability");

	Params::NoceWeapon_GetDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.GetMaxDurability
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceWeapon::GetMaxDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "GetMaxDurability");

	Params::NoceWeapon_GetMaxDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeapon.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceWeapon::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeapon", "IsVisible");

	Params::NoceWeapon_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.AddFakeDeadProgressTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::AddFakeDeadProgressTime(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "AddFakeDeadProgressTime");

	Params::NoceEnemyCharacter_AddFakeDeadProgressTime Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.CanBeLockedOnTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CanBeLockedOnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CanBeLockedOnTarget");

	Params::NoceEnemyCharacter_CanBeLockedOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.CanFakeDead
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CanFakeDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CanFakeDead");

	Params::NoceEnemyCharacter_CanFakeDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.CanSeePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InDebugDraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         InDrawDebugTrace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CanSeePlayer(bool InDebugDraw, EDrawDebugTrace InDrawDebugTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CanSeePlayer");

	Params::NoceEnemyCharacter_CanSeePlayer Parms{};

	Parms.InDebugDraw = InDebugDraw;
	Parms.InDrawDebugTrace = InDrawDebugTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.CheckAlive
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CheckAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CheckAlive");

	Params::NoceEnemyCharacter_CheckAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.CheckIsInBrightRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CheckIsInBrightRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CheckIsInBrightRoom");

	Params::NoceEnemyCharacter_CheckIsInBrightRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.CheckMayNotReviveRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::CheckMayNotReviveRule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "CheckMayNotReviveRule");

	Params::NoceEnemyCharacter_CheckMayNotReviveRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.Die_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::Die_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "Die_BP");

	Params::NoceEnemyCharacter_Die_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.EndFakeDead
// (Final, Native, Protected, BlueprintCallable)

void ANoceEnemyCharacter::EndFakeDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "EndFakeDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.EndResurrect
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::EndResurrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "EndResurrect");

	Params::NoceEnemyCharacter_EndResurrect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.EnterBrightRoom
// (Final, Native, Public, BlueprintCallable)

void ANoceEnemyCharacter::EnterBrightRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "EnterBrightRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.ExitBrightRoom
// (Final, Native, Public, BlueprintCallable)

void ANoceEnemyCharacter::ExitBrightRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "ExitBrightRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.FakeDeadToDie
// (Final, Native, Protected, BlueprintCallable)

void ANoceEnemyCharacter::FakeDeadToDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "FakeDeadToDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.GetAIAlertType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceAIAlertType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceAIAlertType ANoceEnemyCharacter::GetAIAlertType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetAIAlertType");

	Params::NoceEnemyCharacter_GetAIAlertType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetBattlePositionScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceBattlePositionTier                 InTier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceEnemyCharacter::GetBattlePositionScore(ENoceBattlePositionTier InTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetBattlePositionScore");

	Params::NoceEnemyCharacter_GetBattlePositionScore Parms{};

	Parms.InTier = InTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetCanAcceptAttrackSoul
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetCanAcceptAttrackSoul()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetCanAcceptAttrackSoul");

	Params::NoceEnemyCharacter_GetCanAcceptAttrackSoul Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetCanBePushedByPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetCanBePushedByPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetCanBePushedByPlayer");

	Params::NoceEnemyCharacter_GetCanBePushedByPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetCanPlayerSlideByDodgePush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetCanPlayerSlideByDodgePush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetCanPlayerSlideByDodgePush");

	Params::NoceEnemyCharacter_GetCanPlayerSlideByDodgePush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetCanPushPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetCanPushPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetCanPushPlayer");

	Params::NoceEnemyCharacter_GetCanPushPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetCanTakeDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetCanTakeDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetCanTakeDamage");

	Params::NoceEnemyCharacter_GetCanTakeDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetExtendAutoAimDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetExtendAutoAimDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetExtendAutoAimDistance");

	Params::NoceEnemyCharacter_GetExtendAutoAimDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetFakeDeadCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceEnemyCharacter::GetFakeDeadCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetFakeDeadCount");

	Params::NoceEnemyCharacter_GetFakeDeadCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetFakeDeadProgressTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetFakeDeadProgressTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetFakeDeadProgressTime");

	Params::NoceEnemyCharacter_GetFakeDeadProgressTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetFakeDeadRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetFakeDeadRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetFakeDeadRemainingTime");

	Params::NoceEnemyCharacter_GetFakeDeadRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetIsNonCounterableWhenInactive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::GetIsNonCounterableWhenInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetIsNonCounterableWhenInactive");

	Params::NoceEnemyCharacter_GetIsNonCounterableWhenInactive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetPossiblePositionOnLoad
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceEnemyCharacter::GetPossiblePositionOnLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetPossiblePositionOnLoad");

	Params::NoceEnemyCharacter_GetPossiblePositionOnLoad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.HasBattlePositionScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::HasBattlePositionScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "HasBattlePositionScore");

	Params::NoceEnemyCharacter_HasBattlePositionScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.HasFakeDeadAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::HasFakeDeadAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "HasFakeDeadAbility");

	Params::NoceEnemyCharacter_HasFakeDeadAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.InstantRevival
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::InstantRevival()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "InstantRevival");

	Params::NoceEnemyCharacter_InstantRevival Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsBreakDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsBreakDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsBreakDown");

	Params::NoceEnemyCharacter_IsBreakDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsCounterable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCounterHint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsCounterable(bool InCounterHint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsCounterable");

	Params::NoceEnemyCharacter_IsCounterable Parms{};

	Parms.InCounterHint = InCounterHint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsEngagedStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsEngagedStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsEngagedStatus");

	Params::NoceEnemyCharacter_IsEngagedStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsLockedTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsLockedTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsLockedTarget");

	Params::NoceEnemyCharacter_IsLockedTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsNoCostPlayerWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsNoCostPlayerWeaponDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsNoCostPlayerWeaponDurability");

	Params::NoceEnemyCharacter_IsNoCostPlayerWeaponDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsSpawnFromFreak
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsSpawnFromFreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsSpawnFromFreak");

	Params::NoceEnemyCharacter_IsSpawnFromFreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsVisibileToPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InDebugDraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCapsuleRadiusRatio                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBackSideDiffDistance                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InOnlyCheckCenter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         InDrawDebugTrace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsVisibileToPlayer(bool InDebugDraw, float InCapsuleRadiusRatio, float InBackSideDiffDistance, bool InOnlyCheckCenter, EDrawDebugTrace InDrawDebugTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsVisibileToPlayer");

	Params::NoceEnemyCharacter_IsVisibileToPlayer Parms{};

	Parms.InDebugDraw = InDebugDraw;
	Parms.InCapsuleRadiusRatio = InCapsuleRadiusRatio;
	Parms.InBackSideDiffDistance = InBackSideDiffDistance;
	Parms.InOnlyCheckCenter = InOnlyCheckCenter;
	Parms.InDrawDebugTrace = InDrawDebugTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsVisibleForEnemyInSight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsVisibleForEnemyInSight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsVisibleForEnemyInSight");

	Params::NoceEnemyCharacter_IsVisibleForEnemyInSight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.Kill
// (Native, Public, BlueprintCallable)

void ANoceEnemyCharacter::Kill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "Kill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.NoFightingStrength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::NoFightingStrength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "NoFightingStrength");

	Params::NoceEnemyCharacter_NoFightingStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.OnDamaged_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FNoceAttackHitResult&      AttackHitResult                                        (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::OnDamaged_BP(const struct FNoceAttackHitResult& AttackHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "OnDamaged_BP");

	Params::NoceEnemyCharacter_OnDamaged_BP Parms{};

	Parms.AttackHitResult = std::move(AttackHitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.OnFinishEvent_BP
// (Event, Protected, BlueprintEvent)

void ANoceEnemyCharacter::OnFinishEvent_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "OnFinishEvent_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyCharacter.OnStartEvent_BP
// (Event, Protected, BlueprintEvent)

void ANoceEnemyCharacter::OnStartEvent_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "OnStartEvent_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceEnemyCharacter.RequestFakeDead
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ResetAI                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::RequestFakeDead(bool FromLoad, bool ResetAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "RequestFakeDead");

	Params::NoceEnemyCharacter_RequestFakeDead Parms{};

	Parms.FromLoad = FromLoad;
	Parms.ResetAI = ResetAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.ResetMovementState
// (Final, Native, Public, BlueprintCallable)

void ANoceEnemyCharacter::ResetMovementState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "ResetMovementState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SendGameplayEventToAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SendGameplayEventToAnimation(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SendGameplayEventToAnimation");

	Params::NoceEnemyCharacter_SendGameplayEventToAnimation Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetCanAcceptAttrackSoul
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetCanAcceptAttrackSoul(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetCanAcceptAttrackSoul");

	Params::NoceEnemyCharacter_SetCanAcceptAttrackSoul Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetCanTakeDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetCanTakeDamage(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetCanTakeDamage");

	Params::NoceEnemyCharacter_SetCanTakeDamage Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetFakeDeadCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetFakeDeadCount(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetFakeDeadCount");

	Params::NoceEnemyCharacter_SetFakeDeadCount Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetIsHiddenBeforeCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetIsHiddenBeforeCutscene(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetIsHiddenBeforeCutscene");

	Params::NoceEnemyCharacter_SetIsHiddenBeforeCutscene Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetIsVisibleForEnemyInSight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetIsVisibleForEnemyInSight(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetIsVisibleForEnemyInSight");

	Params::NoceEnemyCharacter_SetIsVisibleForEnemyInSight Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetJealous
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetJealous(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetJealous");

	Params::NoceEnemyCharacter_SetJealous Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetRootMotionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetRootMotionScale(float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetRootMotionScale");

	Params::NoceEnemyCharacter_SetRootMotionScale Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.SetSpawnerFreak
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceEnemyCharacter*              FreakCharacter                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::SetSpawnerFreak(class ANoceEnemyCharacter* FreakCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "SetSpawnerFreak");

	Params::NoceEnemyCharacter_SetSpawnerFreak Parms{};

	Parms.FreakCharacter = FreakCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.ShowHideEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::ShowHideEnemy(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "ShowHideEnemy");

	Params::NoceEnemyCharacter_ShowHideEnemy Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.StartFakeDead
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyCharacter::StartFakeDead(bool FromLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "StartFakeDead");

	Params::NoceEnemyCharacter_StartFakeDead Parms{};

	Parms.FromLoad = FromLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.StartResurrect
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::StartResurrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "StartResurrect");

	Params::NoceEnemyCharacter_StartResurrect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.TryCreateRecord
// (Native, Public, BlueprintCallable)

void ANoceEnemyCharacter::TryCreateRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "TryCreateRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyCharacter.GetDamageRatioHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetDamageRatioHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetDamageRatioHealth");

	Params::NoceEnemyCharacter_GetDamageRatioHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetDamageRatioWince
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetDamageRatioWince() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetDamageRatioWince");

	Params::NoceEnemyCharacter_GetDamageRatioWince Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetFakeDeadWakeupRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetFakeDeadWakeupRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetFakeDeadWakeupRatio");

	Params::NoceEnemyCharacter_GetFakeDeadWakeupRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetHealthAttackRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetHealthAttackRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetHealthAttackRatio");

	Params::NoceEnemyCharacter_GetHealthAttackRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetJealous
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetJealous() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetJealous");

	Params::NoceEnemyCharacter_GetJealous Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.GetLinkAttackRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceEnemyCharacter::GetLinkAttackRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "GetLinkAttackRatio");

	Params::NoceEnemyCharacter_GetLinkAttackRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsDead
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsDead");

	Params::NoceEnemyCharacter_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsFakeDead
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsFakeDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsFakeDead");

	Params::NoceEnemyCharacter_IsFakeDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.IsResurrect
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::IsResurrect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "IsResurrect");

	Params::NoceEnemyCharacter_IsResurrect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyCharacter.OnCanCreateRecord
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnemyCharacter::OnCanCreateRecord() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyCharacter", "OnCanCreateRecord");

	Params::NoceEnemyCharacter_OnCanCreateRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconWidget.GetWorldPos
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceMapIconWidget::GetWorldPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconWidget", "GetWorldPos");

	Params::NoceMapIconWidget_GetWorldPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconWidget.OnFadeInCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceMapIconWidget::OnFadeInCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconWidget", "OnFadeInCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconWidget.UpdateRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InvMapYaw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconWidget::UpdateRotation(float InvMapYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconWidget", "UpdateRotation");

	Params::NoceMapIconWidget_UpdateRotation Parms{};

	Parms.InvMapYaw = InvMapYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconWidget.UpdateScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MapScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IconScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconWidget::UpdateScale(float MapScale, float IconScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconWidget", "UpdateScale");

	Params::NoceMapIconWidget_UpdateScale Parms{};

	Parms.MapScale = MapScale;
	Parms.IconScale = IconScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconWidget.UpdateVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsInView                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconWidget::UpdateVisibility(bool IsInView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconWidget", "UpdateVisibility");

	Params::NoceMapIconWidget_UpdateVisibility Parms{};

	Parms.IsInView = IsInView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyDamageHandleComponent.HandleBodyPartGroupDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBodyPartGroupName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsLimitHealth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsBreak                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsDamageToHealth                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyDamageHandleComponent::HandleBodyPartGroupDamage(class FName InBodyPartGroupName, float InHealthDamage, bool InIsLimitHealth, bool* OutIsBreak, bool* OutIsDamageToHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyDamageHandleComponent", "HandleBodyPartGroupDamage");

	Params::NoceEnemyDamageHandleComponent_HandleBodyPartGroupDamage Parms{};

	Parms.InBodyPartGroupName = InBodyPartGroupName;
	Parms.InHealthDamage = InHealthDamage;
	Parms.InIsLimitHealth = InIsLimitHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsBreak != nullptr)
		*OutIsBreak = Parms.OutIsBreak;

	if (OutIsDamageToHealth != nullptr)
		*OutIsDamageToHealth = Parms.OutIsDamageToHealth;
}


// Function GameNoce.NoceEnemyDamageHandleComponent.HandleDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWinceDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsForceWince                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAttackWinceToAdditvie                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          InWinceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsLimitHealth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsLimitWince                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWinceType UNoceEnemyDamageHandleComponent::HandleDamage(float InHealthDamage, float InWinceDamage, bool InIsForceWince, bool InAttackWinceToAdditvie, ENoceWinceType InWinceType, bool InIsLimitHealth, bool InIsLimitWince)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyDamageHandleComponent", "HandleDamage");

	Params::NoceEnemyDamageHandleComponent_HandleDamage Parms{};

	Parms.InHealthDamage = InHealthDamage;
	Parms.InWinceDamage = InWinceDamage;
	Parms.InIsForceWince = InIsForceWince;
	Parms.InAttackWinceToAdditvie = InAttackWinceToAdditvie;
	Parms.InWinceType = InWinceType;
	Parms.InIsLimitHealth = InIsLimitHealth;
	Parms.InIsLimitWince = InIsLimitWince;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyGroupSpawnComponent.GetCurrentGroupTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceActionLevel                        InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnemyGroupSpawnComponent::GetCurrentGroupTime(ENoceActionLevel InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyGroupSpawnComponent", "GetCurrentGroupTime");

	Params::NoceEnemyGroupSpawnComponent_GetCurrentGroupTime Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnemyGroupSpawnComponent.HandleUnhideSpawnedEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceEnemyCharacter*              Char                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyGroupSpawnComponent::HandleUnhideSpawnedEnemy(class ANoceEnemyCharacter* Char, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyGroupSpawnComponent", "HandleUnhideSpawnedEnemy");

	Params::NoceEnemyGroupSpawnComponent_HandleUnhideSpawnedEnemy Parms{};

	Parms.Char = Char;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyGroupSpawnComponent.OnGameProgressChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyGroupSpawnComponent::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyGroupSpawnComponent", "OnGameProgressChanged");

	Params::NoceEnemyGroupSpawnComponent_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceEnemyGroupSpawnComponent.UpdateSpawnedEnemies
// (Final, Native, Protected, BlueprintCallable)

void UNoceEnemyGroupSpawnComponent::UpdateSpawnedEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyGroupSpawnComponent", "UpdateSpawnedEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMontageStateMonitorComponent.GetMontageState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceMontageState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceMontageState UNoceMontageStateMonitorComponent::GetMontageState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMontageStateMonitorComponent", "GetMontageState");

	Params::NoceMontageStateMonitorComponent_GetMontageState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMontageStateMonitorComponent.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMontageStateMonitorComponent::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMontageStateMonitorComponent", "OnMontageBlendingOut");

	Params::NoceMontageStateMonitorComponent_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMontageStateMonitorComponent.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMontageStateMonitorComponent::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMontageStateMonitorComponent", "OnMontageEnded");

	Params::NoceMontageStateMonitorComponent_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMontageStateMonitorComponent.RecordMontageState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceMontageState                       InMontageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMontageStateMonitorComponent::RecordMontageState(class UAnimMontage* InMontage, ENoceMontageState InMontageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMontageStateMonitorComponent", "RecordMontageState");

	Params::NoceMontageStateMonitorComponent_RecordMontageState Parms{};

	Parms.InMontage = InMontage;
	Parms.InMontageState = InMontageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyGroupSpawner.OnGameProgressChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceEnemyGroupSpawner::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyGroupSpawner", "OnGameProgressChanged");

	Params::NoceEnemyGroupSpawner_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceLoadBarWidget.UpdateProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLoadBarWidget::UpdateProgress(float InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLoadBarWidget", "UpdateProgress");

	Params::NoceLoadBarWidget_UpdateProgress Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyPhysicsAssetSwapComp.ChangePhysicsAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShrink                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyPhysicsAssetSwapComp::ChangePhysicsAsset(bool InShrink)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyPhysicsAssetSwapComp", "ChangePhysicsAsset");

	Params::NoceEnemyPhysicsAssetSwapComp_ChangePhysicsAsset Parms{};

	Parms.InShrink = InShrink;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyPhysicsAssetSwapComp.InitializeDefaultAssetData
// (Final, Native, Public, BlueprintCallable)

void UNoceEnemyPhysicsAssetSwapComp::InitializeDefaultAssetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyPhysicsAssetSwapComp", "InitializeDefaultAssetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyPhysicsAssetSwapComp.OnPossessedPawnChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            InOldPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            InNewPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyPhysicsAssetSwapComp::OnPossessedPawnChanged(class APawn* InOldPawn, class APawn* InNewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyPhysicsAssetSwapComp", "OnPossessedPawnChanged");

	Params::NoceEnemyPhysicsAssetSwapComp_OnPossessedPawnChanged Parms{};

	Parms.InOldPawn = InOldPawn;
	Parms.InNewPawn = InNewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnemyPhysicsAssetSwapComp.OnUseCapsuleShrink
// (Final, Native, Protected)
// Parameters:
// bool                                    InUse                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnemyPhysicsAssetSwapComp::OnUseCapsuleShrink(bool InUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnemyPhysicsAssetSwapComp", "OnUseCapsuleShrink");

	Params::NoceEnemyPhysicsAssetSwapComp_OnUseCapsuleShrink Parms{};

	Parms.InUse = InUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanityFlowerWidget.UpdateFlowerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SmallFlowerNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSanityFlowerWidget::UpdateFlowerVisibility(int32 SmallFlowerNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanityFlowerWidget", "UpdateFlowerVisibility");

	Params::NoceSanityFlowerWidget_UpdateFlowerVisibility Parms{};

	Parms.SmallFlowerNum = SmallFlowerNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "HandleOnPossessed");

	Params::NocePlayerInputHelperComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.IsInputActionValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInputHelperComponent::IsInputActionValid(class FName InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "IsInputActionValid");

	Params::NocePlayerInputHelperComponent_IsInputActionValid Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnFocusDisableStateTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnFocusDisableStateTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnFocusDisableStateTagChanged");

	Params::NocePlayerInputHelperComponent_OnFocusDisableStateTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnFocusEnableStateTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnFocusEnableStateTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnFocusEnableStateTagChanged");

	Params::NocePlayerInputHelperComponent_OnFocusEnableStateTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnFocusPauseStateTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnFocusPauseStateTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnFocusPauseStateTagChanged");

	Params::NocePlayerInputHelperComponent_OnFocusPauseStateTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnInputModeChanged
// (Final, Native, Protected)

void UNocePlayerInputHelperComponent::OnInputModeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnInputModeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnPlayerUsingGimmick
// (Final, Native, Protected)
// Parameters:
// bool                                    InIsUsing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnPlayerUsingGimmick(bool InIsUsing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnPlayerUsingGimmick");

	Params::NocePlayerInputHelperComponent_OnPlayerUsingGimmick Parms{};

	Parms.InIsUsing = InIsUsing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnShortcutItemEnableStateTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnShortcutItemEnableStateTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnShortcutItemEnableStateTagChanged");

	Params::NocePlayerInputHelperComponent_OnShortcutItemEnableStateTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnShortcutTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnShortcutTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnShortcutTagChanged");

	Params::NocePlayerInputHelperComponent_OnShortcutTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnUISubsystemWidgetStackSizeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnUISubsystemWidgetStackSizeChanged(int32 InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnUISubsystemWidgetStackSizeChanged");

	Params::NocePlayerInputHelperComponent_OnUISubsystemWidgetStackSizeChanged Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.OnUpperBodyMotionTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInputHelperComponent::OnUpperBodyMotionTagChanged(const struct FGameplayTag& InTag, int32 InNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "OnUpperBodyMotionTagChanged");

	Params::NocePlayerInputHelperComponent_OnUpperBodyMotionTagChanged Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InNewCount = InNewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.RegisterOnPossessed
// (Final, Native, Protected)

void UNocePlayerInputHelperComponent::RegisterOnPossessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "RegisterOnPossessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInputHelperComponent.StopSprintWhenInputExtraSprintReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInputHelperComponent::StopSprintWhenInputExtraSprintReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInputHelperComponent", "StopSprintWhenInputExtraSprintReleased");

	Params::NocePlayerInputHelperComponent_StopSprintWhenInputExtraSprintReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.GetIsEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerLookAtTargetComponent::GetIsEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "GetIsEnable");

	Params::NocePlayerLookAtTargetComponent_GetIsEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.GetOnlyUseForMotionWarp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerLookAtTargetComponent::GetOnlyUseForMotionWarp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "GetOnlyUseForMotionWarp");

	Params::NocePlayerLookAtTargetComponent_GetOnlyUseForMotionWarp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.GetSkipAutoAimMeshCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerLookAtTargetComponent::GetSkipAutoAimMeshCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "GetSkipAutoAimMeshCheck");

	Params::NocePlayerLookAtTargetComponent_GetSkipAutoAimMeshCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.HandleEnemyFakeDead
// (Final, Native, Protected)

void UNocePlayerLookAtTargetComponent::HandleEnemyFakeDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "HandleEnemyFakeDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.HandleEnemyOnDie
// (Final, Native, Protected)

void UNocePlayerLookAtTargetComponent::HandleEnemyOnDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "HandleEnemyOnDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.HandleEnemyRevive
// (Final, Native, Protected)

void UNocePlayerLookAtTargetComponent::HandleEnemyRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "HandleEnemyRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.HandleEnemyShowHide
// (Final, Native, Protected)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookAtTargetComponent::HandleEnemyShowHide(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "HandleEnemyShowHide");

	Params::NocePlayerLookAtTargetComponent_HandleEnemyShowHide Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.HandleInteractEnableChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookAtTargetComponent::HandleInteractEnableChanged(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "HandleInteractEnableChanged");

	Params::NocePlayerLookAtTargetComponent_HandleInteractEnableChanged Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtTargetComponent.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookAtTargetComponent::SetEnable(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtTargetComponent", "SetEnable");

	Params::NocePlayerLookAtTargetComponent_SetEnable Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTabWidget.GetListSlots
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UUserWidget*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UUserWidget*> UNoceTabWidget::GetListSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTabWidget", "GetListSlots");

	Params::NoceTabWidget_GetListSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTabWidget.InitializeTab
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceTabWidget::InitializeTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTabWidget", "InitializeTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapTabWidget.InitTabs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FText>&              TabNames                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceMapTabWidget::InitTabs(const TArray<class FText>& TabNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapTabWidget", "InitTabs");

	Params::NoceMapTabWidget_InitTabs Parms{};

	Parms.TabNames = std::move(TabNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapTabWidget.Show
// (Final, Native, Public, BlueprintCallable)

void UNoceMapTabWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapTabWidget", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.AddHeightFogSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceExpFogSetting&        InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::AddHeightFogSetting(class FName RowName, const struct FNoceExpFogSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "AddHeightFogSetting");

	Params::NoceEnvironmentSubsystem_AddHeightFogSetting Parms{};

	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.AddSkyLightSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSkyLightSetting&      InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::AddSkyLightSetting(class FName RowName, const struct FNoceSkyLightSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "AddSkyLightSetting");

	Params::NoceEnvironmentSubsystem_AddSkyLightSetting Parms{};

	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.AddSpotLightSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::AddSpotLightSetting(class FName RowName, const struct FNoceSpotLightSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "AddSpotLightSetting");

	Params::NoceEnvironmentSubsystem_AddSpotLightSetting Parms{};

	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.AddVolumeFogSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::AddVolumeFogSetting(class FName RowName, const struct FNoceVolumetricFogSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "AddVolumeFogSetting");

	Params::NoceEnvironmentSubsystem_AddVolumeFogSetting Parms{};

	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.ClearAllOnewayLightControl
// (Final, Native, Public, BlueprintCallable)

void UNoceEnvironmentSubsystem::ClearAllOnewayLightControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "ClearAllOnewayLightControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.DebugRequestDarkness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDarknessSetting&      InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::DebugRequestDarkness(bool Enable, class FName InRowName, const struct FNoceDarknessSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "DebugRequestDarkness");

	Params::NoceEnvironmentSubsystem_DebugRequestDarkness Parms{};

	Parms.Enable = Enable;
	Parms.InRowName = InRowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.DebugRequestHeightFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceExpFogSetting&        InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::DebugRequestHeightFog(bool Enable, class FName RowName, const struct FNoceExpFogSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "DebugRequestHeightFog");

	Params::NoceEnvironmentSubsystem_DebugRequestHeightFog Parms{};

	Parms.Enable = Enable;
	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.DebugRequestVolumeFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& InData                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::DebugRequestVolumeFog(bool Enable, class FName RowName, const struct FNoceVolumetricFogSetting& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "DebugRequestVolumeFog");

	Params::NoceEnvironmentSubsystem_DebugRequestVolumeFog Parms{};

	Parms.Enable = Enable;
	Parms.RowName = RowName;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.EnableLanternBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::EnableLanternBlending(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "EnableLanternBlending");

	Params::NoceEnvironmentSubsystem_EnableLanternBlending Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.EnableLanternLightUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::EnableLanternLightUpdate(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "EnableLanternLightUpdate");

	Params::NoceEnvironmentSubsystem_EnableLanternLightUpdate Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.ForceUpdateHandlersWithTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    NeedOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InTargetLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::ForceUpdateHandlersWithTargetLocation(bool NeedOverride, const struct FVector& InTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "ForceUpdateHandlersWithTargetLocation");

	Params::NoceEnvironmentSubsystem_ForceUpdateHandlersWithTargetLocation Parms{};

	Parms.NeedOverride = NeedOverride;
	Parms.InTargetLocation = std::move(InTargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetDirectionalLightRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceEnvironmentSubsystem::GetDirectionalLightRowName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetDirectionalLightRowName");

	Params::NoceEnvironmentSubsystem_GetDirectionalLightRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetHeightFogEnemyInSightDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnvironmentSubsystem::GetHeightFogEnemyInSightDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetHeightFogEnemyInSightDistance");

	Params::NoceEnvironmentSubsystem_GetHeightFogEnemyInSightDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetHeightFogFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnvironmentSubsystem::GetHeightFogFadeDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetHeightFogFadeDistance");

	Params::NoceEnvironmentSubsystem_GetHeightFogFadeDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetHeightFogRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceEnvironmentSubsystem::GetHeightFogRowName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetHeightFogRowName");

	Params::NoceEnvironmentSubsystem_GetHeightFogRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetOnewayLightControlAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceEnvironmentSubsystem::GetOnewayLightControlAlpha(const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetOnewayLightControlAlpha");

	Params::NoceEnvironmentSubsystem_GetOnewayLightControlAlpha Parms{};

	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetSkyLightRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceEnvironmentSubsystem::GetSkyLightRowName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetSkyLightRowName");

	Params::NoceEnvironmentSubsystem_GetSkyLightRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetSSFSRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceEnvironmentSubsystem::GetSSFSRowName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetSSFSRowName");

	Params::NoceEnvironmentSubsystem_GetSSFSRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetVolumetricFogRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceEnvironmentSubsystem::GetVolumetricFogRowName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetVolumetricFogRowName");

	Params::NoceEnvironmentSubsystem_GetVolumetricFogRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.GetWindAudioLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceEnvironmentSubsystem::GetWindAudioLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "GetWindAudioLevel");

	Params::NoceEnvironmentSubsystem_GetWindAudioLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.HasAnyLanternSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnvironmentSubsystem::HasAnyLanternSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "HasAnyLanternSetting");

	Params::NoceEnvironmentSubsystem_HasAnyLanternSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.HasOnewayLightControlSaved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnvironmentSubsystem::HasOnewayLightControlSaved(const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "HasOnewayLightControlSaved");

	Params::NoceEnvironmentSubsystem_HasOnewayLightControlSaved Parms{};

	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.OnDarknessUpdateEvent
// (Final, Native, Public, HasDefaults)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InDarknessColor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InEdgeContrast                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InEffectOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::OnDarknessUpdateEvent(float InAlpha, const struct FLinearColor& InDarknessColor, float InEdgeContrast, float InEffectOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "OnDarknessUpdateEvent");

	Params::NoceEnvironmentSubsystem_OnDarknessUpdateEvent Parms{};

	Parms.InAlpha = InAlpha;
	Parms.InDarknessColor = std::move(InDarknessColor);
	Parms.InEdgeContrast = InEdgeContrast;
	Parms.InEffectOffset = InEffectOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.OnHeightFogUpdateEvent
// (Final, Native, Public)

void UNoceEnvironmentSubsystem::OnHeightFogUpdateEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "OnHeightFogUpdateEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.OnResumeFromSequence
// (Final, Native, Public, BlueprintCallable)

void UNoceEnvironmentSubsystem::OnResumeFromSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "OnResumeFromSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.OnSpecialEnvironmentAdjustChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SourceName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CompStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendWeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APostProcessVolume*               InPPV                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::OnSpecialEnvironmentAdjustChanged(const class FString& SourceName, const class FString& CompStr, float InPriority, float InBlendWeight, class APostProcessVolume* InPPV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "OnSpecialEnvironmentAdjustChanged");

	Params::NoceEnvironmentSubsystem_OnSpecialEnvironmentAdjustChanged Parms{};

	Parms.SourceName = std::move(SourceName);
	Parms.CompStr = std::move(CompStr);
	Parms.InPriority = InPriority;
	Parms.InBlendWeight = InBlendWeight;
	Parms.InPPV = InPPV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.OnWindUpdateEvent
// (Final, Native, Public)
// Parameters:
// float                                   InWindSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAudioLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::OnWindUpdateEvent(float InWindSpeed, int32 InAudioLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "OnWindUpdateEvent");

	Params::NoceEnvironmentSubsystem_OnWindUpdateEvent Parms{};

	Parms.InWindSpeed = InWindSpeed;
	Parms.InAudioLevel = InAudioLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterDarknessMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMPC                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterDarknessMaterial(class UMaterialParameterCollection* InMPC, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterDarknessMaterial");

	Params::NoceEnvironmentSubsystem_RegisterDarknessMaterial Parms{};

	Parms.InMPC = InMPC;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterDirectionalLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDirectionalLightComponent*       InDL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterDirectionalLight(class UDirectionalLightComponent* InDL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterDirectionalLight");

	Params::NoceEnvironmentSubsystem_RegisterDirectionalLight Parms{};

	Parms.InDL = InDL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterEmissiveFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMI                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceLightFadeFullSetting& InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    InUseCPD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InEmissiveCPDIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceEnvironmentSubsystem::RegisterEmissiveFade(class UMaterialInstanceDynamic* InMI, class AActor* InActor, const struct FNoceLightFadeFullSetting& InParam, bool InUseCPD, int32 InEmissiveCPDIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterEmissiveFade");

	Params::NoceEnvironmentSubsystem_RegisterEmissiveFade Parms{};

	Parms.InMI = InMI;
	Parms.InActor = InActor;
	Parms.InParam = std::move(InParam);
	Parms.InUseCPD = InUseCPD;
	Parms.InEmissiveCPDIndex = InEmissiveCPDIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterLanternLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointLightComponent*             InPL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceLanternLightType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterLanternLight(class UPointLightComponent* InPL, ENoceLanternLightType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterLanternLight");

	Params::NoceEnvironmentSubsystem_RegisterLanternLight Parms{};

	Parms.InPL = InPL;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterLanternNiagara
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNC                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterLanternNiagara(class UNiagaraComponent* InNC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterLanternNiagara");

	Params::NoceEnvironmentSubsystem_RegisterLanternNiagara Parms{};

	Parms.InNC = InNC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterLightFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalLightComponent*             InLL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceLightFadeFullSetting& InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    PossibleConflict                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceEnvironmentSubsystem::RegisterLightFade(class ULocalLightComponent* InLL, const struct FNoceLightFadeFullSetting& InParam, bool PossibleConflict)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterLightFade");

	Params::NoceEnvironmentSubsystem_RegisterLightFade Parms{};

	Parms.InLL = InLL;
	Parms.InParam = std::move(InParam);
	Parms.PossibleConflict = PossibleConflict;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterNPCLanternLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointLightComponent*             InPL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterNPCLanternLight(class UPointLightComponent* InPL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterNPCLanternLight");

	Params::NoceEnvironmentSubsystem_RegisterNPCLanternLight Parms{};

	Parms.InPL = InPL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterOnewayLightControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterOnewayLightControl(const class FString& ObjectName, float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterOnewayLightControl");

	Params::NoceEnvironmentSubsystem_RegisterOnewayLightControl Parms{};

	Parms.ObjectName = std::move(ObjectName);
	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterSkyAtmosphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkyAtmosphereComponent*          InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterSkyAtmosphere(class USkyAtmosphereComponent* InSL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterSkyAtmosphere");

	Params::NoceEnvironmentSubsystem_RegisterSkyAtmosphere Parms{};

	Parms.InSL = InSL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterSkyDome
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMI                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterSkyDome(class UMaterialInstanceDynamic* InMI, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterSkyDome");

	Params::NoceEnvironmentSubsystem_RegisterSkyDome Parms{};

	Parms.InMI = InMI;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterSkyLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterSkyLight(class USkyLightComponent* InSL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterSkyLight");

	Params::NoceEnvironmentSubsystem_RegisterSkyLight Parms{};

	Parms.InSL = InSL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterSweetLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USpotLightComponent*              InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceSweetLightType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterSweetLight(class USpotLightComponent* InSL, ENoceSweetLightType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterSweetLight");

	Params::NoceEnvironmentSubsystem_RegisterSweetLight Parms{};

	Parms.InSL = InSL;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterTargetFogComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceEnvironmentSubsystem::RegisterTargetFogComponent(class UExponentialHeightFogComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterTargetFogComponent");

	Params::NoceEnvironmentSubsystem_RegisterTargetFogComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterVolumetricFogMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InStaticMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFogTown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterVolumetricFogMaterial(class UStaticMeshComponent* InStaticMesh, bool IsFogTown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterVolumetricFogMaterial");

	Params::NoceEnvironmentSubsystem_RegisterVolumetricFogMaterial Parms{};

	Parms.InStaticMesh = InStaticMesh;
	Parms.IsFogTown = IsFogTown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.RegisterWindSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNeoWindComponent*                InWind                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::RegisterWindSource(class UNeoWindComponent* InWind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "RegisterWindSource");

	Params::NoceEnvironmentSubsystem_RegisterWindSource Parms{};

	Parms.InWind = InWind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetForceUseCameraLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetForceUseCameraLocation(bool InForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetForceUseCameraLocation");

	Params::NoceEnvironmentSubsystem_SetForceUseCameraLocation Parms{};

	Parms.InForce = InForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetLanternBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     InData                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   InBlendTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetLanternBlending(class FName RowName, const struct FNoceSpotLightSetting& InData, float InBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetLanternBlending");

	Params::NoceEnvironmentSubsystem_SetLanternBlending Parms{};

	Parms.RowName = RowName;
	Parms.InData = std::move(InData);
	Parms.InBlendTime = InBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetLightFadeDebugDraw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    EnableDebugDraw                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetLightFadeDebugDraw(int32 InIndex, bool EnableDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetLightFadeDebugDraw");

	Params::NoceEnvironmentSubsystem_SetLightFadeDebugDraw Parms{};

	Parms.InIndex = InIndex;
	Parms.EnableDebugDraw = EnableDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetLightFadeExtraIntensityAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetLightFadeExtraIntensityAlpha(int32 InIndex, float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetLightFadeExtraIntensityAlpha");

	Params::NoceEnvironmentSubsystem_SetLightFadeExtraIntensityAlpha Parms{};

	Parms.InIndex = InIndex;
	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetNocePPVBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendWeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetNocePPVBlendWeight(class FName TagName, float InBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetNocePPVBlendWeight");

	Params::NoceEnvironmentSubsystem_SetNocePPVBlendWeight Parms{};

	Parms.TagName = TagName;
	Parms.InBlendWeight = InBlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetNPCLanternExtraColorAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetNPCLanternExtraColorAlpha(float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetNPCLanternExtraColorAlpha");

	Params::NoceEnvironmentSubsystem_SetNPCLanternExtraColorAlpha Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetNPCLanternExtraIntensityAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetNPCLanternExtraIntensityAlpha(float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetNPCLanternExtraIntensityAlpha");

	Params::NoceEnvironmentSubsystem_SetNPCLanternExtraIntensityAlpha Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetPauseUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPauseHandler                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPauseFade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetPauseUpdate(bool InPauseHandler, bool InPauseFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetPauseUpdate");

	Params::NoceEnvironmentSubsystem_SetPauseUpdate Parms{};

	Parms.InPauseHandler = InPauseHandler;
	Parms.InPauseFade = InPauseFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetPlayerLanternExtraIntensityAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetPlayerLanternExtraIntensityAlpha(float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetPlayerLanternExtraIntensityAlpha");

	Params::NoceEnvironmentSubsystem_SetPlayerLanternExtraIntensityAlpha Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.SetSweetLightExtraIntensityAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::SetSweetLightExtraIntensityAlpha(float InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "SetSweetLightExtraIntensityAlpha");

	Params::NoceEnvironmentSubsystem_SetSweetLightExtraIntensityAlpha Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterDarknessMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     InMPC                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterDarknessMaterial(class UMaterialParameterCollection* InMPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterDarknessMaterial");

	Params::NoceEnvironmentSubsystem_UnregisterDarknessMaterial Parms{};

	Parms.InMPC = InMPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterDirectionalLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDirectionalLightComponent*       InDL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterDirectionalLight(class UDirectionalLightComponent* InDL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterDirectionalLight");

	Params::NoceEnvironmentSubsystem_UnregisterDirectionalLight Parms{};

	Parms.InDL = InDL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterEmissiveFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterEmissiveFade(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterEmissiveFade");

	Params::NoceEnvironmentSubsystem_UnregisterEmissiveFade Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterLanternLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointLightComponent*             InPL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceLanternLightType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterLanternLight(class UPointLightComponent* InPL, ENoceLanternLightType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterLanternLight");

	Params::NoceEnvironmentSubsystem_UnregisterLanternLight Parms{};

	Parms.InPL = InPL;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterLanternNiagara
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNC                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterLanternNiagara(class UNiagaraComponent* InNC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterLanternNiagara");

	Params::NoceEnvironmentSubsystem_UnregisterLanternNiagara Parms{};

	Parms.InNC = InNC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterLightFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterLightFade(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterLightFade");

	Params::NoceEnvironmentSubsystem_UnregisterLightFade Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterNPCLanternLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointLightComponent*             InPL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterNPCLanternLight(class UPointLightComponent* InPL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterNPCLanternLight");

	Params::NoceEnvironmentSubsystem_UnregisterNPCLanternLight Parms{};

	Parms.InPL = InPL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterSkyAtmosphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkyAtmosphereComponent*          InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterSkyAtmosphere(class USkyAtmosphereComponent* InSL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterSkyAtmosphere");

	Params::NoceEnvironmentSubsystem_UnregisterSkyAtmosphere Parms{};

	Parms.InSL = InSL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterSkyDome
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMI                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterSkyDome(class UMaterialInstanceDynamic* InMI, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterSkyDome");

	Params::NoceEnvironmentSubsystem_UnregisterSkyDome Parms{};

	Parms.InMI = InMI;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterSkyLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterSkyLight(class USkyLightComponent* InSL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterSkyLight");

	Params::NoceEnvironmentSubsystem_UnregisterSkyLight Parms{};

	Parms.InSL = InSL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterSweetLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USpotLightComponent*              InSL                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceSweetLightType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterSweetLight(class USpotLightComponent* InSL, ENoceSweetLightType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterSweetLight");

	Params::NoceEnvironmentSubsystem_UnregisterSweetLight Parms{};

	Parms.InSL = InSL;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterTargetFogComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterTargetFogComponent(class UExponentialHeightFogComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterTargetFogComponent");

	Params::NoceEnvironmentSubsystem_UnregisterTargetFogComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterVolumetricFogMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InStaticMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterVolumetricFogMaterial(class UStaticMeshComponent* InStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterVolumetricFogMaterial");

	Params::NoceEnvironmentSubsystem_UnregisterVolumetricFogMaterial Parms{};

	Parms.InStaticMesh = InStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UnregisterWindSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNeoWindComponent*                InWind                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UnregisterWindSource(class UNeoWindComponent* InWind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UnregisterWindSource");

	Params::NoceEnvironmentSubsystem_UnregisterWindSource Parms{};

	Parms.InWind = InWind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UpdateHeightFogWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PPVName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UpdateHeightFogWeight(class FName RowName, float InPriority, const class FString& PPVName, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UpdateHeightFogWeight");

	Params::NoceEnvironmentSubsystem_UpdateHeightFogWeight Parms{};

	Parms.RowName = RowName;
	Parms.InPriority = InPriority;
	Parms.PPVName = std::move(PPVName);
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UpdateSkyLightWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PPVName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UpdateSkyLightWeight(class FName RowName, float InPriority, const class FString& PPVName, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UpdateSkyLightWeight");

	Params::NoceEnvironmentSubsystem_UpdateSkyLightWeight Parms{};

	Parms.RowName = RowName;
	Parms.InPriority = InPriority;
	Parms.PPVName = std::move(PPVName);
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UpdateSweetLightWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceSweetLightType                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PPVName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UpdateSweetLightWeight(class FName RowName, float InPriority, ENoceSweetLightType InType, const class FString& PPVName, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UpdateSweetLightWeight");

	Params::NoceEnvironmentSubsystem_UpdateSweetLightWeight Parms{};

	Parms.RowName = RowName;
	Parms.InPriority = InPriority;
	Parms.InType = InType;
	Parms.PPVName = std::move(PPVName);
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvironmentSubsystem.UpdateVolumeFogWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PPVName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEnvironmentSubsystem::UpdateVolumeFogWeight(class FName RowName, float InPriority, const class FString& PPVName, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvironmentSubsystem", "UpdateVolumeFogWeight");

	Params::NoceEnvironmentSubsystem_UpdateVolumeFogWeight Parms{};

	Parms.RowName = RowName;
	Parms.InPriority = InPriority;
	Parms.PPVName = std::move(PPVName);
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNPCLookTargetComponent.GetCachedLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceNPCLookTargetComponent::GetCachedLookTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "GetCachedLookTarget");

	Params::NoceNPCLookTargetComponent_GetCachedLookTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNPCLookTargetComponent.GetEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceNPCLookTargetComponent::GetEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "GetEnable");

	Params::NoceNPCLookTargetComponent_GetEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNPCLookTargetComponent.GetLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceNPCLookTargetComponent::GetLookTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "GetLookTarget");

	Params::NoceNPCLookTargetComponent_GetLookTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNPCLookTargetComponent.GetPreviousLookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceNPCLookTargetComponent::GetPreviousLookAtLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "GetPreviousLookAtLocation");

	Params::NoceNPCLookTargetComponent_GetPreviousLookAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNPCLookTargetComponent.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNPCLookTargetComponent::SetEnable(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "SetEnable");

	Params::NoceNPCLookTargetComponent_SetEnable Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNPCLookTargetComponent.SetLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InLookTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNPCLookTargetComponent::SetLookTarget(class AActor* InLookTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "SetLookTarget");

	Params::NoceNPCLookTargetComponent_SetLookTarget Parms{};

	Parms.InLookTarget = InLookTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNPCLookTargetComponent.SetUseDeadZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNPCLookTargetComponent::SetUseDeadZone(bool InValue, float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "SetUseDeadZone");

	Params::NoceNPCLookTargetComponent_SetUseDeadZone Parms{};

	Parms.InValue = InValue;
	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNPCLookTargetComponent.SetUseMaxLookDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNPCLookTargetComponent::SetUseMaxLookDistance(bool InValue, float InMaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "SetUseMaxLookDistance");

	Params::NoceNPCLookTargetComponent_SetUseMaxLookDistance Parms{};

	Parms.InValue = InValue;
	Parms.InMaxDistance = InMaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNPCLookTargetComponent.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNPCLookTargetComponent::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNPCLookTargetComponent", "Update");

	Params::NoceNPCLookTargetComponent_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEnvNiagaraActor.IsLoadLoadRecordData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnvNiagaraActor::IsLoadLoadRecordData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvNiagaraActor", "IsLoadLoadRecordData");

	Params::NoceEnvNiagaraActor_IsLoadLoadRecordData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookContent.Init
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InIsVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsNew                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNeedTop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNeedBottom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookContent::Init(const bool InIsVisible, const bool InIsNew, bool InNeedTop, bool InNeedBottom, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookContent", "Init");

	Params::NoceNotebookContent_Init Parms{};

	Parms.InIsVisible = InIsVisible;
	Parms.InIsNew = InIsNew;
	Parms.InNeedTop = InNeedTop;
	Parms.InNeedBottom = InNeedBottom;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookContent.InitImage
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InIsVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsNew                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsDoodle                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InImage                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookContent::InitImage(const bool InIsVisible, const bool InIsNew, const bool InIsDoodle, const struct FSoftObjectPath& InImage, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookContent", "InitImage");

	Params::NoceNotebookContent_InitImage Parms{};

	Parms.InIsVisible = InIsVisible;
	Parms.InIsNew = InIsNew;
	Parms.InIsDoodle = InIsDoodle;
	Parms.InImage = std::move(InImage);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookContent.InitImageWithMask
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InIsVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsNew                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsDoodle                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InImage                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InMask                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookContent::InitImageWithMask(const bool InIsVisible, const bool InIsNew, const bool InIsDoodle, const struct FSoftObjectPath& InImage, const struct FSoftObjectPath& InMask, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookContent", "InitImageWithMask");

	Params::NoceNotebookContent_InitImageWithMask Parms{};

	Parms.InIsVisible = InIsVisible;
	Parms.InIsNew = InIsNew;
	Parms.InIsDoodle = InIsDoodle;
	Parms.InImage = std::move(InImage);
	Parms.InMask = std::move(InMask);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookContent.InitText
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              InIsVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              InIsNew                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNeedTop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNeedBottom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookContent::InitText(const bool InIsVisible, const bool InIsNew, bool InNeedTop, bool InNeedBottom, const class FText& InText, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookContent", "InitText");

	Params::NoceNotebookContent_InitText Parms{};

	Parms.InIsVisible = InIsVisible;
	Parms.InIsNew = InIsNew;
	Parms.InNeedTop = InNeedTop;
	Parms.InNeedBottom = InNeedBottom;
	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookContent.OnFadeIn
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookContent::OnFadeIn(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookContent", "OnFadeIn");

	Params::NoceNotebookContent_OnFadeIn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceEnvVolumeFogActor.IsLoadLoadRecordData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceEnvVolumeFogActor::IsLoadLoadRecordData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEnvVolumeFogActor", "IsLoadLoadRecordData");

	Params::NoceEnvVolumeFogActor_IsLoadLoadRecordData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOmamoriDrawingSubsystem.DrawOmamori
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ENoceOmamoriDrawingType*                out_Type                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            out_Name                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOmamoriDrawingSubsystem::DrawOmamori(ENoceOmamoriDrawingType* out_Type, class FName* out_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOmamoriDrawingSubsystem", "DrawOmamori");

	Params::NoceOmamoriDrawingSubsystem_DrawOmamori Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_Type != nullptr)
		*out_Type = Parms.out_Type;

	if (out_Name != nullptr)
		*out_Name = Parms.out_Name;
}


// Function GameNoce.NoceOmamoriDrawingSubsystem.GetRequiredFaith
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceOmamoriDrawingSubsystem::GetRequiredFaith()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOmamoriDrawingSubsystem", "GetRequiredFaith");

	Params::NoceOmamoriDrawingSubsystem_GetRequiredFaith Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOmamoriDrawingSubsystem.IsOmamoriLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceOmamoriDrawingSubsystem::IsOmamoriLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOmamoriDrawingSubsystem", "IsOmamoriLeft");

	Params::NoceOmamoriDrawingSubsystem_IsOmamoriLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIDataTableMappingText.SetTextStyleKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIDataTableMappingText::SetTextStyleKey(int32 Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIDataTableMappingText", "SetTextStyleKey");

	Params::NoceUIDataTableMappingText_SetTextStyleKey Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceExtractAudioDurationTool.WriteAudioDurationToDatatable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       InTable                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExtractJP                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceExtractAudioDurationTool::WriteAudioDurationToDatatable(class UDataTable* InTable, class FName InRowName, bool ExtractJP, float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceExtractAudioDurationTool", "WriteAudioDurationToDatatable");

	Params::NoceExtractAudioDurationTool_WriteAudioDurationToDatatable Parms{};

	Parms.InTable = InTable;
	Parms.InRowName = InRowName;
	Parms.ExtractJP = ExtractJP;
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEyeballGroupComponent.CollectEyeballFromChildren
// (Final, Native, Public, BlueprintCallable)

void UNoceEyeballGroupComponent::CollectEyeballFromChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEyeballGroupComponent", "CollectEyeballFromChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEyeballGroupComponent.RegisterEyeball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FollowPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEyeballGroupComponent::RegisterEyeball(class AActor* InActor, bool FollowPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEyeballGroupComponent", "RegisterEyeball");

	Params::NoceEyeballGroupComponent_RegisterEyeball Parms{};

	Parms.InActor = InActor;
	Parms.FollowPlayer = FollowPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceEyeballGroupComponent.UnregisterEyeball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceEyeballGroupComponent::UnregisterEyeball(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceEyeballGroupComponent", "UnregisterEyeball");

	Params::NoceEyeballGroupComponent_UnregisterEyeball Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFloatIconSubsystem.ClearIconPool
// (Final, Native, Public, BlueprintCallable)

void UNoceFloatIconSubsystem::ClearIconPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "ClearIconPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFloatIconSubsystem.GetActiveIndicatorVisiblity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UNoceFloatIconSubsystem::GetActiveIndicatorVisiblity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "GetActiveIndicatorVisiblity");

	Params::NoceFloatIconSubsystem_GetActiveIndicatorVisiblity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFloatIconSubsystem.IsShowIndicatorIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFloatIconSubsystem::IsShowIndicatorIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "IsShowIndicatorIcon");

	Params::NoceFloatIconSubsystem_IsShowIndicatorIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFloatIconSubsystem.RequestIndicatorIcon
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   IndicateLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFloatIconSubsystem::RequestIndicatorIcon(class AActor* Owner, const struct FVector& IndicateLocation, bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "RequestIndicatorIcon");

	Params::NoceFloatIconSubsystem_RequestIndicatorIcon Parms{};

	Parms.Owner = Owner;
	Parms.IndicateLocation = std::move(IndicateLocation);
	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFloatIconSubsystem.RequestInteractIcon
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInteractIconState                  TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   IconPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      PromptText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceFloatIconSubsystem::RequestInteractIcon(class AActor* Owner, ENoceInteractIconState TargetState, const struct FVector& IconPosition, const class FText& PromptText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "RequestInteractIcon");

	Params::NoceFloatIconSubsystem_RequestInteractIcon Parms{};

	Parms.Owner = Owner;
	Parms.TargetState = TargetState;
	Parms.IconPosition = std::move(IconPosition);
	Parms.PromptText = std::move(PromptText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFloatIconSubsystem.SetCanShowInteractIcon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InCanShow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFloatIconSubsystem::SetCanShowInteractIcon(bool InCanShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "SetCanShowInteractIcon");

	Params::NoceFloatIconSubsystem_SetCanShowInteractIcon Parms{};

	Parms.InCanShow = InCanShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFloatIconSubsystem.SetShowIndicatorIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFloatIconSubsystem::SetShowIndicatorIcon(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFloatIconSubsystem", "SetShowIndicatorIcon");

	Params::NoceFloatIconSubsystem_SetShowIndicatorIcon Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidgetBase.ResetSettingToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameSetting*                     Setting                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidgetBase::ResetSettingToDefault(class UGameSetting* Setting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidgetBase", "ResetSettingToDefault");

	Params::NoceOptionWidgetBase_ResetSettingToDefault Parms{};

	Parms.Setting = Setting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidgetBase.SetSetting
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameSetting*                     InSetting                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidgetBase::SetSetting(class UGameSetting* InSetting, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidgetBase", "SetSetting");

	Params::NoceOptionWidgetBase_SetSetting Parms{};

	Parms.InSetting = InSetting;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceOptionWidgetBase.SetSettings
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class UGameSetting*>&      InSettings                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidgetBase::SetSettings(const TArray<class UGameSetting*>& InSettings, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidgetBase", "SetSettings");

	Params::NoceOptionWidgetBase_SetSettings Parms{};

	Parms.InSettings = std::move(InSettings);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceOptionWidget.ApplyModifiedKeyBindings
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceOptionWidget::ApplyModifiedKeyBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "ApplyModifiedKeyBindings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceOptionWidget.ApplyPendingChanges
// (Final, Native, Protected, BlueprintCallable)

void UNoceOptionWidget::ApplyPendingChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "ApplyPendingChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.CheckChangedAndSave
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidget::CheckChangedAndSave(bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "CheckChangedAndSave");

	Params::NoceOptionWidget_CheckChangedAndSave Parms{};

	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.GetListView
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UNoceListView*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceListView* UNoceOptionWidget::GetListView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "GetListView");

	Params::NoceOptionWidget_GetListView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOptionWidget.GetSetting
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             SettingDevName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameSetting*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameSetting* UNoceOptionWidget::GetSetting(class FName SettingDevName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "GetSetting");

	Params::NoceOptionWidget_GetSetting Parms{};

	Parms.SettingDevName = SettingDevName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOptionWidget.HandleKeyBindingModified
// (Final, Native, Protected, BlueprintCallable)

void UNoceOptionWidget::HandleKeyBindingModified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "HandleKeyBindingModified");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.OnSettingsDirtyStateChanged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bSettingsDirty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidget::OnSettingsDirtyStateChanged(bool bSettingsDirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "OnSettingsDirtyStateChanged");

	Params::NoceOptionWidget_OnSettingsDirtyStateChanged Parms{};

	Parms.bSettingsDirty = bSettingsDirty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.SaveSettings
// (Final, Native, Protected, BlueprintCallable)

void UNoceOptionWidget::SaveSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "SaveSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.SaveSystemSave
// (Event, Protected, BlueprintEvent)

void UNoceOptionWidget::SaveSystemSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "SaveSystemSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceOptionWidget.SelectSetting
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      SettingDevName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOptionWidget::SelectSetting(const class FName& SettingDevName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "SelectSetting");

	Params::NoceOptionWidget_SelectSetting Parms{};

	Parms.SettingDevName = SettingDevName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.SelectSettings
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              SettingDevNames                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceOptionWidget::SelectSettings(const TArray<class FName>& SettingDevNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "SelectSettings");

	Params::NoceOptionWidget_SelectSettings Parms{};

	Parms.SettingDevNames = std::move(SettingDevNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOptionWidget.HaveSettingsBeenChanged
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceOptionWidget::HaveSettingsBeenChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionWidget", "HaveSettingsBeenChanged");

	Params::NoceOptionWidget_HaveSettingsBeenChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIGameplayTagMappingText.SetTextStyleByKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIGameplayTagMappingText::SetTextStyleByKey(const struct FGameplayTag& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIGameplayTagMappingText", "SetTextStyleByKey");

	Params::NoceUIGameplayTagMappingText_SetTextStyleByKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusablePage.OnSwitchInCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceFocusablePage::OnSwitchInCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusablePage", "OnSwitchInCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusablePage.OnSwitchOutCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceFocusablePage::OnSwitchOutCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusablePage", "OnSwitchOutCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusablePage.SwitchIn
// (Final, Native, Public, BlueprintCallable)

void UNoceFocusablePage::SwitchIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusablePage", "SwitchIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFocusablePage.SwitchOut
// (Final, Native, Public, BlueprintCallable)

void UNoceFocusablePage::SwitchOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceFocusablePage", "SwitchOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNpcCharacter.Kill
// (Native, Public, BlueprintCallable)

void ANoceNpcCharacter::Kill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNpcCharacter", "Kill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNpcCharacter.ResetMovementState
// (Final, Native, Public, BlueprintCallable)

void ANoceNpcCharacter::ResetMovementState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNpcCharacter", "ResetMovementState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNpcCharacter.SetRootMotionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceNpcCharacter::SetRootMotionScale(float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNpcCharacter", "SetRootMotionScale");

	Params::NoceNpcCharacter_SetRootMotionScale Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNpcCharacter.TryCreateRecord
// (Native, Public, BlueprintCallable)

void ANoceNpcCharacter::TryCreateRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNpcCharacter", "TryCreateRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.CreatePageWidget
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceFocusableWidget**            NewWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseWidget::CreatePageWidget(const struct FSoftClassPath& Path, class UNoceFocusableWidget** NewWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "CreatePageWidget");

	Params::NocePauseWidget_CreatePageWidget Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewWidget != nullptr)
		*NewWidget = Parms.NewWidget;
}


// Function GameNoce.NocePauseWidget.DoToTitle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::DoToTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "DoToTitle");

	Params::NocePauseWidget_DoToTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.ExecuteObj
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPauseListObject*                 Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseWidget::ExecuteObj(class UPauseListObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ExecuteObj");

	Params::NocePauseWidget_ExecuteObj Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.GetPauseListObjs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPauseListObject*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPauseListObject*> UNocePauseWidget::GetPauseListObjs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "GetPauseListObjs");

	Params::NocePauseWidget_GetPauseListObjs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.HideChangeLevel
// (Final, Native, Public, BlueprintCallable)

void UNocePauseWidget::HideChangeLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "HideChangeLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.IsInCombat
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::IsInCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "IsInCombat");

	Params::NocePauseWidget_IsInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.IsInEquipment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::IsInEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "IsInEquipment");

	Params::NocePauseWidget_IsInEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.IsInMap
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::IsInMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "IsInMap");

	Params::NocePauseWidget_IsInMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.IsInNotebook
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::IsInNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "IsInNotebook");

	Params::NocePauseWidget_IsInNotebook Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.IsInPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePauseWidget::IsInPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "IsInPage");

	Params::NocePauseWidget_IsInPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseWidget.OnFadeOutToTitleCompleted
// (Final, Native, Protected)

void UNocePauseWidget::OnFadeOutToTitleCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnFadeOutToTitleCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.OnListMouseConfirm
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseWidget::OnListMouseConfirm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnListMouseConfirm");

	Params::NocePauseWidget_OnListMouseConfirm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.OnOptionClosed
// (Final, Native, Protected)

void UNocePauseWidget::OnOptionClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnOptionClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.OnPageClose
// (Final, Native, Protected)

void UNocePauseWidget::OnPageClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnPageClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.OnPlayerEndPlay
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseWidget::OnPlayerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnPlayerEndPlay");

	Params::NocePauseWidget_OnPlayerEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.OnPopWindowClose
// (Final, Native, Protected)

void UNocePauseWidget::OnPopWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "OnPopWindowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.PrepareSeamlessTravel
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::PrepareSeamlessTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "PrepareSeamlessTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ShowEquipment
// (Final, Native, Public, BlueprintCallable)

void UNocePauseWidget::ShowEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ShowEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ShowMap
// (Final, Native, Public, BlueprintCallable)

void UNocePauseWidget::ShowMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ShowMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ShowNotebook
// (Final, Native, Public, BlueprintCallable)

void UNocePauseWidget::ShowNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ShowNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToCollectible
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToCollectible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToCollectible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToEquipment
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToMap
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToNotebook
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToOption
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToShortcutItem
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToShortcutItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToShortcutItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseWidget.ToTitle
// (Final, Native, Protected, BlueprintCallable)

void UNocePauseWidget::ToTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseWidget", "ToTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIInputImage.SetInputIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             IconName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIInputImage::SetInputIcon(class FName IconName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputImage", "SetInputIcon");

	Params::NoceUIInputImage_SetInputIcon Parms{};

	Parms.IconName = IconName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIInputImage.UpdateIcon
// (Final, Native, Public, BlueprintCallable)

void UNoceUIInputImage::UpdateIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputImage", "UpdateIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNewGameWidget.ShowNewGame
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InIsPlus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNewGameWidget::ShowNewGame(bool InIsPlus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewGameWidget", "ShowNewGame");

	Params::NoceNewGameWidget_ShowNewGame Parms{};

	Parms.InIsPlus = InIsPlus;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceFunctionLibrary.CalculateAngleBetweenVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   v1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   v2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::CalculateAngleBetweenVector(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateAngleBetweenVector");

	Params::NoceFunctionLibrary_CalculateAngleBetweenVector Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CalculateDamageDirectionAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InDamagedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InHitPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::CalculateDamageDirectionAngle(class AActor* InDamagedActor, const struct FVector& InHitPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateDamageDirectionAngle");

	Params::NoceFunctionLibrary_CalculateDamageDirectionAngle Parms{};

	Parms.InDamagedActor = InDamagedActor;
	Parms.InHitPoint = std::move(InHitPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CalculateDirectionAngle2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InForward                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InCenter                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InTarget                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::CalculateDirectionAngle2D(const struct FVector& InForward, const struct FVector& InCenter, const struct FVector& InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateDirectionAngle2D");

	Params::NoceFunctionLibrary_CalculateDirectionAngle2D Parms{};

	Parms.InForward = std::move(InForward);
	Parms.InCenter = std::move(InCenter);
	Parms.InTarget = std::move(InTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CalculateFootIKOffset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UAnimInstance*              InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LeftFootName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RightFootName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceUpDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceDownDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseMaxLeftRightDifference                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxLeftRightDifference                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAdjustOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutLeftFootOffset                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutRightFootOffset                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::CalculateFootIKOffset(const class UAnimInstance* InAnimInstance, float DeltaSeconds, class FName LeftFootName, class FName RightFootName, float TraceUpDistance, float TraceDownDistance, bool UseMaxLeftRightDifference, float MaxLeftRightDifference, float MaxAdjustOffset, float InterpSpeed, float* OutLeftFootOffset, float* OutRightFootOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateFootIKOffset");

	Params::NoceFunctionLibrary_CalculateFootIKOffset Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.LeftFootName = LeftFootName;
	Parms.RightFootName = RightFootName;
	Parms.TraceUpDistance = TraceUpDistance;
	Parms.TraceDownDistance = TraceDownDistance;
	Parms.UseMaxLeftRightDifference = UseMaxLeftRightDifference;
	Parms.MaxLeftRightDifference = MaxLeftRightDifference;
	Parms.MaxAdjustOffset = MaxAdjustOffset;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLeftFootOffset != nullptr)
		*OutLeftFootOffset = Parms.OutLeftFootOffset;

	if (OutRightFootOffset != nullptr)
		*OutRightFootOffset = Parms.OutRightFootOffset;
}


// Function GameNoce.NoceFunctionLibrary.CalculateNormalFromPoints
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Point1                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Point2                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Point3                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::CalculateNormalFromPoints(const struct FVector& Point1, const struct FVector& Point2, const struct FVector& Point3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateNormalFromPoints");

	Params::NoceFunctionLibrary_CalculateNormalFromPoints Parms{};

	Parms.Point1 = std::move(Point1);
	Parms.Point2 = std::move(Point2);
	Parms.Point3 = std::move(Point3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CalculateStringLineCount
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterPerLine                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceFunctionLibrary::CalculateStringLineCount(const class FString& InString, int32 CharacterPerLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateStringLineCount");

	Params::NoceFunctionLibrary_CalculateStringLineCount Parms{};

	Parms.InString = std::move(InString);
	Parms.CharacterPerLine = CharacterPerLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CalculateStringLineCountByLetterWidth
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceFunctionLibrary::CalculateStringLineCountByLetterWidth(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CalculateStringLineCountByLetterWidth");

	Params::NoceFunctionLibrary_CalculateStringLineCountByLetterWidth Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceMulti");

	Params::NoceFunctionLibrary_CapsuleTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceMultiByProfile");

	Params::NoceFunctionLibrary_CapsuleTraceMultiByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceMultiForObjects");

	Params::NoceFunctionLibrary_CapsuleTraceMultiForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceSingle");

	Params::NoceFunctionLibrary_CapsuleTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceSingleByProfile");

	Params::NoceFunctionLibrary_CapsuleTraceSingleByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CapsuleTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FRotator& orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CapsuleTraceSingleForObjects");

	Params::NoceFunctionLibrary_CapsuleTraceSingleForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.orientation = std::move(orientation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckActionLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceActionLevel                        InActionLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActionLevelBitmask                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckActionLevel(ENoceActionLevel InActionLevel, int32 ActionLevelBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckActionLevel");

	Params::NoceFunctionLibrary_CheckActionLevel Parms{};

	Parms.InActionLevel = InActionLevel;
	Parms.ActionLevelBitmask = ActionLevelBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckDefiniteEndingType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckDefiniteEndingType(class UObject* WorldContextObject, ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckDefiniteEndingType");

	Params::NoceFunctionLibrary_CheckDefiniteEndingType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckGameActionLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActionLevelBitmask                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckGameActionLevel(class UObject* WorldContextObject, int32 ActionLevelBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckGameActionLevel");

	Params::NoceFunctionLibrary_CheckGameActionLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActionLevelBitmask = ActionLevelBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckGameRiddleLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RiddleLevelBitmask                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckGameRiddleLevel(class UObject* WorldContextObject, int32 RiddleLevelBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckGameRiddleLevel");

	Params::NoceFunctionLibrary_CheckGameRiddleLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RiddleLevelBitmask = RiddleLevelBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckGameRound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameRoundBitmask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckGameRound(class UObject* WorldContextObject, int32 GameRoundBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckGameRound");

	Params::NoceFunctionLibrary_CheckGameRound Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GameRoundBitmask = GameRoundBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckOnSlope
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InMeshLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         InSlopeDetectObjectTypes                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ECollisionChannel                       InPawnChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDebugLog                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsOnStair                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel*                      OutObjectType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutHitLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutHitNormal                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::CheckOnSlope(class UObject* WorldContextObject, const struct FVector& InMeshLocation, const TArray<EObjectTypeQuery>& InSlopeDetectObjectTypes, ECollisionChannel InPawnChannel, bool InDebugLog, bool* OutIsOnStair, ECollisionChannel* OutObjectType, struct FVector* OutHitLocation, struct FVector* OutHitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckOnSlope");

	Params::NoceFunctionLibrary_CheckOnSlope Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMeshLocation = std::move(InMeshLocation);
	Parms.InSlopeDetectObjectTypes = std::move(InSlopeDetectObjectTypes);
	Parms.InPawnChannel = InPawnChannel;
	Parms.InDebugLog = InDebugLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsOnStair != nullptr)
		*OutIsOnStair = Parms.OutIsOnStair;

	if (OutObjectType != nullptr)
		*OutObjectType = Parms.OutObjectType;

	if (OutHitLocation != nullptr)
		*OutHitLocation = std::move(Parms.OutHitLocation);

	if (OutHitNormal != nullptr)
		*OutHitNormal = std::move(Parms.OutHitNormal);
}


// Function GameNoce.NoceFunctionLibrary.CheckPlayGoDownloadProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InProgressTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAnyEndingCleared                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckPlayGoDownloadProgress(class UObject* WorldContextObject, const struct FGameplayTag& InProgressTag, bool IsAnyEndingCleared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckPlayGoDownloadProgress");

	Params::NoceFunctionLibrary_CheckPlayGoDownloadProgress Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InProgressTag = std::move(InProgressTag);
	Parms.IsAnyEndingCleared = IsAnyEndingCleared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckRiddleLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRiddleLevel                        InRiddleLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RiddleLevelBitmask                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckRiddleLevel(ENoceRiddleLevel InRiddleLevel, int32 RiddleLevelBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckRiddleLevel");

	Params::NoceFunctionLibrary_CheckRiddleLevel Parms{};

	Parms.InRiddleLevel = InRiddleLevel;
	Parms.RiddleLevelBitmask = RiddleLevelBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckRound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          InRoundType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameRoundBitmask                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckRound(ENoceRoundType InRoundType, int32 GameRoundBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckRound");

	Params::NoceFunctionLibrary_CheckRound Parms{};

	Parms.InRoundType = InRoundType;
	Parms.GameRoundBitmask = GameRoundBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CheckStoryEndingBranch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndingBitmask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::CheckStoryEndingBranch(class UObject* WorldContextObject, int32 EndingBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CheckStoryEndingBranch");

	Params::NoceFunctionLibrary_CheckStoryEndingBranch Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EndingBitmask = EndingBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ClampLookAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSpineSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLookAtLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InTargetHeadLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLengthRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPitchRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InYawRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDebugDraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::ClampLookAtLocation(class AActor* InTargetActor, class FName InSpineSocketName, const struct FVector& InLookAtLocation, const struct FVector& InTargetHeadLocation, float InLengthRange, float InPitchRange, float InYawRange, bool InDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ClampLookAtLocation");

	Params::NoceFunctionLibrary_ClampLookAtLocation Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InSpineSocketName = InSpineSocketName;
	Parms.InLookAtLocation = std::move(InLookAtLocation);
	Parms.InTargetHeadLocation = std::move(InTargetHeadLocation);
	Parms.InLengthRange = InLengthRange;
	Parms.InPitchRange = InPitchRange;
	Parms.InYawRange = InYawRange;
	Parms.InDebugDraw = InDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ClearMotionVector
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   InChar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ClearMotionVector(class ANoceCharacter* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ClearMotionVector");

	Params::NoceFunctionLibrary_ClearMotionVector Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.CloneActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InputActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceFunctionLibrary::CloneActor(class AActor* InputActor, class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CloneActor");

	Params::NoceFunctionLibrary_CloneActor Parms{};

	Parms.InputActor = InputActor;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ComputeInputAngle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InInputForward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InInputRight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::ComputeInputAngle(class UObject* WorldContextObject, float InInputForward, float InInputRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ComputeInputAngle");

	Params::NoceFunctionLibrary_ComputeInputAngle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InInputForward = InInputForward;
	Parms.InInputRight = InInputRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ComputeStairAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharcter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InHitNrmal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::ComputeStairAngle(class ACharacter* InCharcter, const struct FVector& InHitNrmal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ComputeStairAngle");

	Params::NoceFunctionLibrary_ComputeStairAngle Parms{};

	Parms.InCharcter = InCharcter;
	Parms.InHitNrmal = std::move(InHitNrmal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.CorrectActorRotation_Direct
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::CorrectActorRotation_Direct(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "CorrectActorRotation_Direct");

	Params::NoceFunctionLibrary_CorrectActorRotation_Direct Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DeactivateNiagara
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDetachFromComponent                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DeactivateNiagara(class UNiagaraComponent* InNiagaraComponent, bool InDetachFromComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DeactivateNiagara");

	Params::NoceFunctionLibrary_DeactivateNiagara Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;
	Parms.InDetachFromComponent = InDetachFromComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DelayDestroyActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InData                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InDelaySeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DelayDestroyActors(const TArray<class AActor*>& InData, float InDelaySeconds, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DelayDestroyActors");

	Params::NoceFunctionLibrary_DelayDestroyActors Parms{};

	Parms.InData = std::move(InData);
	Parms.InDelaySeconds = InDelaySeconds;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DrawCircleArc
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Degree                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PersistentLines                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DrawCircleArc(class UObject* WorldContextObject, const struct FVector& Center, float Radius, const struct FVector& Direction, float Degree, int32 Segments, const struct FLinearColor& LineColor, bool PersistentLines, float Lifetime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DrawCircleArc");

	Params::NoceFunctionLibrary_DrawCircleArc Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.Direction = std::move(Direction);
	Parms.Degree = Degree;
	Parms.Segments = Segments;
	Parms.LineColor = std::move(LineColor);
	Parms.PersistentLines = PersistentLines;
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DrawDebugArrowShift
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thinkness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DrawDebugArrowShift(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FLinearColor& LineColor, float ArrowSize, float Offset, float duration, float Thinkness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DrawDebugArrowShift");

	Params::NoceFunctionLibrary_DrawDebugArrowShift Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.LineColor = std::move(LineColor);
	Parms.ArrowSize = ArrowSize;
	Parms.Offset = Offset;
	Parms.duration = duration;
	Parms.Thinkness = Thinkness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DrawDebugFan
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origi                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Degree                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DrawDebugFan(class UObject* WorldContextObject, const struct FVector& Origi, const struct FVector& Direction, float MinRadius, float MaxRadius, float Degree, int32 Segments, const struct FLinearColor& LineColor, float Lifetime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DrawDebugFan");

	Params::NoceFunctionLibrary_DrawDebugFan Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origi = std::move(Origi);
	Parms.Direction = std::move(Direction);
	Parms.MinRadius = MinRadius;
	Parms.MaxRadius = MaxRadius;
	Parms.Degree = Degree;
	Parms.Segments = Segments;
	Parms.LineColor = std::move(LineColor);
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.DrawDebugFanByCenter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origi                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FrontDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BackDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::DrawDebugFanByCenter(class UObject* WorldContextObject, const struct FVector& Origi, const struct FVector& Center, float FrontDistance, float BackDistance, float Angle, const struct FLinearColor& LineColor, float Lifetime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "DrawDebugFanByCenter");

	Params::NoceFunctionLibrary_DrawDebugFanByCenter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origi = std::move(Origi);
	Parms.Center = std::move(Center);
	Parms.FrontDistance = FrontDistance;
	Parms.BackDistance = BackDistance;
	Parms.Angle = Angle;
	Parms.LineColor = std::move(LineColor);
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.EnableMaterialSlots
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InMatSlotNames                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::EnableMaterialSlots(bool bEnable, class USkeletalMeshComponent* InComp, const TArray<class FName>& InMatSlotNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "EnableMaterialSlots");

	Params::NoceFunctionLibrary_EnableMaterialSlots Parms{};

	Parms.bEnable = bEnable;
	Parms.InComp = InComp;
	Parms.InMatSlotNames = std::move(InMatSlotNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.Equal_ActorRecord
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FNoceActorRecord&          A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UObject*                    B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::Equal_ActorRecord(const struct FNoceActorRecord& A, const class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "Equal_ActorRecord");

	Params::NoceFunctionLibrary_Equal_ActorRecord Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.Equal_Record
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FNoceObjectRecord&         A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UObject*                    B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::Equal_Record(const struct FNoceObjectRecord& A, const class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "Equal_Record");

	Params::NoceFunctionLibrary_Equal_Record Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ExecuteConsoleCmdFromSeqData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceSeqData&              InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ExecuteConsoleCmdFromSeqData(const struct FNoceSeqData& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ExecuteConsoleCmdFromSeqData");

	Params::NoceFunctionLibrary_ExecuteConsoleCmdFromSeqData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ExecuteConsoleCommandWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Param                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InTagName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ExecuteConsoleCommandWithTag(const class FString& Command, const class FString& Param, const class FName& InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ExecuteConsoleCommandWithTag");

	Params::NoceFunctionLibrary_ExecuteConsoleCommandWithTag Parms{};

	Parms.Command = std::move(Command);
	Parms.Param = std::move(Param);
	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ExecuteSeqDataCmdWithTagForHighSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSeqDataCmd&           InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FName&                      InTagName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ExecuteSeqDataCmdWithTagForHighSpec(const class FString& Command, const struct FNoceSeqDataCmd& InData, const class FName& InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ExecuteSeqDataCmdWithTagForHighSpec");

	Params::NoceFunctionLibrary_ExecuteSeqDataCmdWithTagForHighSpec Parms{};

	Parms.Command = std::move(Command);
	Parms.InData = std::move(InData);
	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ForceClothNextUpdateTeleport
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ForceClothNextUpdateTeleport(class ANoceCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ForceClothNextUpdateTeleport");

	Params::NoceFunctionLibrary_ForceClothNextUpdateTeleport Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ForceStopSlotAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ForceStopSlotAnimation(class UAnimInstance* InAnimInstance, float InBlendOutTime, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ForceStopSlotAnimation");

	Params::NoceFunctionLibrary_ForceStopSlotAnimation Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.InBlendOutTime = InBlendOutTime;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.GenerateRandomForceVector_Hatcher100
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FNoceRandomForceVectorData&InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DirectionOffset                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Previous                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Next                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_LocalTimer                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::GenerateRandomForceVector_Hatcher100(const struct FNoceRandomForceVectorData& InData, float InTime, float DeltaTime, const struct FVector& Direction, const struct FVector& DirectionOffset, TArray<struct FVector>& OutRandomVectorStorage_Previous, TArray<struct FVector>& OutRandomVectorStorage_Next, TArray<struct FVector>& OutRandomVectorStorage_LocalTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GenerateRandomForceVector_Hatcher100");

	Params::NoceFunctionLibrary_GenerateRandomForceVector_Hatcher100 Parms{};

	Parms.InData = std::move(InData);
	Parms.InTime = InTime;
	Parms.DeltaTime = DeltaTime;
	Parms.Direction = std::move(Direction);
	Parms.DirectionOffset = std::move(DirectionOffset);
	Parms.OutRandomVectorStorage_Previous = std::move(OutRandomVectorStorage_Previous);
	Parms.OutRandomVectorStorage_Next = std::move(OutRandomVectorStorage_Next);
	Parms.OutRandomVectorStorage_LocalTimer = std::move(OutRandomVectorStorage_LocalTimer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutRandomVectorStorage_Previous = std::move(Parms.OutRandomVectorStorage_Previous);
	OutRandomVectorStorage_Next = std::move(Parms.OutRandomVectorStorage_Next);
	OutRandomVectorStorage_LocalTimer = std::move(Parms.OutRandomVectorStorage_LocalTimer);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GenerateRandomForceVector_TsukumoBody
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FNoceRandomForceVectorData&InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DirectionOffset                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Previous                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Next                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_LocalTimer                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::GenerateRandomForceVector_TsukumoBody(const struct FNoceRandomForceVectorData& InData, float InTime, float DeltaTime, const struct FVector& Direction, const struct FVector& DirectionOffset, TArray<struct FVector>& OutRandomVectorStorage_Previous, TArray<struct FVector>& OutRandomVectorStorage_Next, TArray<struct FVector>& OutRandomVectorStorage_LocalTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GenerateRandomForceVector_TsukumoBody");

	Params::NoceFunctionLibrary_GenerateRandomForceVector_TsukumoBody Parms{};

	Parms.InData = std::move(InData);
	Parms.InTime = InTime;
	Parms.DeltaTime = DeltaTime;
	Parms.Direction = std::move(Direction);
	Parms.DirectionOffset = std::move(DirectionOffset);
	Parms.OutRandomVectorStorage_Previous = std::move(OutRandomVectorStorage_Previous);
	Parms.OutRandomVectorStorage_Next = std::move(OutRandomVectorStorage_Next);
	Parms.OutRandomVectorStorage_LocalTimer = std::move(OutRandomVectorStorage_LocalTimer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutRandomVectorStorage_Previous = std::move(Parms.OutRandomVectorStorage_Previous);
	OutRandomVectorStorage_Next = std::move(Parms.OutRandomVectorStorage_Next);
	OutRandomVectorStorage_LocalTimer = std::move(Parms.OutRandomVectorStorage_LocalTimer);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GenerateRandomForceVector_TsukumoHair
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FNoceRandomForceVectorData&InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DirectionOffset                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Previous                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_Next                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>&                 OutRandomVectorStorage_LocalTimer                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::GenerateRandomForceVector_TsukumoHair(const struct FNoceRandomForceVectorData& InData, float InTime, float DeltaTime, const struct FVector& Direction, const struct FVector& DirectionOffset, TArray<struct FVector>& OutRandomVectorStorage_Previous, TArray<struct FVector>& OutRandomVectorStorage_Next, TArray<struct FVector>& OutRandomVectorStorage_LocalTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GenerateRandomForceVector_TsukumoHair");

	Params::NoceFunctionLibrary_GenerateRandomForceVector_TsukumoHair Parms{};

	Parms.InData = std::move(InData);
	Parms.InTime = InTime;
	Parms.DeltaTime = DeltaTime;
	Parms.Direction = std::move(Direction);
	Parms.DirectionOffset = std::move(DirectionOffset);
	Parms.OutRandomVectorStorage_Previous = std::move(OutRandomVectorStorage_Previous);
	Parms.OutRandomVectorStorage_Next = std::move(OutRandomVectorStorage_Next);
	Parms.OutRandomVectorStorage_LocalTimer = std::move(OutRandomVectorStorage_LocalTimer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutRandomVectorStorage_Previous = std::move(Parms.OutRandomVectorStorage_Previous);
	OutRandomVectorStorage_Next = std::move(Parms.OutRandomVectorStorage_Next);
	OutRandomVectorStorage_LocalTimer = std::move(Parms.OutRandomVectorStorage_LocalTimer);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetAllRoundSequenceNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceRoundType                          RoundType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceFunctionLibrary::GetAllRoundSequenceNames(ENoceRoundType RoundType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetAllRoundSequenceNames");

	Params::NoceFunctionLibrary_GetAllRoundSequenceNames Parms{};

	Parms.RoundType = RoundType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetAssetName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           Obj                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetAssetName(TSoftObjectPtr<class UObject> Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetAssetName");

	Params::NoceFunctionLibrary_GetAssetName Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetBinkUrlWithOutfitSuffix
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContextObject                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InURL                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetBinkUrlWithOutfitSuffix(class UObject* InWorldContextObject, const class FString& InURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetBinkUrlWithOutfitSuffix");

	Params::NoceFunctionLibrary_GetBinkUrlWithOutfitSuffix Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InURL = std::move(InURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetBPCDOMeshComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           InActorClass                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>*          OutArray                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::GetBPCDOMeshComponents(class UClass* InActorClass, TArray<class UMeshComponent*>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetBPCDOMeshComponents");

	Params::NoceFunctionLibrary_GetBPCDOMeshComponents Parms{};

	Parms.InActorClass = InActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);
}


// Function GameNoce.NoceFunctionLibrary.GetCharacterSlopeAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   SizeRatio                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DebugDraw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetCharacterSlopeAngle(class ACharacter* Character, const TArray<EObjectTypeQuery>& ObjectTypes, float SizeRatio, bool DebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCharacterSlopeAngle");

	Params::NoceFunctionLibrary_GetCharacterSlopeAngle Parms{};

	Parms.Character = Character;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.SizeRatio = SizeRatio;
	Parms.DebugDraw = DebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCineEventUserTypeFromString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceCineEventUserType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceCineEventUserType UNoceFunctionLibrary::GetCineEventUserTypeFromString(const class FString& InStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCineEventUserTypeFromString");

	Params::NoceFunctionLibrary_GetCineEventUserTypeFromString Parms{};

	Parms.InStr = std::move(InStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetClassFromAssetData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FAssetData&                InAssetData                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UNoceFunctionLibrary::GetClassFromAssetData(const struct FAssetData& InAssetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetClassFromAssetData");

	Params::NoceFunctionLibrary_GetClassFromAssetData Parms{};

	Parms.InAssetData = std::move(InAssetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCompCollisionType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionEnabled                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionEnabled UNoceFunctionLibrary::GetCompCollisionType(class UPrimitiveComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCompCollisionType");

	Params::NoceFunctionLibrary_GetCompCollisionType Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCurrentChapterName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetCurrentChapterName(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCurrentChapterName");

	Params::NoceFunctionLibrary_GetCurrentChapterName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCurrentDefiniteEnding
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEndingType UNoceFunctionLibrary::GetCurrentDefiniteEnding(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCurrentDefiniteEnding");

	Params::NoceFunctionLibrary_GetCurrentDefiniteEnding Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCurrentEndingBranch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEndingType UNoceFunctionLibrary::GetCurrentEndingBranch(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCurrentEndingBranch");

	Params::NoceFunctionLibrary_GetCurrentEndingBranch Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCurrentProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceFunctionLibrary::GetCurrentProgress(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCurrentProgress");

	Params::NoceFunctionLibrary_GetCurrentProgress Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetCVarCurrentValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InCVarName                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetCVarCurrentValue(const class FString& InCVarName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetCVarCurrentValue");

	Params::NoceFunctionLibrary_GetCVarCurrentValue Parms{};

	Parms.InCVarName = std::move(InCVarName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetDependencySoftObjPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   InSeq                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UObject>>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UObject>> UNoceFunctionLibrary::GetDependencySoftObjPtr(class ULevelSequence* InSeq, TSubclassOf<class UObject> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetDependencySoftObjPtr");

	Params::NoceFunctionLibrary_GetDependencySoftObjPtr Parms{};

	Parms.InSeq = InSeq;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetDiffDegree
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   AnchorFoward                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetDiffDegree(const struct FVector& AnchorFoward, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetDiffDegree");

	Params::NoceFunctionLibrary_GetDiffDegree Parms{};

	Parms.AnchorFoward = std::move(AnchorFoward);
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetForwardDiffDegree
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Anchor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Check                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetForwardDiffDegree(class AActor* Anchor, const struct FVector& Check)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetForwardDiffDegree");

	Params::NoceFunctionLibrary_GetForwardDiffDegree Parms{};

	Parms.Anchor = Anchor;
	Parms.Check = std::move(Check);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetGameActionLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceActionLevel                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceActionLevel UNoceFunctionLibrary::GetGameActionLevel(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetGameActionLevel");

	Params::NoceFunctionLibrary_GetGameActionLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetGameRiddleLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRiddleLevel                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRiddleLevel UNoceFunctionLibrary::GetGameRiddleLevel(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetGameRiddleLevel");

	Params::NoceFunctionLibrary_GetGameRiddleLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetGameRound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType UNoceFunctionLibrary::GetGameRound(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetGameRound");

	Params::NoceFunctionLibrary_GetGameRound Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetGlobalTimeDilationMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetGlobalTimeDilationMultiplier(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetGlobalTimeDilationMultiplier");

	Params::NoceFunctionLibrary_GetGlobalTimeDilationMultiplier Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetHitReactionFourWay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAngel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceHitReactionFourWayType             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceHitReactionFourWayType UNoceFunctionLibrary::GetHitReactionFourWay(class UObject* WorldContextObject, float InAngel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetHitReactionFourWay");

	Params::NoceFunctionLibrary_GetHitReactionFourWay Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InAngel = InAngel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetHitReactionTwoWay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAngel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceHitReactionTwoWayType              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceHitReactionTwoWayType UNoceFunctionLibrary::GetHitReactionTwoWay(class UObject* WorldContextObject, float InAngel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetHitReactionTwoWay");

	Params::NoceFunctionLibrary_GetHitReactionTwoWay Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InAngel = InAngel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetInputMappingVectorFromCameraRotate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  InCameraRotator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InInputForward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InInputRight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::GetInputMappingVectorFromCameraRotate(const struct FRotator& InCameraRotator, float InInputForward, float InInputRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetInputMappingVectorFromCameraRotate");

	Params::NoceFunctionLibrary_GetInputMappingVectorFromCameraRotate Parms{};

	Parms.InCameraRotator = std::move(InCameraRotator);
	Parms.InInputForward = InInputForward;
	Parms.InInputRight = InInputRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetMediaName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMediaPlayer*                     MediaPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceFunctionLibrary::GetMediaName(class UMediaPlayer* MediaPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetMediaName");

	Params::NoceFunctionLibrary_GetMediaName Parms{};

	Parms.MediaPlayer = MediaPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNiagaraVariableBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVariableName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::GetNiagaraVariableBool(class UNiagaraComponent* NiagaraComponent, class FName InVariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNiagaraVariableBool");

	Params::NoceFunctionLibrary_GetNiagaraVariableBool Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.InVariableName = InVariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNiagaraVariableFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVariableName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetNiagaraVariableFloat(class UNiagaraComponent* NiagaraComponent, class FName InVariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNiagaraVariableFloat");

	Params::NoceFunctionLibrary_GetNiagaraVariableFloat Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.InVariableName = InVariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNiagaraVariableLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVariableName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UNoceFunctionLibrary::GetNiagaraVariableLinearColor(class UNiagaraComponent* NiagaraComponent, class FName InVariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNiagaraVariableLinearColor");

	Params::NoceFunctionLibrary_GetNiagaraVariableLinearColor Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.InVariableName = InVariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNiagaraVariableVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InVariableName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNoceFunctionLibrary::GetNiagaraVariableVector(class UNiagaraComponent* NiagaraComponent, class FName InVariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNiagaraVariableVector");

	Params::NoceFunctionLibrary_GetNiagaraVariableVector Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.InVariableName = InVariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNoceCheatManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceCheatManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceCheatManager* UNoceFunctionLibrary::GetNoceCheatManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNoceCheatManager");

	Params::NoceFunctionLibrary_GetNoceCheatManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNoceGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceGameInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceGameInstance* UNoceFunctionLibrary::GetNoceGameInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNoceGameInstance");

	Params::NoceFunctionLibrary_GetNoceGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNoceGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceGameMode*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceGameMode* UNoceFunctionLibrary::GetNoceGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNoceGameMode");

	Params::NoceFunctionLibrary_GetNoceGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNoceGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceGameState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceGameState* UNoceFunctionLibrary::GetNoceGameState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNoceGameState");

	Params::NoceFunctionLibrary_GetNoceGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNoceGlobalDelegates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceGlobalDelegates*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceGlobalDelegates* UNoceFunctionLibrary::GetNoceGlobalDelegates(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNoceGlobalDelegates");

	Params::NoceFunctionLibrary_GetNoceGlobalDelegates Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetNocePlayerCharater
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerCharacter*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerCharacter* UNoceFunctionLibrary::GetNocePlayerCharater(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetNocePlayerCharater");

	Params::NoceFunctionLibrary_GetNocePlayerCharater Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetPhysicsAssetCollision
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionEnabled*                      OutCollisionEnabled                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::GetPhysicsAssetCollision(class USkeletalMeshComponent* InSkeletalMesh, class FName InBoneName, ECollisionEnabled* OutCollisionEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetPhysicsAssetCollision");

	Params::NoceFunctionLibrary_GetPhysicsAssetCollision Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCollisionEnabled != nullptr)
		*OutCollisionEnabled = Parms.OutCollisionEnabled;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetPlaySequenceStateSeqActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceFunctionLibrary::GetPlaySequenceStateSeqActor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetPlaySequenceStateSeqActor");

	Params::NoceFunctionLibrary_GetPlaySequenceStateSeqActor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetPreSeamlessMontagePlayRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetPreSeamlessMontagePlayRate(class UAnimMontage* InMontage, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetPreSeamlessMontagePlayRate");

	Params::NoceFunctionLibrary_GetPreSeamlessMontagePlayRate Parms{};

	Parms.InMontage = InMontage;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetPreSeamlessMotionWarppingDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetPreSeamlessMotionWarppingDuration(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetPreSeamlessMotionWarppingDuration");

	Params::NoceFunctionLibrary_GetPreSeamlessMotionWarppingDuration Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetPreviewLightSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetPreviewLightSet(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetPreviewLightSet");

	Params::NoceFunctionLibrary_GetPreviewLightSet Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetRBANAlphaRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetRBANAlphaRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetRBANAlphaRatio");

	Params::NoceFunctionLibrary_GetRBANAlphaRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetSeqDataAssetPackageNameFromSeq
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UMovieSceneSequence>PlaySeq                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::GetSeqDataAssetPackageNameFromSeq(TSoftObjectPtr<class UMovieSceneSequence> PlaySeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetSeqDataAssetPackageNameFromSeq");

	Params::NoceFunctionLibrary_GetSeqDataAssetPackageNameFromSeq Parms{};

	Parms.PlaySeq = PlaySeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetSequenceName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequencePlayer*             SequencePlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceFunctionLibrary::GetSequenceName(class ULevelSequencePlayer* SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetSequenceName");

	Params::NoceFunctionLibrary_GetSequenceName Parms{};

	Parms.SequencePlayer = SequencePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetSkirtSlopeAdjustRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetSkirtSlopeAdjustRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetSkirtSlopeAdjustRatio");

	Params::NoceFunctionLibrary_GetSkirtSlopeAdjustRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetSpineSocketRotationYaw
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSpineSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetSpineSocketRotationYaw(class AActor* InTargetActor, class FName InSpineSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetSpineSocketRotationYaw");

	Params::NoceFunctionLibrary_GetSpineSocketRotationYaw Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InSpineSocketName = InSpineSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetTimeManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceTimeManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceTimeManager* UNoceFunctionLibrary::GetTimeManager(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetTimeManager");

	Params::NoceFunctionLibrary_GetTimeManager Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetTraceOffset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UAnimInstance*              InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceUpDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceDownDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::GetTraceOffset(const class UAnimInstance* InAnimInstance, class FName SocketName, float TraceUpDistance, float TraceDownDistance, bool ShowDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetTraceOffset");

	Params::NoceFunctionLibrary_GetTraceOffset Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.SocketName = SocketName;
	Parms.TraceUpDistance = TraceUpDistance;
	Parms.TraceDownDistance = TraceDownDistance;
	Parms.ShowDebug = ShowDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.GetWeaponSubSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceWeaponSubsystem*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceWeaponSubsystem* UNoceFunctionLibrary::GetWeaponSubSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "GetWeaponSubSystem");

	Params::NoceFunctionLibrary_GetWeaponSubSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.HandleRestartGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::HandleRestartGame(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "HandleRestartGame");

	Params::NoceFunctionLibrary_HandleRestartGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.HasQualitySwitchNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterial*                        InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Info                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::HasQualitySwitchNode(class UMaterial* InMaterial, class FString* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "HasQualitySwitchNode");

	Params::NoceFunctionLibrary_HasQualitySwitchNode Parms{};

	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsActiveEffectHandleValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FActiveGameplayEffectHandle&InEffectHandle                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsActiveEffectHandleValid(const struct FActiveGameplayEffectHandle& InEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsActiveEffectHandleValid");

	Params::NoceFunctionLibrary_IsActiveEffectHandleValid Parms{};

	Parms.InEffectHandle = std::move(InEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsActiveMovieSceneExecutor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsActiveMovieSceneExecutor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsActiveMovieSceneExecutor");

	Params::NoceFunctionLibrary_IsActiveMovieSceneExecutor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsActivePreloadSequenceAndSeqData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsActivePreloadSequenceAndSeqData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsActivePreloadSequenceAndSeqData");

	Params::NoceFunctionLibrary_IsActivePreloadSequenceAndSeqData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsActivePreloadSeqUpdateDataLayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsActivePreloadSeqUpdateDataLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsActivePreloadSeqUpdateDataLayer");

	Params::NoceFunctionLibrary_IsActivePreloadSeqUpdateDataLayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsActorOfClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftClassPtr<class UClass>       Class_0                                                (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsActorOfClass(class AActor* Actor, const TSoftClassPtr<class UClass> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsActorOfClass");

	Params::NoceFunctionLibrary_IsActorOfClass Parms{};

	Parms.Actor = Actor;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsForceJumpPlaybackPosByCmd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsForceJumpPlaybackPosByCmd(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsForceJumpPlaybackPosByCmd");

	Params::NoceFunctionLibrary_IsForceJumpPlaybackPosByCmd Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsGame");

	Params::NoceFunctionLibrary_IsGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsInEndGameProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsInEndGameProgress(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsInEndGameProgress");

	Params::NoceFunctionLibrary_IsInEndGameProgress Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsInEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsInEvent(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsInEvent");

	Params::NoceFunctionLibrary_IsInEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsInPartitionedWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsInPartitionedWorld(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsInPartitionedWorld");

	Params::NoceFunctionLibrary_IsInPartitionedWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsInPlaySequenceState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsInPlaySequenceState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsInPlaySequenceState");

	Params::NoceFunctionLibrary_IsInPlaySequenceState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsNiagaraComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNiagaraComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsNiagaraComplete(class UNiagaraComponent* InNiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsNiagaraComplete");

	Params::NoceFunctionLibrary_IsNiagaraComplete Parms{};

	Parms.InNiagaraComponent = InNiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsPlayerInputDirectionIsOppositeToCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsPlayerInputDirectionIsOppositeToCharacter(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsPlayerInputDirectionIsOppositeToCharacter");

	Params::NoceFunctionLibrary_IsPlayerInputDirectionIsOppositeToCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsPointInFanShape
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsPointInFanShape(const struct FVector& Origin, const struct FVector& Direction, const struct FVector& TargetPoint, float Angle, float MinRadius, float MaxRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsPointInFanShape");

	Params::NoceFunctionLibrary_IsPointInFanShape Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.TargetPoint = std::move(TargetPoint);
	Parms.Angle = Angle;
	Parms.MinRadius = MinRadius;
	Parms.MaxRadius = MaxRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsProgressConditionMatch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InProgressCondition                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    ExactProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InNeedAddTag                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    NeedAllAddTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NeedAddTagNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InWithoutAddTag                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    WithoutAllTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsProgressConditionMatch(class UObject* WorldContextObject, const struct FGameplayTagContainer& InProgressCondition, bool ExactProgress, const struct FGameplayTagContainer& InNeedAddTag, bool NeedAllAddTag, int32 NeedAddTagNum, const struct FGameplayTagContainer& InWithoutAddTag, bool WithoutAllTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsProgressConditionMatch");

	Params::NoceFunctionLibrary_IsProgressConditionMatch Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InProgressCondition = std::move(InProgressCondition);
	Parms.ExactProgress = ExactProgress;
	Parms.InNeedAddTag = std::move(InNeedAddTag);
	Parms.NeedAllAddTag = NeedAllAddTag;
	Parms.NeedAddTagNum = NeedAddTagNum;
	Parms.InWithoutAddTag = std::move(InWithoutAddTag);
	Parms.WithoutAllTag = WithoutAllTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.IsShowDebugInfoForRBANBlending
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::IsShowDebugInfoForRBANBlending(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "IsShowDebugInfoForRBANBlending");

	Params::NoceFunctionLibrary_IsShowDebugInfoForRBANBlending Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.KawaiiWarmUpForCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WarmUpFrames                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::KawaiiWarmUpForCharacter(class ANoceCharacter* InCharacter, int32 WarmUpFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "KawaiiWarmUpForCharacter");

	Params::NoceFunctionLibrary_KawaiiWarmUpForCharacter Parms{};

	Parms.InCharacter = InCharacter;
	Parms.WarmUpFrames = WarmUpFrames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.MessageOpen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::MessageOpen(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "MessageOpen");

	Params::NoceFunctionLibrary_MessageOpen Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.MRQ_TriggerPlayStart
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           InSeq                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::MRQ_TriggerPlayStart(const struct FSoftObjectPath& InSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "MRQ_TriggerPlayStart");

	Params::NoceFunctionLibrary_MRQ_TriggerPlayStart Parms{};

	Parms.InSeq = std::move(InSeq);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.Noce_Seq_Trace_BookMark
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InLogString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::Noce_Seq_Trace_BookMark(class UObject* WorldContextObject, const class FString& InLogString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "Noce_Seq_Trace_BookMark");

	Params::NoceFunctionLibrary_Noce_Seq_Trace_BookMark Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLogString = std::move(InLogString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.Noce_Trace_BookMark
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InLogString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::Noce_Trace_BookMark(const class FString& InLogString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "Noce_Trace_BookMark");

	Params::NoceFunctionLibrary_Noce_Trace_BookMark Parms{};

	Parms.InLogString = std::move(InLogString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.NoceCapsuleTraceSingleForObjectsFirstBlock
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       BlockChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkipTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::NoceCapsuleTraceSingleForObjectsFirstBlock(const class UObject* WorldContextObject, ECollisionChannel BlockChannel, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, class FName SkipTag, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "NoceCapsuleTraceSingleForObjectsFirstBlock");

	Params::NoceFunctionLibrary_NoceCapsuleTraceSingleForObjectsFirstBlock Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BlockChannel = BlockChannel;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.SkipTag = SkipTag;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.NoceLineTraceSingleForObjectsFirstBlock
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       BlockChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkipTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::NoceLineTraceSingleForObjectsFirstBlock(const class UObject* WorldContextObject, ECollisionChannel BlockChannel, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, class FName SkipTag, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "NoceLineTraceSingleForObjectsFirstBlock");

	Params::NoceFunctionLibrary_NoceLineTraceSingleForObjectsFirstBlock Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BlockChannel = BlockChannel;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.SkipTag = SkipTag;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.NoceSphereTraceSingleForObjectsFirstBlock
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       BlockChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkipTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceFunctionLibrary::NoceSphereTraceSingleForObjectsFirstBlock(const class UObject* WorldContextObject, ECollisionChannel BlockChannel, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, class FName SkipTag, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "NoceSphereTraceSingleForObjectsFirstBlock");

	Params::NoceFunctionLibrary_NoceSphereTraceSingleForObjectsFirstBlock Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BlockChannel = BlockChannel;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.SkipTag = SkipTag;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.PlayerScarfResetDynmaics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANocePlayerCharacter*             InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeleportType                           TeleportType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::PlayerScarfResetDynmaics(class ANocePlayerCharacter* InPlayer, ETeleportType TeleportType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "PlayerScarfResetDynmaics");

	Params::NoceFunctionLibrary_PlayerScarfResetDynmaics Parms{};

	Parms.InPlayer = InPlayer;
	Parms.TeleportType = TeleportType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.PlayerSkirtResetDynmaics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANocePlayerCharacter*             InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeleportType                           TeleportType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::PlayerSkirtResetDynmaics(class ANocePlayerCharacter* InPlayer, ETeleportType TeleportType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "PlayerSkirtResetDynmaics");

	Params::NoceFunctionLibrary_PlayerSkirtResetDynmaics Parms{};

	Parms.InPlayer = InPlayer;
	Parms.TeleportType = TeleportType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ProcessSolveLumenGhostingCmds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InSeqName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ProcessSolveLumenGhostingCmds(const class FName& InSeqName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ProcessSolveLumenGhostingCmds");

	Params::NoceFunctionLibrary_ProcessSolveLumenGhostingCmds Parms{};

	Parms.InSeqName = InSeqName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.RandomFloatRange_ThreadSafe
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceFunctionLibrary::RandomFloatRange_ThreadSafe(float InSeed, float InMin, float InMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "RandomFloatRange_ThreadSafe");

	Params::NoceFunctionLibrary_RandomFloatRange_ThreadSafe Parms{};

	Parms.InSeed = InSeed;
	Parms.InMin = InMin;
	Parms.InMax = InMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.RefreshNoceLightSavableData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ULightComponent*            InLightComp                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLightSavableData&           OutData                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::RefreshNoceLightSavableData(const class UObject* WorldContextObject, const class ULightComponent* InLightComp, struct FNoceLightSavableData& OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "RefreshNoceLightSavableData");

	Params::NoceFunctionLibrary_RefreshNoceLightSavableData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLightComp = InLightComp;
	Parms.OutData = std::move(OutData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutData = std::move(Parms.OutData);
}


// Function GameNoce.NoceFunctionLibrary.ReplacePlayerCharMaterialByCharMeshType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReplaceMatIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               DefaultMat                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               PureWhite                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               PinkRabbit                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ReplacePlayerCharMaterialByCharMeshType(class USkeletalMeshComponent* InComp, int32 ReplaceMatIndex, class UMaterialInterface* DefaultMat, class UMaterialInterface* PureWhite, class UMaterialInterface* PinkRabbit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ReplacePlayerCharMaterialByCharMeshType");

	Params::NoceFunctionLibrary_ReplacePlayerCharMaterialByCharMeshType Parms{};

	Parms.InComp = InComp;
	Parms.ReplaceMatIndex = ReplaceMatIndex;
	Parms.DefaultMat = DefaultMat;
	Parms.PureWhite = PureWhite;
	Parms.PinkRabbit = PinkRabbit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.RequestGameplayTagFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InData                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceFunctionLibrary::RequestGameplayTagFromString(const class FString& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "RequestGameplayTagFromString");

	Params::NoceFunctionLibrary_RequestGameplayTagFromString Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.ResetConsoleCmdFromSeqData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceSeqData&              InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ResetConsoleCmdFromSeqData(const struct FNoceSeqData& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetConsoleCmdFromSeqData");

	Params::NoceFunctionLibrary_ResetConsoleCmdFromSeqData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ResetDynamics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeleportType                           InTeleportType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ResetDynamics(class ANoceCharacter* InCharacter, ETeleportType InTeleportType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetDynamics");

	Params::NoceFunctionLibrary_ResetDynamics Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InTeleportType = InTeleportType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ResetEnableHDROutput
// (Final, Native, Static, Public, BlueprintCallable)

void UNoceFunctionLibrary::ResetEnableHDROutput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetEnableHDROutput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ResetHDRUICompositeMode
// (Final, Native, Static, Public, BlueprintCallable)

void UNoceFunctionLibrary::ResetHDRUICompositeMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetHDRUICompositeMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ResetHDRUILevel
// (Final, Native, Static, Public, BlueprintCallable)

void UNoceFunctionLibrary::ResetHDRUILevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetHDRUILevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.ResetSolveLumenGhostingCmds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InSeqName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::ResetSolveLumenGhostingCmds(const class FName& InSeqName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "ResetSolveLumenGhostingCmds");

	Params::NoceFunctionLibrary_ResetSolveLumenGhostingCmds Parms{};

	Parms.InSeqName = InSeqName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SearchActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InSelfActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    DebugDraw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SearchActors(class UObject* WorldContextObject, class AActor* InSelfActor, const struct FVector& InDirection, float InRadius, float InHalfAngle, const TArray<EObjectTypeQuery>& ObjectTypes, TArray<class AActor*>* OutActors, bool DebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SearchActors");

	Params::NoceFunctionLibrary_SearchActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSelfActor = InSelfActor;
	Parms.InDirection = std::move(InDirection);
	Parms.InRadius = InRadius;
	Parms.InHalfAngle = InHalfAngle;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.DebugDraw = DebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function GameNoce.NoceFunctionLibrary.SearchEnemy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InSelfActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InCountableTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor**                          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNocePlayerLookAtTargetComponent**OutLookAtTarget                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DebugDraw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForMotionWarp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SearchEnemy(class UObject* WorldContextObject, class AActor* InSelfActor, float InRadius, float InHalfAngle, const struct FGameplayTag& InCountableTag, class AActor** OutActor, class UNocePlayerLookAtTargetComponent** OutLookAtTarget, bool DebugDraw, bool InForMotionWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SearchEnemy");

	Params::NoceFunctionLibrary_SearchEnemy Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSelfActor = InSelfActor;
	Parms.InRadius = InRadius;
	Parms.InHalfAngle = InHalfAngle;
	Parms.InCountableTag = std::move(InCountableTag);
	Parms.DebugDraw = DebugDraw;
	Parms.InForMotionWarp = InForMotionWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	if (OutLookAtTarget != nullptr)
		*OutLookAtTarget = Parms.OutLookAtTarget;
}


// Function GameNoce.NoceFunctionLibrary.SearchEnemyWithDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InSelfActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InCountableTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor**                          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNocePlayerLookAtTargetComponent**OutLookAtTarget                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DebugDraw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForMotionWarp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SearchEnemyWithDirection(class UObject* WorldContextObject, class AActor* InSelfActor, const struct FVector& InDirection, float InRadius, float InHalfAngle, const struct FGameplayTag& InCountableTag, class AActor** OutActor, class UNocePlayerLookAtTargetComponent** OutLookAtTarget, bool DebugDraw, bool InForMotionWarp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SearchEnemyWithDirection");

	Params::NoceFunctionLibrary_SearchEnemyWithDirection Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSelfActor = InSelfActor;
	Parms.InDirection = std::move(InDirection);
	Parms.InRadius = InRadius;
	Parms.InHalfAngle = InHalfAngle;
	Parms.InCountableTag = std::move(InCountableTag);
	Parms.DebugDraw = DebugDraw;
	Parms.InForMotionWarp = InForMotionWarp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	if (OutLookAtTarget != nullptr)
		*OutLookAtTarget = Parms.OutLookAtTarget;
}


// Function GameNoce.NoceFunctionLibrary.SetActiveEffectHandleInvalid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle&     InEffectHandle                                         (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetActiveEffectHandleInvalid(struct FActiveGameplayEffectHandle& InEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetActiveEffectHandleInvalid");

	Params::NoceFunctionLibrary_SetActiveEffectHandleInvalid Parms{};

	Parms.InEffectHandle = std::move(InEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InEffectHandle = std::move(Parms.InEffectHandle);
}


// Function GameNoce.NoceFunctionLibrary.SetConstraintProfileForAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefaultIfNotFound                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetConstraintProfileForAll(class UAnimInstance* Instance, class FName ProfileName, bool bDefaultIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetConstraintProfileForAll");

	Params::NoceFunctionLibrary_SetConstraintProfileForAll Parms{};

	Parms.Instance = Instance;
	Parms.ProfileName = ProfileName;
	Parms.bDefaultIfNotFound = bDefaultIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetCVarWithCurrentPriority
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InCVarName                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InCVarValue                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetCVarWithCurrentPriority(const class FString& InCVarName, const class FString& InCVarValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetCVarWithCurrentPriority");

	Params::NoceFunctionLibrary_SetCVarWithCurrentPriority Parms{};

	Parms.InCVarName = std::move(InCVarName);
	Parms.InCVarValue = std::move(InCVarValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetEnableHDROutput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetEnableHDROutput(bool InIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetEnableHDROutput");

	Params::NoceFunctionLibrary_SetEnableHDROutput Parms{};

	Parms.InIsEnable = InIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetEventMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEventModeType                      EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceCineEventUserType                  CineEventUserType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetEventMode(const class UObject* WorldContextObject, bool IsEnable, ENoceEventModeType EventType, ENoceCineEventUserType CineEventUserType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetEventMode");

	Params::NoceFunctionLibrary_SetEventMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IsEnable = IsEnable;
	Parms.EventType = EventType;
	Parms.CineEventUserType = CineEventUserType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetGlobalTimeDilationMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDilationMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetGlobalTimeDilationMultiplier(const class UObject* WorldContextObject, float TimeDilationMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetGlobalTimeDilationMultiplier");

	Params::NoceFunctionLibrary_SetGlobalTimeDilationMultiplier Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TimeDilationMultiplier = TimeDilationMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetHDRUICompositeMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetHDRUICompositeMode(bool InIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetHDRUICompositeMode");

	Params::NoceFunctionLibrary_SetHDRUICompositeMode Parms{};

	Parms.InIsEnable = InIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetHDRUILevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetHDRUILevel(float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetHDRUILevel");

	Params::NoceFunctionLibrary_SetHDRUILevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceCustomPrimitiveDataFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceCustomPrimitiveDataFloat(class UPrimitiveComponent* InComp, int32 DataIndex, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceCustomPrimitiveDataFloat");

	Params::NoceFunctionLibrary_SetNoceCustomPrimitiveDataFloat Parms{};

	Parms.InComp = InComp;
	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceCustomPrimitiveDataVector2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceCustomPrimitiveDataVector2(class UPrimitiveComponent* InComp, int32 DataIndex, const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceCustomPrimitiveDataVector2");

	Params::NoceFunctionLibrary_SetNoceCustomPrimitiveDataVector2 Parms{};

	Parms.InComp = InComp;
	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceCustomPrimitiveDataVector3
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceCustomPrimitiveDataVector3(class UPrimitiveComponent* InComp, int32 DataIndex, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceCustomPrimitiveDataVector3");

	Params::NoceFunctionLibrary_SetNoceCustomPrimitiveDataVector3 Parms{};

	Parms.InComp = InComp;
	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceCustomPrimitiveDataVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceCustomPrimitiveDataVector4(class UPrimitiveComponent* InComp, int32 DataIndex, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceCustomPrimitiveDataVector4");

	Params::NoceFunctionLibrary_SetNoceCustomPrimitiveDataVector4 Parms{};

	Parms.InComp = InComp;
	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceScalarParameterForCustomPrimitiveData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceScalarParameterForCustomPrimitiveData(class UPrimitiveComponent* InComp, class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceScalarParameterForCustomPrimitiveData");

	Params::NoceFunctionLibrary_SetNoceScalarParameterForCustomPrimitiveData Parms{};

	Parms.InComp = InComp;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetNoceVectorParameterForCustomPrimitiveData
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetNoceVectorParameterForCustomPrimitiveData(class UPrimitiveComponent* InComp, class FName ParameterName, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetNoceVectorParameterForCustomPrimitiveData");

	Params::NoceFunctionLibrary_SetNoceVectorParameterForCustomPrimitiveData Parms{};

	Parms.InComp = InComp;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetPhysicsAssetCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionEnabled                       InCollisionEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetPhysicsAssetCollision(class USkeletalMeshComponent* InSkeletalMesh, class FName InBoneName, ECollisionEnabled InCollisionEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetPhysicsAssetCollision");

	Params::NoceFunctionLibrary_SetPhysicsAssetCollision Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneName = InBoneName;
	Parms.InCollisionEnabled = InCollisionEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetPhysicsAssetCollisions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InBoneNames                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ECollisionEnabled                       InCollisionEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetPhysicsAssetCollisions(class USkeletalMeshComponent* InSkeletalMesh, const TArray<class FName>& InBoneNames, ECollisionEnabled InCollisionEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetPhysicsAssetCollisions");

	Params::NoceFunctionLibrary_SetPhysicsAssetCollisions Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.InBoneNames = std::move(InBoneNames);
	Parms.InCollisionEnabled = InCollisionEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetPlaySequenceStateSeqActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InSeqActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetPlaySequenceStateSeqActor(const class UObject* WorldContextObject, class AActor* InSeqActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetPlaySequenceStateSeqActor");

	Params::NoceFunctionLibrary_SetPlaySequenceStateSeqActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSeqActor = InSeqActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetSkeletalMeshAssetAndClearOverrideMat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    NewMesh                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetSkeletalMeshAssetAndClearOverrideMat(class USkeletalMeshComponent* InComp, class USkeletalMesh* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetSkeletalMeshAssetAndClearOverrideMat");

	Params::NoceFunctionLibrary_SetSkeletalMeshAssetAndClearOverrideMat Parms{};

	Parms.InComp = InComp;
	Parms.NewMesh = NewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SetStaticMeshAssetAndClearOverrideMat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      NewMesh                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SetStaticMeshAssetAndClearOverrideMat(class UStaticMeshComponent* InComp, class UStaticMesh* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SetStaticMeshAssetAndClearOverrideMat");

	Params::NoceFunctionLibrary_SetStaticMeshAssetAndClearOverrideMat Parms{};

	Parms.InComp = InComp;
	Parms.NewMesh = NewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SolvePhysicsPopping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   InChar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KawaiiWarmUpFrame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetPhysics                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SolvePhysicsPopping(class ANoceCharacter* InChar, int32 KawaiiWarmUpFrame, bool bResetPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SolvePhysicsPopping");

	Params::NoceFunctionLibrary_SolvePhysicsPopping Parms{};

	Parms.InChar = InChar;
	Parms.KawaiiWarmUpFrame = KawaiiWarmUpFrame;
	Parms.bResetPhysics = bResetPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.SolveSeamlessSeqBeginCopyPose
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkelComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetPhysics                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::SolveSeamlessSeqBeginCopyPose(class USkeletalMeshComponent* InSkelComp, bool bResetPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "SolveSeamlessSeqBeginCopyPose");

	Params::NoceFunctionLibrary_SolveSeamlessSeqBeginCopyPose Parms{};

	Parms.InSkelComp = InSkelComp;
	Parms.bResetPhysics = bResetPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.StoryEndingBitToGameRound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   EndingBitmask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceRoundType UNoceFunctionLibrary::StoryEndingBitToGameRound(int32 EndingBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "StoryEndingBitToGameRound");

	Params::NoceFunctionLibrary_StoryEndingBitToGameRound Parms{};

	Parms.EndingBitmask = EndingBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.String_Remove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InData                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InSuffix                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchDir                              SearchDir                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::String_Remove(const class FString& InData, const class FString& InSuffix, ESearchDir SearchDir, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "String_Remove");

	Params::NoceFunctionLibrary_String_Remove Parms{};

	Parms.InData = std::move(InData);
	Parms.InSuffix = std::move(InSuffix);
	Parms.SearchDir = SearchDir;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.TimeSecondsToMMSSString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             InSeconds                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInFloor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceFunctionLibrary::TimeSecondsToMMSSString(const float InSeconds, const bool bInFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "TimeSecondsToMMSSString");

	Params::NoceFunctionLibrary_TimeSecondsToMMSSString Parms{};

	Parms.InSeconds = InSeconds;
	Parms.bInFloor = bInFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceFunctionLibrary.UnlockFOV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UnlockFOV(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UnlockFOV");

	Params::NoceFunctionLibrary_UnlockFOV Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UnsetConsoleCommandWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InTagName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UnsetConsoleCommandWithTag(const class FString& Command, const class FName& InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UnsetConsoleCommandWithTag");

	Params::NoceFunctionLibrary_UnsetConsoleCommandWithTag Parms{};

	Parms.Command = std::move(Command);
	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UnsetSeqDataCmdWithTagForHighSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InTagName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UnsetSeqDataCmdWithTagForHighSpec(const class FString& Command, const class FName& InTagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UnsetSeqDataCmdWithTagForHighSpec");

	Params::NoceFunctionLibrary_UnsetSeqDataCmdWithTagForHighSpec Parms{};

	Parms.Command = std::move(Command);
	Parms.InTagName = InTagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UpdateEveLightSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InSetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoNotSwitchDataLayer                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UpdateEveLightSet(const class UObject* WorldContextObject, const class FString& InSetName, bool bDoNotSwitchDataLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UpdateEveLightSet");

	Params::NoceFunctionLibrary_UpdateEveLightSet Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSetName = std::move(InSetName);
	Parms.bDoNotSwitchDataLayer = bDoNotSwitchDataLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UpdateNoceLightCompPropertyFromSaveData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULightComponent*                  OutLightComp                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceLightSavableData&     InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UpdateNoceLightCompPropertyFromSaveData(const class UObject* WorldContextObject, class ULightComponent* OutLightComp, const struct FNoceLightSavableData& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UpdateNoceLightCompPropertyFromSaveData");

	Params::NoceFunctionLibrary_UpdateNoceLightCompPropertyFromSaveData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OutLightComp = OutLightComp;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UpdateSeqDataAssetDataLayerForPreloadingSeq
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class ULevelSequence>    PlaySeq                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UpdateSeqDataAssetDataLayerForPreloadingSeq(TSoftObjectPtr<class ULevelSequence> PlaySeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UpdateSeqDataAssetDataLayerForPreloadingSeq");

	Params::NoceFunctionLibrary_UpdateSeqDataAssetDataLayerForPreloadingSeq Parms{};

	Parms.PlaySeq = PlaySeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UpdateSlotWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UAnimInstance*              InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UpdateSlotWeight(const class UAnimInstance* InAnimInstance, class FName SlotNodeName, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UpdateSlotWeight");

	Params::NoceFunctionLibrary_UpdateSlotWeight Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.SlotNodeName = SlotNodeName;
	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.UpdateWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UAnimInstance*              InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimMontage*               InMontage                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::UpdateWeight(const class UAnimInstance* InAnimInstance, const class UAnimMontage* InMontage, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "UpdateWeight");

	Params::NoceFunctionLibrary_UpdateWeight Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.InMontage = InMontage;
	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.VolumetricFogHistoryWeightOff
// (Final, Native, Static, Public, BlueprintCallable)

void UNoceFunctionLibrary::VolumetricFogHistoryWeightOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "VolumetricFogHistoryWeightOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceFunctionLibrary.VolumetricFogHistoryWeightOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceFunctionLibrary::VolumetricFogHistoryWeightOn(float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceFunctionLibrary", "VolumetricFogHistoryWeightOn");

	Params::NoceFunctionLibrary_VolumetricFogHistoryWeightOn Parms{};

	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameClockSubsystem.GetPlayTimeSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UNoceGameClockSubsystem::GetPlayTimeSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameClockSubsystem", "GetPlayTimeSeconds");

	Params::NoceGameClockSubsystem_GetPlayTimeSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameClockSubsystem.GetPlayTimespanWithoutEvent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UNoceGameClockSubsystem::GetPlayTimespanWithoutEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameClockSubsystem", "GetPlayTimespanWithoutEvent");

	Params::NoceGameClockSubsystem_GetPlayTimespanWithoutEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameClockSubsystem.GetPlayTimespawn
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UNoceGameClockSubsystem::GetPlayTimespawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameClockSubsystem", "GetPlayTimespawn");

	Params::NoceGameClockSubsystem_GetPlayTimespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.AddGameOverCount
// (Final, Native, Public, BlueprintCallable)

void UNoceGameInstance::AddGameOverCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "AddGameOverCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameInstance.AddViewdEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InEventName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGameInstance::AddViewdEvent(class FName InEventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "AddViewdEvent");

	Params::NoceGameInstance_AddViewdEvent Parms{};

	Parms.InEventName = InEventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameInstance.Clear
// (Final, Native, Public, BlueprintCallable)

void UNoceGameInstance::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameInstance.GetAvailableOutfits
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<ENocePlayerOutfit>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ENocePlayerOutfit> UNoceGameInstance::GetAvailableOutfits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "GetAvailableOutfits");

	Params::NoceGameInstance_GetAvailableOutfits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.GetInitProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceGameInstance::GetInitProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "GetInitProgressTag");

	Params::NoceGameInstance_GetInitProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.GetPeriodGameOverCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceGameInstance::GetPeriodGameOverCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "GetPeriodGameOverCount");

	Params::NoceGameInstance_GetPeriodGameOverCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.HandleApplicationHasReactivated
// (Final, Native, Public, BlueprintCallable)

void UNoceGameInstance::HandleApplicationHasReactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "HandleApplicationHasReactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameInstance.HandleApplicationWillDeactivate
// (Final, Native, Public, BlueprintCallable)

void UNoceGameInstance::HandleApplicationWillDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "HandleApplicationWillDeactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameInstance.HasAvailableOutfit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerOutfit                       OutfitType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameInstance::HasAvailableOutfit(ENocePlayerOutfit OutfitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "HasAvailableOutfit");

	Params::NoceGameInstance_HasAvailableOutfit Parms{};

	Parms.OutfitType = OutfitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.HasBoosterPack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameInstance::HasBoosterPack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "HasBoosterPack");

	Params::NoceGameInstance_HasBoosterPack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.HasLimitedOmamori
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameInstance::HasLimitedOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "HasLimitedOmamori");

	Params::NoceGameInstance_HasLimitedOmamori Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.IsViewdEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InEventName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameInstance::IsViewdEvent(class FName InEventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "IsViewdEvent");

	Params::NoceGameInstance_IsViewdEvent Parms{};

	Parms.InEventName = InEventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameInstance.ResetPeriodGameOverCount
// (Final, Native, Public, BlueprintCallable)

void UNoceGameInstance::ResetPeriodGameOverCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameInstance", "ResetPeriodGameOverCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLinkMotionComponent.CanLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELinkPriority                           InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::CanLink(ELinkPriority InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "CanLink");

	Params::NoceLinkMotionComponent_CanLink Parms{};

	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.EndConstPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRestoreRuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLinkMotionComponent::EndConstPosition(float InRestoreRuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "EndConstPosition");

	Params::NoceLinkMotionComponent_EndConstPosition Parms{};

	Parms.InRestoreRuration = InRestoreRuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLinkMotionComponent.EndLinkMotion
// (Final, Native, Public, BlueprintCallable)

void UNoceLinkMotionComponent::EndLinkMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "EndLinkMotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLinkMotionComponent.GetCurrentLinkPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELinkPriority                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELinkPriority UNoceLinkMotionComponent::GetCurrentLinkPriority()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "GetCurrentLinkPriority");

	Params::NoceLinkMotionComponent_GetCurrentLinkPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.GetLinkAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbilityName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayAbility> UNoceLinkMotionComponent::GetLinkAbility(class AActor* TargetActor, class FName AbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "GetLinkAbility");

	Params::NoceLinkMotionComponent_GetLinkAbility Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AbilityName = AbilityName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.GetLinkOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceLinkMotionComponent::GetLinkOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "GetLinkOwner");

	Params::NoceLinkMotionComponent_GetLinkOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.GetLinkTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceLinkMotionComponent::GetLinkTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "GetLinkTarget");

	Params::NoceLinkMotionComponent_GetLinkTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.GetTargetStartMotion
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32*                                  BankID                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  MotionID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLinkMotionComponent::GetTargetStartMotion(int32* BankID, int32* MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "GetTargetStartMotion");

	Params::NoceLinkMotionComponent_GetTargetStartMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BankID != nullptr)
		*BankID = Parms.BankID;

	if (MotionID != nullptr)
		*MotionID = Parms.MotionID;
}


// Function GameNoce.NoceLinkMotionComponent.IsConstPositionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::IsConstPositionActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "IsConstPositionActive");

	Params::NoceLinkMotionComponent_IsConstPositionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.IsCurrentExecutionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::IsCurrentExecutionType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "IsCurrentExecutionType");

	Params::NoceLinkMotionComponent_IsCurrentExecutionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.NotifyInterrupted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::NotifyInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "NotifyInterrupted");

	Params::NoceLinkMotionComponent_NotifyInterrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.NotifyStartLinkMotion
// (Final, Native, Public, BlueprintCallable)

void UNoceLinkMotionComponent::NotifyStartLinkMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "NotifyStartLinkMotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLinkMotionComponent.RequestAttackerLinkAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceCharacter*                   LinkTarget                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ExAbilityName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::RequestAttackerLinkAbility(class ANoceCharacter* LinkTarget, class FName ExAbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "RequestAttackerLinkAbility");

	Params::NoceLinkMotionComponent_RequestAttackerLinkAbility Parms{};

	Parms.LinkTarget = LinkTarget;
	Parms.ExAbilityName = ExAbilityName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.RequestLinkMotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULinkRequest*                     InReuest                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::RequestLinkMotion(class ULinkRequest* InReuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "RequestLinkMotion");

	Params::NoceLinkMotionComponent_RequestLinkMotion Parms{};

	Parms.InReuest = InReuest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.RequestReject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LinkTarget                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLinkMotionComponent::RequestReject(class AActor* LinkTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "RequestReject");

	Params::NoceLinkMotionComponent_RequestReject Parms{};

	Parms.LinkTarget = LinkTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLinkMotionComponent.StartConstLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    EnableSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLinkMotionComponent::StartConstLocation(const struct FVector& Location, const struct FRotator& Rotator, float BlendTime, bool EnableSweep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "StartConstLocation");

	Params::NoceLinkMotionComponent_StartConstLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);
	Parms.BlendTime = BlendTime;
	Parms.EnableSweep = EnableSweep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLinkMotionComponent.StartConstPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       ConstTarget                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ConstBoneOwner                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ConstBoneName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  ConstOffsetRot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   ConstOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceConstPositionMode                  ConstMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    EnableSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLinkMotionComponent::StartConstPosition(class ACharacter* ConstTarget, class ACharacter* ConstBoneOwner, class FName ConstBoneName, const struct FRotator& ConstOffsetRot, const struct FVector& ConstOffset, ENoceConstPositionMode ConstMode, float BlendTime, bool EnableSweep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLinkMotionComponent", "StartConstPosition");

	Params::NoceLinkMotionComponent_StartConstPosition Parms{};

	Parms.ConstTarget = ConstTarget;
	Parms.ConstBoneOwner = ConstBoneOwner;
	Parms.ConstBoneName = ConstBoneName;
	Parms.ConstOffsetRot = std::move(ConstOffsetRot);
	Parms.ConstOffset = std::move(ConstOffset);
	Parms.ConstMode = ConstMode;
	Parms.BlendTime = BlendTime;
	Parms.EnableSweep = EnableSweep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.AnyStoryEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameMode::AnyStoryEndingCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "AnyStoryEndingCleared");

	Params::NoceGameMode_AnyStoryEndingCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.CanEnterGameOverFlow
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameMode::CanEnterGameOverFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "CanEnterGameOverFlow");

	Params::NoceGameMode_CanEnterGameOverFlow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.EnableBasicDebugInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::EnableBasicDebugInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "EnableBasicDebugInfo");

	Params::NoceGameMode_EnableBasicDebugInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.GetAttackRightMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceGameMode::GetAttackRightMaxCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "GetAttackRightMaxCount");

	Params::NoceGameMode_GetAttackRightMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.GetAttackRightMaxCount_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANoceGameMode::GetAttackRightMaxCount_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "GetAttackRightMaxCount_BP");

	Params::NoceGameMode_GetAttackRightMaxCount_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.GetPlayerCharacterByType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerCharacter*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerCharacter* ANoceGameMode::GetPlayerCharacterByType(ENocePlayerType InPlayerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "GetPlayerCharacterByType");

	Params::NoceGameMode_GetPlayerCharacterByType Parms{};

	Parms.InPlayerType = InPlayerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.IsStoryEndingCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameMode::IsStoryEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "IsStoryEndingCleared");

	Params::NoceGameMode_IsStoryEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.IsWaitForRevive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameMode::IsWaitForRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "IsWaitForRevive");

	Params::NoceGameMode_IsWaitForRevive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameMode.OnDynamicShadowEnableTimerUp
// (Final, Native, Protected)

void ANoceGameMode::OnDynamicShadowEnableTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "OnDynamicShadowEnableTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.OnGameInitializeBP
// (Native, Event, Public, BlueprintEvent)

void ANoceGameMode::OnGameInitializeBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "OnGameInitializeBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.OnInitGameBP
// (Native, Event, Public, BlueprintEvent)

void ANoceGameMode::OnInitGameBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "OnInitGameBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.OnPlayerReady
// (Final, Native, Public, BlueprintCallable)

void ANoceGameMode::OnPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "OnPlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.OnStreamingFinish
// (Final, Native, Public, BlueprintCallable)

void ANoceGameMode::OnStreamingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "OnStreamingFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.RegisterPlayerCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerCharacter*             InPlayerCharacter                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::RegisterPlayerCharacter(ENocePlayerType InPlayerType, class ANocePlayerCharacter* InPlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "RegisterPlayerCharacter");

	Params::NoceGameMode_RegisterPlayerCharacter Parms{};

	Parms.InPlayerType = InPlayerType;
	Parms.InPlayerCharacter = InPlayerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.RequestGameOver
// (Final, Native, Public, BlueprintCallable)

void ANoceGameMode::RequestGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "RequestGameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.RequestGameOver_BP
// (Event, Public, BlueprintEvent)

void ANoceGameMode::RequestGameOver_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "RequestGameOver_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGameMode.RequestRestartMyGame
// (Final, Native, Public, BlueprintCallable)

void ANoceGameMode::RequestRestartMyGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "RequestRestartMyGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.RequestRestartMyGame_BP
// (Event, Public, BlueprintEvent)

void ANoceGameMode::RequestRestartMyGame_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "RequestRestartMyGame_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGameMode.SetDebugPlayerAutoRevive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::SetDebugPlayerAutoRevive(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "SetDebugPlayerAutoRevive");

	Params::NoceGameMode_SetDebugPlayerAutoRevive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.SetDebugPlayerAutoRevive_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::SetDebugPlayerAutoRevive_BP(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "SetDebugPlayerAutoRevive_BP");

	Params::NoceGameMode_SetDebugPlayerAutoRevive_BP Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceGameMode.SetEnableGameOverFlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::SetEnableGameOverFlow(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "SetEnableGameOverFlow");

	Params::NoceGameMode_SetEnableGameOverFlow Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.SetStoryEndingCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::SetStoryEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "SetStoryEndingCleared");

	Params::NoceGameMode_SetStoryEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.SetWaitForRevive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceGameMode::SetWaitForRevive(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "SetWaitForRevive");

	Params::NoceGameMode_SetWaitForRevive Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.ToggleDebugInfo
// (Final, Native, Public, BlueprintCallable)

void ANoceGameMode::ToggleDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "ToggleDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameMode.IsInitializeCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameMode::IsInitializeCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameMode", "IsInitializeCompleted");

	Params::NoceGameMode_IsInitializeCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOptionListItem.OnDisableChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceOptionListItem::OnDisableChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionListItem", "OnDisableChanged");

	Params::NoceOptionListItem_OnDisableChanged Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOptionListItem.OnSettingChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceOptionListItem::OnSettingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionListItem", "OnSettingChanged");

	Params::NoceOptionListItem_OnSettingChanged Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceOptionListItem.RefreshText
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceOptionListItem::RefreshText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOptionListItem", "RefreshText");

	Params::NoceOptionListItem_RefreshText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.AddAdditionalProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceProgressType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::AddAdditionalProgressTag(const struct FGameplayTag& InTag, ENoceProgressType InType, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "AddAdditionalProgressTag");

	Params::NoceGameProgressComponent_AddAdditionalProgressTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InType = InType;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.GetAdditionalProgressTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UNoceGameProgressComponent::GetAdditionalProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "GetAdditionalProgressTag");

	Params::NoceGameProgressComponent_GetAdditionalProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.GetHistoryAdditionalProgressTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UNoceGameProgressComponent::GetHistoryAdditionalProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "GetHistoryAdditionalProgressTag");

	Params::NoceGameProgressComponent_GetHistoryAdditionalProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.GetHistoryProgressTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UNoceGameProgressComponent::GetHistoryProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "GetHistoryProgressTag");

	Params::NoceGameProgressComponent_GetHistoryProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.GetProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceGameProgressComponent::GetProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "GetProgressTag");

	Params::NoceGameProgressComponent_GetProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.GetStateMachineProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNoceGameProgressComponent::GetStateMachineProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "GetStateMachineProgressTag");

	Params::NoceGameProgressComponent_GetStateMachineProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.HasAdditionalTagInHistory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::HasAdditionalTagInHistory(const struct FGameplayTag& InTag, bool ExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "HasAdditionalTagInHistory");

	Params::NoceGameProgressComponent_HasAdditionalTagInHistory Parms{};

	Parms.InTag = std::move(InTag);
	Parms.ExactMatch = ExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.HasAllAdditionalTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InTagContainer                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::HasAllAdditionalTag(const struct FGameplayTagContainer& InTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "HasAllAdditionalTag");

	Params::NoceGameProgressComponent_HasAllAdditionalTag Parms{};

	Parms.InTagContainer = std::move(InTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.HasAnyAdditionalTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InTagContainer                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::HasAnyAdditionalTag(const struct FGameplayTagContainer& InTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "HasAnyAdditionalTag");

	Params::NoceGameProgressComponent_HasAnyAdditionalTag Parms{};

	Parms.InTagContainer = std::move(InTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.HasTagInHistory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExactMatch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::HasTagInHistory(const struct FGameplayTag& InTag, bool ExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "HasTagInHistory");

	Params::NoceGameProgressComponent_HasTagInHistory Parms{};

	Parms.InTag = std::move(InTag);
	Parms.ExactMatch = ExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.OnProgressStateBegin
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              StartCondition                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGameProgressComponent::OnProgressStateBegin(const struct FGameplayTag& StartCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "OnProgressStateBegin");

	Params::NoceGameProgressComponent_OnProgressStateBegin Parms{};

	Parms.StartCondition = std::move(StartCondition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameProgressComponent.RefreshDataLayerStatus
// (Final, Native, Public, BlueprintCallable)

void UNoceGameProgressComponent::RefreshDataLayerStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "RefreshDataLayerStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameProgressComponent.RemoveAdditionalProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::RemoveAdditionalProgressTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "RemoveAdditionalProgressTag");

	Params::NoceGameProgressComponent_RemoveAdditionalProgressTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.RemoveAdditionalProgressTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InTagContainer                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::RemoveAdditionalProgressTags(const struct FGameplayTagContainer& InTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "RemoveAdditionalProgressTags");

	Params::NoceGameProgressComponent_RemoveAdditionalProgressTags Parms{};

	Parms.InTagContainer = std::move(InTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressComponent.SetProgressTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceProgressType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGameProgressComponent::SetProgressTag(const struct FGameplayTag& InTag, ENoceProgressType InType, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameProgressComponent", "SetProgressTag");

	Params::NoceGameProgressComponent_SetProgressTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InType = InType;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalPlayer.GetSharedSettings
// (Final, Native, Public)
// Parameters:
// class UNoceSystemSaveGame*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceSystemSaveGame* UNoceLocalPlayer::GetSharedSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalPlayer", "GetSharedSettings");

	Params::NoceLocalPlayer_GetSharedSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalPlayer.GetLocalSettings
// (Final, Native, Public, Const)
// Parameters:
// class UNoceLocalGameUserSettings*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceLocalGameUserSettings* UNoceLocalPlayer::GetLocalSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalPlayer", "GetLocalSettings");

	Params::NoceLocalPlayer_GetLocalSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookTabWidget.GetCurrentTabType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceNotebookType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceNotebookType UNoceNotebookTabWidget::GetCurrentTabType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookTabWidget", "GetCurrentTabType");

	Params::NoceNotebookTabWidget_GetCurrentTabType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookTabWidget.ResetList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceNotebookType                       DefaultType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookTabWidget::ResetList(ENoceNotebookType DefaultType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookTabWidget", "ResetList");

	Params::NoceNotebookTabWidget_ResetList Parms{};

	Parms.DefaultType = DefaultType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameProgressInterface.AddAdditionalProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceProgressType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::AddAdditionalProgressTag(const struct FGameplayTag& InTag, ENoceProgressType InType, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "AddAdditionalProgressTag");

	Params::NoceGameProgressInterface_AddAdditionalProgressTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InType = InType;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetAdditionalProgressTagContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer INoceGameProgressInterface::GetAdditionalProgressTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetAdditionalProgressTagContainer");

	Params::NoceGameProgressInterface_GetAdditionalProgressTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetBGMProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag INoceGameProgressInterface::GetBGMProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetBGMProgressTag");

	Params::NoceGameProgressInterface_GetBGMProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetHistoryAdditionalProgressTagContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer INoceGameProgressInterface::GetHistoryAdditionalProgressTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetHistoryAdditionalProgressTagContainer");

	Params::NoceGameProgressInterface_GetHistoryAdditionalProgressTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetHistoryProgressTagContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer INoceGameProgressInterface::GetHistoryProgressTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetHistoryProgressTagContainer");

	Params::NoceGameProgressInterface_GetHistoryProgressTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetManipulatedProgress
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::GetManipulatedProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetManipulatedProgress");

	Params::NoceGameProgressInterface_GetManipulatedProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetNewGameProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag INoceGameProgressInterface::GetNewGameProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetNewGameProgressTag");

	Params::NoceGameProgressInterface_GetNewGameProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag INoceGameProgressInterface::GetProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetProgressTag");

	Params::NoceGameProgressInterface_GetProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.GetStateMachineProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag INoceGameProgressInterface::GetStateMachineProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "GetStateMachineProgressTag");

	Params::NoceGameProgressInterface_GetStateMachineProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.HasAdditionalTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              TargetTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::HasAdditionalTag(const struct FGameplayTag& TargetTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "HasAdditionalTag");

	Params::NoceGameProgressInterface_HasAdditionalTag Parms{};

	Parms.TargetTag = std::move(TargetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.HasAllAdditionalTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     TargetTag                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::HasAllAdditionalTag(const struct FGameplayTagContainer& TargetTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "HasAllAdditionalTag");

	Params::NoceGameProgressInterface_HasAllAdditionalTag Parms{};

	Parms.TargetTag = std::move(TargetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.HasAnyAdditionalTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     TargetTag                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::HasAnyAdditionalTag(const struct FGameplayTagContainer& TargetTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "HasAnyAdditionalTag");

	Params::NoceGameProgressInterface_HasAnyAdditionalTag Parms{};

	Parms.TargetTag = std::move(TargetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInDarkShrine
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInDarkShrine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInDarkShrine");

	Params::NoceGameProgressInterface_IsInDarkShrine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInEnding
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInEnding");

	Params::NoceGameProgressInterface_IsInEnding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInEndingBranchDecidedChapter
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInEndingBranchDecidedChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInEndingBranchDecidedChapter");

	Params::NoceGameProgressInterface_IsInEndingBranchDecidedChapter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInExplore
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInExplore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInExplore");

	Params::NoceGameProgressInterface_IsInExplore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInHellMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInHellMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInHellMode");

	Params::NoceGameProgressInterface_IsInHellMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsInMainStory
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsInMainStory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsInMainStory");

	Params::NoceGameProgressInterface_IsInMainStory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.IsProgressReady
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::IsProgressReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "IsProgressReady");

	Params::NoceGameProgressInterface_IsProgressReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.MatchProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              TargetTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::MatchProgressTag(const struct FGameplayTag& TargetTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "MatchProgressTag");

	Params::NoceGameProgressInterface_MatchProgressTag Parms{};

	Parms.TargetTag = std::move(TargetTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.RemoveAdditionalProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::RemoveAdditionalProgressTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "RemoveAdditionalProgressTag");

	Params::NoceGameProgressInterface_RemoveAdditionalProgressTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.RemoveAdditionalProgressTags
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InTagContainer                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::RemoveAdditionalProgressTags(const struct FGameplayTagContainer& InTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "RemoveAdditionalProgressTags");

	Params::NoceGameProgressInterface_RemoveAdditionalProgressTags Parms{};

	Parms.InTagContainer = std::move(InTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.RemoveLeafAdditionalTags
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InParentTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::RemoveLeafAdditionalTags(const struct FGameplayTag& InParentTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "RemoveLeafAdditionalTags");

	Params::NoceGameProgressInterface_RemoveLeafAdditionalTags Parms{};

	Parms.InParentTag = std::move(InParentTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.SetBGMProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceGameProgressInterface::SetBGMProgressTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "SetBGMProgressTag");

	Params::NoceGameProgressInterface_SetBGMProgressTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameProgressInterface.SetProgressTag
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceProgressType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::SetProgressTag(const struct FGameplayTag& InTag, ENoceProgressType InType, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "SetProgressTag");

	Params::NoceGameProgressInterface_SetProgressTag Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InType = InType;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameProgressInterface.UsedProgressDebug
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceGameProgressInterface::UsedProgressDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceGameProgressInterface", "UsedProgressDebug");

	Params::NoceGameProgressInterface_UsedProgressDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.BP_NewGameWidgetByIntent
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InIsContinue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMainmenuWidget::BP_NewGameWidgetByIntent(bool InIsContinue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "BP_NewGameWidgetByIntent");

	Params::NoceMainmenuWidget_BP_NewGameWidgetByIntent Parms{};

	Parms.InIsContinue = InIsContinue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceMainmenuWidget.BP_SeamlessTravel
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceMainmenuWidget::BP_SeamlessTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "BP_SeamlessTravel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceMainmenuWidget.ClearCancelAction
// (Final, Native, Public, BlueprintCallable)

void UNoceMainmenuWidget::ClearCancelAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ClearCancelAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMainmenuWidget.CreateChapterListObjs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FText>&              ChapterNames                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UMainMenuListObject*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMainMenuListObject*> UNoceMainmenuWidget::CreateChapterListObjs(const TArray<class FText>& ChapterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "CreateChapterListObjs");

	Params::NoceMainmenuWidget_CreateChapterListObjs Parms{};

	Parms.ChapterNames = std::move(ChapterNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.CreateDevInfo
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::CreateDevInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "CreateDevInfo");

	Params::NoceMainmenuWidget_CreateDevInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.CreateExploreListObjs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FText>&              ExploreNames                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UMainMenuListObject*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMainMenuListObject*> UNoceMainmenuWidget::CreateExploreListObjs(const TArray<class FText>& ExploreNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "CreateExploreListObjs");

	Params::NoceMainmenuWidget_CreateExploreListObjs Parms{};

	Parms.ExploreNames = std::move(ExploreNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ExecuteObj
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMainMenuListObject*              Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMainmenuWidget::ExecuteObj(class UMainMenuListObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ExecuteObj");

	Params::NoceMainmenuWidget_ExecuteObj Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMainmenuWidget.GetMainMenuListObjs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UMainMenuListObject*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMainMenuListObject*> UNoceMainmenuWidget::GetMainMenuListObjs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "GetMainMenuListObjs");

	Params::NoceMainmenuWidget_GetMainMenuListObjs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.HasContinue
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::HasContinue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "HasContinue");

	Params::NoceMainmenuWidget_HasContinue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.SetupCancelActionToMainMenu
// (Final, Native, Public, BlueprintCallable)

void UNoceMainmenuWidget::SetupCancelActionToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "SetupCancelActionToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMainmenuWidget.ToChapter
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToChapter");

	Params::NoceMainmenuWidget_ToChapter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToChapterMenu
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToChapterMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToChapterMenu");

	Params::NoceMainmenuWidget_ToChapterMenu Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToChapterMenu2
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToChapterMenu2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToChapterMenu2");

	Params::NoceMainmenuWidget_ToChapterMenu2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToCombatTest
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToCombatTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToCombatTest");

	Params::NoceMainmenuWidget_ToCombatTest Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToContinue
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToContinue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToContinue");

	Params::NoceMainmenuWidget_ToContinue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToDemo
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToDemo");

	Params::NoceMainmenuWidget_ToDemo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToEndingList
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToEndingList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToEndingList");

	Params::NoceMainmenuWidget_ToEndingList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToExitGame
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToExitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToExitGame");

	Params::NoceMainmenuWidget_ToExitGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToExplore
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToExplore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToExplore");

	Params::NoceMainmenuWidget_ToExplore Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToExploreMenu
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToExploreMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToExploreMenu");

	Params::NoceMainmenuWidget_ToExploreMenu Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToJPTest0
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToJPTest0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToJPTest0");

	Params::NoceMainmenuWidget_ToJPTest0 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToJPTest1
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToJPTest1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToJPTest1");

	Params::NoceMainmenuWidget_ToJPTest1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToJPTest2
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToJPTest2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToJPTest2");

	Params::NoceMainmenuWidget_ToJPTest2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToJPTest3
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToJPTest3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToJPTest3");

	Params::NoceMainmenuWidget_ToJPTest3 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToLoadGamePanel
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToLoadGamePanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToLoadGamePanel");

	Params::NoceMainmenuWidget_ToLoadGamePanel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToMainMenu
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToMainMenu");

	Params::NoceMainmenuWidget_ToMainMenu Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToNewGame
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToNewGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToNewGame");

	Params::NoceMainmenuWidget_ToNewGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMainmenuWidget.ToOption
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMainmenuWidget::ToOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMainmenuWidget", "ToOption");

	Params::NoceMainmenuWidget_ToOption Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameSettingFunctionLibrary.ExecuteSettingAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameSettingAction*               Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MarkAsDirty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGameSettingFunctionLibrary::ExecuteSettingAction(class UGameSettingAction* Action, bool MarkAsDirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGameSettingFunctionLibrary", "ExecuteSettingAction");

	Params::NoceGameSettingFunctionLibrary_ExecuteSettingAction Parms{};

	Parms.Action = Action;
	Parms.MarkAsDirty = MarkAsDirty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameSettingFunctionLibrary.GetOptionText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceGameSettingFunctionLibrary::GetOptionText(const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGameSettingFunctionLibrary", "GetOptionText");

	Params::NoceGameSettingFunctionLibrary_GetOptionText Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameSettingFunctionLibrary.GetOptionTextWithTableID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InTableID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceGameSettingFunctionLibrary::GetOptionTextWithTableID(const class FName& InTableID, const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGameSettingFunctionLibrary", "GetOptionTextWithTableID");

	Params::NoceGameSettingFunctionLibrary_GetOptionTextWithTableID Parms{};

	Parms.InTableID = InTableID;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePendantLightPostAnimInst.ComputeForce
// (Final, Native, Private, Const)
// Parameters:
// float                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePendantLightPostAnimInst::ComputeForce(float Seed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLightPostAnimInst", "ComputeForce");

	Params::NocePendantLightPostAnimInst_ComputeForce Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameSettingRegistry.BP_Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*                     InLocalPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGameSettingRegistry::BP_Init(class ULocalPlayer* InLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameSettingRegistry", "BP_Init");

	Params::NoceGameSettingRegistry_BP_Init Parms{};

	Parms.InLocalPlayer = InLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameSettingRegistry.BP_SaveChanges
// (Final, Native, Public, BlueprintCallable)

void UNoceGameSettingRegistry::BP_SaveChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameSettingRegistry", "BP_SaveChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameState.GetGameProgressTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ANoceGameState::GetGameProgressTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "GetGameProgressTag");

	Params::NoceGameState_GetGameProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.GetProgressStateInstanceStack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class USMStateInstance>     StateClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckNested                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USMStateInstance_Base*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USMStateInstance_Base* ANoceGameState::GetProgressStateInstanceStack(TSubclassOf<class USMStateInstance> StateClass, bool bCheckNested, bool bIncludeChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "GetProgressStateInstanceStack");

	Params::NoceGameState_GetProgressStateInstanceStack Parms{};

	Parms.StateClass = StateClass;
	Parms.bCheckNested = bCheckNested;
	Parms.bIncludeChildren = bIncludeChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsDarkHinakoChapter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          InRound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsDarkHinakoChapter(const struct FGameplayTag& InTag, ENoceRoundType InRound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsDarkHinakoChapter");

	Params::NoceGameState_IsDarkHinakoChapter Parms{};

	Parms.InTag = std::move(InTag);
	Parms.InRound = InRound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsDarkShrine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsDarkShrine(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsDarkShrine");

	Params::NoceGameState_IsDarkShrine Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsEnding
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsEnding(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsEnding");

	Params::NoceGameState_IsEnding Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsEndingBranchDecidedChapter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsEndingBranchDecidedChapter(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsEndingBranchDecidedChapter");

	Params::NoceGameState_IsEndingBranchDecidedChapter Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsExploreMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsExploreMode(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsExploreMode");

	Params::NoceGameState_IsExploreMode Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsHellMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsHellMode(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsHellMode");

	Params::NoceGameState_IsHellMode Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsInChapter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceChapterType                        InChapterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsInChapter(ENoceChapterType InChapterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsInChapter");

	Params::NoceGameState_IsInChapter Parms{};

	Parms.InChapterType = InChapterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsInEndGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsInEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsInEndGame");

	Params::NoceGameState_IsInEndGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.IsMainStory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceGameState::IsMainStory(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "IsMainStory");

	Params::NoceGameState_IsMainStory Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGameState.OnGameInitialized
// (Final, Native, Public)

void ANoceGameState::OnGameInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "OnGameInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGameState.OnPlayerReady
// (Final, Native, Public)

void ANoceGameState::OnPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGameState", "OnPlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapFunctionLibrary.GetNoceMapTracker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceMapTrackerComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceMapTrackerComponent* UNoceMapFunctionLibrary::GetNoceMapTracker(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceMapFunctionLibrary", "GetNoceMapTracker");

	Params::NoceMapFunctionLibrary_GetNoceMapTracker Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePostProcessAnimInstance.SetupLookAtComponent
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePostProcessAnimInstance::SetupLookAtComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "SetupLookAtComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessAnimInstance.UpdateApplyFootIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePostProcessAnimInstance::UpdateApplyFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "UpdateApplyFootIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessAnimInstance.UpdateApplyLookAtIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePostProcessAnimInstance::UpdateApplyLookAtIK(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "UpdateApplyLookAtIK");

	Params::NocePostProcessAnimInstance_UpdateApplyLookAtIK Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessAnimInstance.UpdateApplyPoseDriverIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePostProcessAnimInstance::UpdateApplyPoseDriverIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "UpdateApplyPoseDriverIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessAnimInstance.UpdateFootIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePostProcessAnimInstance::UpdateFootIK(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "UpdateFootIK");

	Params::NocePostProcessAnimInstance_UpdateFootIK Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessAnimInstance.UpdateRigidbody
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePostProcessAnimInstance::UpdateRigidbody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessAnimInstance", "UpdateRigidbody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGASFunctionLibrary.GetPrimaryAbilityHandleFromClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     InAbilityClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UNoceGASFunctionLibrary::GetPrimaryAbilityHandleFromClass(class UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<class UGameplayAbility> InAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGASFunctionLibrary", "GetPrimaryAbilityHandleFromClass");

	Params::NoceGASFunctionLibrary_GetPrimaryAbilityHandleFromClass Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.InAbilityClass = InAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGASFunctionLibrary.GetPrimaryAbilityInstanceFromClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     InAbilityClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceGameplayAbility*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceGameplayAbility* UNoceGASFunctionLibrary::GetPrimaryAbilityInstanceFromClass(class UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<class UGameplayAbility> InAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGASFunctionLibrary", "GetPrimaryAbilityInstanceFromClass");

	Params::NoceGASFunctionLibrary_GetPrimaryAbilityInstanceFromClass Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.InAbilityClass = InAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGASFunctionLibrary.GetPrimaryAbilityInstanceFromHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpecHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceGameplayAbility*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceGameplayAbility* UNoceGASFunctionLibrary::GetPrimaryAbilityInstanceFromHandle(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGASFunctionLibrary", "GetPrimaryAbilityInstanceFromHandle");

	Params::NoceGASFunctionLibrary_GetPrimaryAbilityInstanceFromHandle Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGASFunctionLibrary.IsPrimaryAbilityInstanceActive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpecHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGASFunctionLibrary::IsPrimaryAbilityInstanceActive(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGASFunctionLibrary", "IsPrimaryAbilityInstanceActive");

	Params::NoceGASFunctionLibrary_IsPrimaryAbilityInstanceActive Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGA_DetectEnemyInSight.End
// (Final, Native, Public, BlueprintCallable)

void UNoceGA_DetectEnemyInSight::End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleCombatAmbushed
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleCombatAmbushed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleCombatAmbushed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleCombatEnded
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleCombatEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleCombatEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleCombatEngaged
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleCombatEngaged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleCombatEngaged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleCombatEscaped
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleCombatEscaped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleCombatEscaped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleCombatWave
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleCombatWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleCombatWave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.HandleSeeingResurrectEnemies
// (Event, Public, BlueprintEvent)

void UNoceGA_DetectEnemyInSight::HandleSeeingResurrectEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "HandleSeeingResurrectEnemies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.Initialize
// (Final, Native, Public, BlueprintCallable)

void UNoceGA_DetectEnemyInSight::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGA_DetectEnemyInSight.OnEnemyInSightChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    NewEnemyInSight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGA_DetectEnemyInSight::OnEnemyInSightChanged(bool NewEnemyInSight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "OnEnemyInSightChanged");

	Params::NoceGA_DetectEnemyInSight_OnEnemyInSightChanged Parms{};

	Parms.NewEnemyInSight = NewEnemyInSight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.OnPlayerDamaged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InAttacker                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHealthDamager                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGA_DetectEnemyInSight::OnPlayerDamaged(class AActor* InAttacker, class FName InComboName, float InHealthDamager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "OnPlayerDamaged");

	Params::NoceGA_DetectEnemyInSight_OnPlayerDamaged Parms{};

	Parms.InAttacker = InAttacker;
	Parms.InComboName = InComboName;
	Parms.InHealthDamager = InHealthDamager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGA_DetectEnemyInSight.OnSeeingEnemyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    NewSeeingEnemey                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGA_DetectEnemyInSight::OnSeeingEnemyChanged(bool NewSeeingEnemey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "OnSeeingEnemyChanged");

	Params::NoceGA_DetectEnemyInSight_OnSeeingEnemyChanged Parms{};

	Parms.NewSeeingEnemey = NewSeeingEnemey;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceGA_DetectEnemyInSight.Update
// (Final, Native, Public, BlueprintCallable)

void UNoceGA_DetectEnemyInSight::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGA_DetectEnemyInSight", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.GetFirstNotebookIDInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ENoceNotebookType*                      OutType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGeneralHintWidget::GetFirstNotebookIDInfo(ENoceNotebookType* OutType, class FName* OutID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "GetFirstNotebookIDInfo");

	Params::NoceGeneralHintWidget_GetFirstNotebookIDInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutType != nullptr)
		*OutType = Parms.OutType;

	if (OutID != nullptr)
		*OutID = Parms.OutID;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGeneralHintWidget.Hide
// (Final, Native, Public, BlueprintCallable)

void UNoceGeneralHintWidget::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.HideHint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::HideHint(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "HideHint");

	Params::NoceGeneralHintWidget_HideHint Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.HideLine
// (Final, Native, Public, BlueprintCallable)

void UNoceGeneralHintWidget::HideLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "HideLine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.OnEnterEvent
// (Final, Native, Protected)

void UNoceGeneralHintWidget::OnEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "OnEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.OnSettingChanged
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              SystemSave                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::OnSettingChanged(class UNoceSystemSaveGame* SystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "OnSettingChanged");

	Params::NoceGeneralHintWidget_OnSettingChanged Parms{};

	Parms.SystemSave = SystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.OnUsingGimmick
// (Final, Native, Protected)
// Parameters:
// bool                                    IsUsing                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::OnUsingGimmick(bool IsUsing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "OnUsingGimmick");

	Params::NoceGeneralHintWidget_OnUsingGimmick Parms{};

	Parms.IsUsing = IsUsing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.Show
// (Final, Native, Public, BlueprintCallable)

void UNoceGeneralHintWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.ShowHint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::ShowHint(const class FText& InText, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "ShowHint");

	Params::NoceGeneralHintWidget_ShowHint Parms{};

	Parms.InText = std::move(InText);
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.ShowNotebookUpdateWithID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceNotebookType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InNotebookID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::ShowNotebookUpdateWithID(ENoceNotebookType InType, class FName InNotebookID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "ShowNotebookUpdateWithID");

	Params::NoceGeneralHintWidget_ShowNotebookUpdateWithID Parms{};

	Parms.InType = InType;
	Parms.InNotebookID = InNotebookID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGeneralHintWidget.ShowTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InNotebookID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHasNotebookID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceNotebookType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGeneralHintWidget::ShowTutorial(class FName InNotebookID, bool InHasNotebookID, const class FText& InText, float InDuration, ENoceNotebookType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGeneralHintWidget", "ShowTutorial");

	Params::NoceGeneralHintWidget_ShowTutorial Parms{};

	Parms.InNotebookID = InNotebookID;
	Parms.InHasNotebookID = InHasNotebookID;
	Parms.InText = std::move(InText);
	Parms.InDuration = InDuration;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.HandleGameInstanceShutdown
// (Final, Native, Public)

void UNoceGlobalDelegates::HandleGameInstanceShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "HandleGameInstanceShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.IsInExamineMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGlobalDelegates::IsInExamineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "IsInExamineMode");

	Params::NoceGlobalDelegates_IsInExamineMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.IsInNotebookOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGlobalDelegates::IsInNotebookOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "IsInNotebookOpen");

	Params::NoceGlobalDelegates_IsInNotebookOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.IsUsingGimmick
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGlobalDelegates::IsUsingGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "IsUsingGimmick");

	Params::NoceGlobalDelegates_IsUsingGimmick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.OnHandleSkipSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InDataRowName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::OnHandleSkipSequence(class FName InDataRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "OnHandleSkipSequence");

	Params::NoceGlobalDelegates_OnHandleSkipSequence Parms{};

	Parms.InDataRowName = InDataRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.ResetEventState
// (Final, Native, Public)

void UNoceGlobalDelegates::ResetEventState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "ResetEventState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.ResetStatus
// (Final, Native, Public, BlueprintCallable)

void UNoceGlobalDelegates::ResetStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "ResetStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.SetExamineMode
// (Final, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::SetExamineMode(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "SetExamineMode");

	Params::NoceGlobalDelegates_SetExamineMode Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.SetInEvent
// (Final, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEventModeType                      InEventModeType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceCineEventUserType                  InCineEventUserType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::SetInEvent(bool IsEnable, ENoceEventModeType InEventModeType, ENoceCineEventUserType InCineEventUserType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "SetInEvent");

	Params::NoceGlobalDelegates_SetInEvent Parms{};

	Parms.IsEnable = IsEnable;
	Parms.InEventModeType = InEventModeType;
	Parms.InCineEventUserType = InCineEventUserType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.SetNotebookOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsOpen                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::SetNotebookOpen(bool IsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "SetNotebookOpen");

	Params::NoceGlobalDelegates_SetNotebookOpen Parms{};

	Parms.IsOpen = IsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.SetPlaySequenceStateSeqActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           InSeqActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::SetPlaySequenceStateSeqActor(class AActor* InSeqActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "SetPlaySequenceStateSeqActor");

	Params::NoceGlobalDelegates_SetPlaySequenceStateSeqActor Parms{};

	Parms.InSeqActor = InSeqActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.SetUsingGimmick
// (Final, Native, Public)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGlobalDelegates::SetUsingGimmick(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "SetUsingGimmick");

	Params::NoceGlobalDelegates_SetUsingGimmick Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGlobalDelegates.GetCineEventUserType
// (Final, Native, Public, Const)
// Parameters:
// ENoceCineEventUserType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceCineEventUserType UNoceGlobalDelegates::GetCineEventUserType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "GetCineEventUserType");

	Params::NoceGlobalDelegates_GetCineEventUserType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.GetEventModeType
// (Final, Native, Public, Const)
// Parameters:
// ENoceEventModeType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEventModeType UNoceGlobalDelegates::GetEventModeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "GetEventModeType");

	Params::NoceGlobalDelegates_GetEventModeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.GetPlaySequenceStateSeqActor
// (Final, Native, Public, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNoceGlobalDelegates::GetPlaySequenceStateSeqActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "GetPlaySequenceStateSeqActor");

	Params::NoceGlobalDelegates_GetPlaySequenceStateSeqActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGlobalDelegates.IsInEvent
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGlobalDelegates::IsInEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceGlobalDelegates", "IsInEvent");

	Params::NoceGlobalDelegates_IsInEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupBase.BP_HandlePickupFailed
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANocePickupBase::BP_HandlePickupFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupBase", "BP_HandlePickupFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePickupBase.BP_PickupCanSpawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupBase::BP_PickupCanSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupBase", "BP_PickupCanSpawn");

	Params::NocePickupBase_BP_PickupCanSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupBase.IsPlayerHasItem
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupBase::IsPlayerHasItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupBase", "IsPlayerHasItem");

	Params::NocePickupBase_IsPlayerHasItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupBase.OnPickup
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupBase::OnPickup(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupBase", "OnPickup");

	Params::NocePickupBase_OnPickup Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupBase.GetId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANocePickupBase::GetId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupBase", "GetId");

	Params::NocePickupBase_GetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.GetAASuperSamplingModes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    IsResolution4K                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ENoceGraphicAASuperSamplingMode>*OutAvailableModes                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::GetAASuperSamplingModes(bool IsResolution4K, TArray<ENoceGraphicAASuperSamplingMode>* OutAvailableModes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "GetAASuperSamplingModes");

	Params::NoceGraphicOptionFunctionLibrary_GetAASuperSamplingModes Parms{};

	Parms.IsResolution4K = IsResolution4K;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAvailableModes != nullptr)
		*OutAvailableModes = std::move(Parms.OutAvailableModes);
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.IsHardwardRaytracingSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceGraphicOptionFunctionLibrary::IsHardwardRaytracingSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "IsHardwardRaytracingSupported");

	Params::NoceGraphicOptionFunctionLibrary_IsHardwardRaytracingSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetAASuperSamplingMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceGraphicAASuperSamplingMode         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetAASuperSamplingMode(ENoceGraphicAASuperSamplingMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetAASuperSamplingMode");

	Params::NoceGraphicOptionFunctionLibrary_SetAASuperSamplingMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetAASuperSamplingQuality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceGraphicAASuperSamplingMode         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InQuality                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetAASuperSamplingQuality(ENoceGraphicAASuperSamplingMode InMode, uint8 InQuality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetAASuperSamplingQuality");

	Params::NoceGraphicOptionFunctionLibrary_SetAASuperSamplingQuality Parms{};

	Parms.InMode = InMode;
	Parms.InQuality = InQuality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetDepthOfField
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetDepthOfField(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetDepthOfField");

	Params::NoceGraphicOptionFunctionLibrary_SetDepthOfField Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetFakeBackBufferSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetFakeBackBufferSize(int32 InWidth, int32 InHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetFakeBackBufferSize");

	Params::NoceGraphicOptionFunctionLibrary_SetFakeBackBufferSize Parms{};

	Parms.InWidth = InWidth;
	Parms.InHeight = InHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetGlobalIlluminationMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetGlobalIlluminationMode(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetGlobalIlluminationMode");

	Params::NoceGraphicOptionFunctionLibrary_SetGlobalIlluminationMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetHardwardRaytracing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetHardwardRaytracing(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetHardwardRaytracing");

	Params::NoceGraphicOptionFunctionLibrary_SetHardwardRaytracing Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetMotionBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetMotionBlur(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetMotionBlur");

	Params::NoceGraphicOptionFunctionLibrary_SetMotionBlur Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetPaniniDistortion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetPaniniDistortion(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetPaniniDistortion");

	Params::NoceGraphicOptionFunctionLibrary_SetPaniniDistortion Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetPaniniVerticalCompression
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetPaniniVerticalCompression(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetPaniniVerticalCompression");

	Params::NoceGraphicOptionFunctionLibrary_SetPaniniVerticalCompression Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetReflectionMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetReflectionMode(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetReflectionMode");

	Params::NoceGraphicOptionFunctionLibrary_SetReflectionMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetScalability_Effects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetScalability_Effects(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetScalability_Effects");

	Params::NoceGraphicOptionFunctionLibrary_SetScalability_Effects Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetScalability_PostProcessing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetScalability_PostProcessing(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetScalability_PostProcessing");

	Params::NoceGraphicOptionFunctionLibrary_SetScalability_PostProcessing Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetScalability_Shadows
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetScalability_Shadows(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetScalability_Shadows");

	Params::NoceGraphicOptionFunctionLibrary_SetScalability_Shadows Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetScalability_Textures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetScalability_Textures(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetScalability_Textures");

	Params::NoceGraphicOptionFunctionLibrary_SetScalability_Textures Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceGraphicOptionFunctionLibrary.SetScalability_ViewDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceGraphicOptionFunctionLibrary::SetScalability_ViewDistance(uint8 InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceGraphicOptionFunctionLibrary", "SetScalability_ViewDistance");

	Params::NoceGraphicOptionFunctionLibrary_SetScalability_ViewDistance Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimBankByProgressComp.OnChangedWeapon
// (Final, Native, Private)
// Parameters:
// class ANoceWeapon*                      InNewWeapon                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimBankByProgressComp::OnChangedWeapon(class ANoceWeapon* InNewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimBankByProgressComp", "OnChangedWeapon");

	Params::NocePlayerAnimBankByProgressComp_OnChangedWeapon Parms{};

	Parms.InNewWeapon = InNewWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerBroochComponent.HandleOnAddItem
// (Final, Native, Protected)
// Parameters:
// ENoceInventoryType                      InItemType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerBroochComponent::HandleOnAddItem(ENoceInventoryType InItemType, class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerBroochComponent", "HandleOnAddItem");

	Params::NocePlayerBroochComponent_HandleOnAddItem Parms{};

	Parms.InItemType = InItemType;
	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerBroochComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerBroochComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerBroochComponent", "HandleOnPossessed");

	Params::NocePlayerBroochComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerBroochComponent.HandleOnRemoveItem
// (Final, Native, Protected)
// Parameters:
// ENoceInventoryType                      InItemType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerBroochComponent::HandleOnRemoveItem(ENoceInventoryType InItemType, class FName InItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerBroochComponent", "HandleOnRemoveItem");

	Params::NocePlayerBroochComponent_HandleOnRemoveItem Parms{};

	Parms.InItemType = InItemType;
	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerBroochComponent.HandlePlayerShowHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerBroochComponent::HandlePlayerShowHide(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerBroochComponent", "HandlePlayerShowHide");

	Params::NocePlayerBroochComponent_HandlePlayerShowHide Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerBroochComponent.SetForceHideMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerBroochComponent::SetForceHideMesh(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerBroochComponent", "SetForceHideMesh");

	Params::NocePlayerBroochComponent_SetForceHideMesh Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceHitPerformDataSubsystem.ClearAllMaps
// (Final, Native, Public, BlueprintCallable)

void UNoceHitPerformDataSubsystem::ClearAllMaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceHitPerformDataSubsystem", "ClearAllMaps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceHitPerformDataSubsystem.LoadCameraShakeBase
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            InSoftClassPath                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShakeBase>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UCameraShakeBase> UNoceHitPerformDataSubsystem::LoadCameraShakeBase(const struct FSoftClassPath& InSoftClassPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceHitPerformDataSubsystem", "LoadCameraShakeBase");

	Params::NoceHitPerformDataSubsystem_LoadCameraShakeBase Parms{};

	Parms.InSoftClassPath = std::move(InSoftClassPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceHitPerformDataSubsystem.LoadCurveFloat
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           InSoftObjectPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveFloat* UNoceHitPerformDataSubsystem::LoadCurveFloat(const struct FSoftObjectPath& InSoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceHitPerformDataSubsystem", "LoadCurveFloat");

	Params::NoceHitPerformDataSubsystem_LoadCurveFloat Parms{};

	Parms.InSoftObjectPath = std::move(InSoftObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceHitPerformDataSubsystem.LoadForceFeedbackEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           InSoftObjectPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackEffect* UNoceHitPerformDataSubsystem::LoadForceFeedbackEffect(const struct FSoftObjectPath& InSoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceHitPerformDataSubsystem", "LoadForceFeedbackEffect");

	Params::NoceHitPerformDataSubsystem_LoadForceFeedbackEffect Parms{};

	Parms.InSoftObjectPath = std::move(InSoftObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceHitPerformDataSubsystem.LoadNiagaraSystem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           InSoftObjectPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UNoceHitPerformDataSubsystem::LoadNiagaraSystem(const struct FSoftObjectPath& InSoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceHitPerformDataSubsystem", "LoadNiagaraSystem");

	Params::NoceHitPerformDataSubsystem_LoadNiagaraSystem Parms{};

	Parms.InSoftObjectPath = std::move(InSoftObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceIndicatorIconBase.UpdateScreenLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InWorldLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceIndicatorIconBase::UpdateScreenLocation(const struct FVector& InWorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceIndicatorIconBase", "UpdateScreenLocation");

	Params::NoceIndicatorIconBase_UpdateScreenLocation Parms{};

	Parms.InWorldLocation = std::move(InWorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceIndicatorIconBase.UpdateWidget
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ENoceIndicatorEdgeType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceIndicatorIconBase::UpdateWidget(ENoceIndicatorEdgeType InType, int32 Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceIndicatorIconBase", "UpdateWidget");

	Params::NoceIndicatorIconBase_UpdateWidget Parms{};

	Parms.InType = InType;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputFunctionLibrary.AddOrRemoveCustomActionKey
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InPrimaryKey                                           (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InSecondaryKey                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsSecondaryKeyRemoved                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::AddOrRemoveCustomActionKey(class FName InActionName, const struct FKey& InPrimaryKey, const struct FKey& InSecondaryKey, bool* OutIsSecondaryKeyRemoved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "AddOrRemoveCustomActionKey");

	Params::NoceInputFunctionLibrary_AddOrRemoveCustomActionKey Parms{};

	Parms.InActionName = InActionName;
	Parms.InPrimaryKey = std::move(InPrimaryKey);
	Parms.InSecondaryKey = std::move(InSecondaryKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsSecondaryKeyRemoved != nullptr)
		*OutIsSecondaryKeyRemoved = Parms.OutIsSecondaryKeyRemoved;
}


// Function GameNoce.NoceInputFunctionLibrary.BindInput
// (Final, Native, Static, Public)
// Parameters:
// class UPlayerInput*                     InPlayerInput                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::BindInput(class UPlayerInput* InPlayerInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "BindInput");

	Params::NoceInputFunctionLibrary_BindInput Parms{};

	Parms.InPlayerInput = InPlayerInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActionIconNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::GetActionIconNames(const class FName& InActionName, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActionIconNames");

	Params::NoceInputFunctionLibrary_GetActionIconNames Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualInputDeviceTypeBy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InControllerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceInputFunctionLibrary::GetActualInputDeviceTypeBy(int32 InControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualInputDeviceTypeBy");

	Params::NoceInputFunctionLibrary_GetActualInputDeviceTypeBy Parms{};

	Parms.InControllerId = InControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutKey                                                 (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::GetActualKey(const class FName& InActionName, struct FKey* OutKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualKey");

	Params::NoceInputFunctionLibrary_GetActualKey Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKey != nullptr)
		*OutKey = std::move(Parms.OutKey);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualKeyIconName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ShowGamepad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::GetActualKeyIconName(bool ShowGamepad, const class FName& InActionName, class FName* OutName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualKeyIconName");

	Params::NoceInputFunctionLibrary_GetActualKeyIconName Parms{};

	Parms.ShowGamepad = ShowGamepad;
	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = Parms.OutName;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualKeyName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceInputFunctionLibrary::GetActualKeyName(const class FName& InActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualKeyName");

	Params::NoceInputFunctionLibrary_GetActualKeyName Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> UNoceInputFunctionLibrary::GetActualKeys(const class FName& InActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualKeys");

	Params::NoceInputFunctionLibrary_GetActualKeys Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetActualKeys2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutPrimaryKey                                          (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutSecondaryKey                                        (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutHiddenKey                                           (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::GetActualKeys2(class FName InActionName, struct FKey* OutPrimaryKey, struct FKey* OutSecondaryKey, struct FKey* OutHiddenKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetActualKeys2");

	Params::NoceInputFunctionLibrary_GetActualKeys2 Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPrimaryKey != nullptr)
		*OutPrimaryKey = std::move(Parms.OutPrimaryKey);

	if (OutSecondaryKey != nullptr)
		*OutSecondaryKey = std::move(Parms.OutSecondaryKey);

	if (OutHiddenKey != nullptr)
		*OutHiddenKey = std::move(Parms.OutHiddenKey);
}


// Function GameNoce.NoceInputFunctionLibrary.GetDefaultKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutPrimaryKey                                          (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutSecondaryKey                                        (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey*                            OutHiddenKey                                           (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::GetDefaultKeys(class FName InActionName, struct FKey* OutPrimaryKey, struct FKey* OutSecondaryKey, struct FKey* OutHiddenKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetDefaultKeys");

	Params::NoceInputFunctionLibrary_GetDefaultKeys Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPrimaryKey != nullptr)
		*OutPrimaryKey = std::move(Parms.OutPrimaryKey);

	if (OutSecondaryKey != nullptr)
		*OutSecondaryKey = std::move(Parms.OutSecondaryKey);

	if (OutHiddenKey != nullptr)
		*OutHiddenKey = std::move(Parms.OutHiddenKey);
}


// Function GameNoce.NoceInputFunctionLibrary.GetInputActionToKeyTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceInputFunctionLibrary::GetInputActionToKeyTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetInputActionToKeyTable");

	Params::NoceInputFunctionLibrary_GetInputActionToKeyTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetInputDeviceType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceInputFunctionLibrary::GetInputDeviceType(class APlayerController* InPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetInputDeviceType");

	Params::NoceInputFunctionLibrary_GetInputDeviceType Parms{};

	Parms.InPC = InPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetInputDeviceTypeBy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InControllerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceInputFunctionLibrary::GetInputDeviceTypeBy(int32 InControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetInputDeviceTypeBy");

	Params::NoceInputFunctionLibrary_GetInputDeviceTypeBy Parms{};

	Parms.InControllerId = InControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetInputGamePadType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceInputFunctionLibrary::GetInputGamePadType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetInputGamePadType");

	Params::NoceInputFunctionLibrary_GetInputGamePadType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetInputMultiActionTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNoceInputFunctionLibrary::GetInputMultiActionTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetInputMultiActionTable");

	Params::NoceInputFunctionLibrary_GetInputMultiActionTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.GetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceInputFunctionLibrary::GetName(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "GetName");

	Params::NoceInputFunctionLibrary_GetName Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsAnyKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsAnyKey(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsAnyKey");

	Params::NoceInputFunctionLibrary_IsAnyKey Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsCancel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsCancel(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsCancel");

	Params::NoceInputFunctionLibrary_IsCancel Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsConfirm
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsConfirm(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsConfirm");

	Params::NoceInputFunctionLibrary_IsConfirm Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsGamePadConnected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InControllerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsGamePadConnected(int32 InControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsGamePadConnected");

	Params::NoceInputFunctionLibrary_IsGamePadConnected Parms{};

	Parms.InControllerId = InControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsMouseClickButton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPointerEvent&             InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsMouseClickButton(const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsMouseClickButton");

	Params::NoceInputFunctionLibrary_IsMouseClickButton Parms{};

	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsMouseConfirm
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsMouseConfirm(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsMouseConfirm");

	Params::NoceInputFunctionLibrary_IsMouseConfirm Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsPauseMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsPauseMenu(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsPauseMenu");

	Params::NoceInputFunctionLibrary_IsPauseMenu Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsRepeatKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKeyEvent&                 InKeyEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsRepeatKey(const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsRepeatKey");

	Params::NoceInputFunctionLibrary_IsRepeatKey Parms{};

	Parms.InKeyEvent = std::move(InKeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIAction1
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIAction1(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIAction1");

	Params::NoceInputFunctionLibrary_IsUIAction1 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIAction2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIAction2(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIAction2");

	Params::NoceInputFunctionLibrary_IsUIAction2 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIEquipment
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIEquipment(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIEquipment");

	Params::NoceInputFunctionLibrary_IsUIEquipment Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ENoceUIInputAction                InActionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIKey(const ENoceUIInputAction InActionName, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIKey");

	Params::NoceInputFunctionLibrary_IsUIKey Parms{};

	Parms.InActionName = InActionName;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIKeyEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ENoceUIInputAction                InActionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKeyEvent&                 InKeyEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIKeyEvent(const ENoceUIInputAction InActionName, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIKeyEvent");

	Params::NoceInputFunctionLibrary_IsUIKeyEvent Parms{};

	Parms.InActionName = InActionName;
	Parms.InKeyEvent = std::move(InKeyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIKeyUp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ENoceUIInputAction                InActionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIKeyUp(const ENoceUIInputAction InActionName, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIKeyUp");

	Params::NoceInputFunctionLibrary_IsUIKeyUp Parms{};

	Parms.InActionName = InActionName;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMap(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMap");

	Params::NoceInputFunctionLibrary_IsUIMap Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMapFloorDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMapFloorDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMapFloorDown");

	Params::NoceInputFunctionLibrary_IsUIMapFloorDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMapFloorUp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMapFloorUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMapFloorUp");

	Params::NoceInputFunctionLibrary_IsUIMapFloorUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMouseEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ENoceUIInputAction                InActionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMouseEvent(const ENoceUIInputAction InActionName, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMouseEvent");

	Params::NoceInputFunctionLibrary_IsUIMouseEvent Parms{};

	Parms.InActionName = InActionName;
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveDown");

	Params::NoceInputFunctionLibrary_IsUIMoveDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveDown2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveDown2(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveDown2");

	Params::NoceInputFunctionLibrary_IsUIMoveDown2 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveLeft(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveLeft");

	Params::NoceInputFunctionLibrary_IsUIMoveLeft Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveLeft2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveLeft2(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveLeft2");

	Params::NoceInputFunctionLibrary_IsUIMoveLeft2 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveRight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveRight(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveRight");

	Params::NoceInputFunctionLibrary_IsUIMoveRight Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveRight2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveRight2(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveRight2");

	Params::NoceInputFunctionLibrary_IsUIMoveRight2 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveUp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveUp");

	Params::NoceInputFunctionLibrary_IsUIMoveUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIMoveUp2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIMoveUp2(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIMoveUp2");

	Params::NoceInputFunctionLibrary_IsUIMoveUp2 Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUINotebook
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUINotebook(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUINotebook");

	Params::NoceInputFunctionLibrary_IsUINotebook Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIPageDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIPageDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIPageDown");

	Params::NoceInputFunctionLibrary_IsUIPageDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUIPageUp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUIPageUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUIPageUp");

	Params::NoceInputFunctionLibrary_IsUIPageUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUISecondTabLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUISecondTabLeft(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUISecondTabLeft");

	Params::NoceInputFunctionLibrary_IsUISecondTabLeft Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUISecondTabRight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUISecondTabRight(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUISecondTabRight");

	Params::NoceInputFunctionLibrary_IsUISecondTabRight Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUITabLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUITabLeft(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUITabLeft");

	Params::NoceInputFunctionLibrary_IsUITabLeft Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUITabRight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUITabRight(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUITabRight");

	Params::NoceInputFunctionLibrary_IsUITabRight Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUsingGamePad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InControllerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUsingGamePad(int32 InControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUsingGamePad");

	Params::NoceInputFunctionLibrary_IsUsingGamePad Parms{};

	Parms.InControllerId = InControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUsingKeyboardMouse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUsingKeyboardMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUsingKeyboardMouse");

	Params::NoceInputFunctionLibrary_IsUsingKeyboardMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.IsUsingMouse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputFunctionLibrary::IsUsingMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "IsUsingMouse");

	Params::NoceInputFunctionLibrary_IsUsingMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputFunctionLibrary.ModifyActionKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InPrimaryKey                                           (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InSecondaryKey                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::ModifyActionKey(class APlayerController* InPC, class FName InActionName, const struct FKey& InPrimaryKey, const struct FKey& InSecondaryKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "ModifyActionKey");

	Params::NoceInputFunctionLibrary_ModifyActionKey Parms{};

	Parms.InPC = InPC;
	Parms.InActionName = InActionName;
	Parms.InPrimaryKey = std::move(InPrimaryKey);
	Parms.InSecondaryKey = std::move(InSecondaryKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputFunctionLibrary.ModifyAxisKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAxisName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InPrimaryKey                                           (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey&                      InSecondaryKey                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::ModifyAxisKey(class APlayerController* InPC, class FName InAxisName, float Scale, class FName InActionName, const struct FKey& InPrimaryKey, const struct FKey& InSecondaryKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "ModifyAxisKey");

	Params::NoceInputFunctionLibrary_ModifyAxisKey Parms{};

	Parms.InPC = InPC;
	Parms.InAxisName = InAxisName;
	Parms.Scale = Scale;
	Parms.InActionName = InActionName;
	Parms.InPrimaryKey = std::move(InPrimaryKey);
	Parms.InSecondaryKey = std::move(InSecondaryKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputFunctionLibrary.RemoveCustomActionKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPrimary                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::RemoveCustomActionKey(class APlayerController* InPC, class FName InActionName, bool IsPrimary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "RemoveCustomActionKey");

	Params::NoceInputFunctionLibrary_RemoveCustomActionKey Parms{};

	Parms.InPC = InPC;
	Parms.InActionName = InActionName;
	Parms.IsPrimary = IsPrimary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputFunctionLibrary.RemoveCustomAxisKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAxisName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPrimary                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputFunctionLibrary::RemoveCustomAxisKey(class APlayerController* InPC, class FName InAxisName, float Scale, class FName InActionName, bool IsPrimary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputFunctionLibrary", "RemoveCustomAxisKey");

	Params::NoceInputFunctionLibrary_RemoveCustomAxisKey Parms{};

	Parms.InPC = InPC;
	Parms.InAxisName = InAxisName;
	Parms.Scale = Scale;
	Parms.InActionName = InActionName;
	Parms.IsPrimary = IsPrimary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerChargeComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "HandleOnPossessed");

	Params::NocePlayerChargeComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.RemoveAttackMultiplier
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerChargeComponent::RemoveAttackMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "RemoveAttackMultiplier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.RemoveChargeBuff
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerChargeComponent::RemoveChargeBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "RemoveChargeBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.RemoveWinceMultiplier
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerChargeComponent::RemoveWinceMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "RemoveWinceMultiplier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.SetAttackMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InChargeTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerChargeComponent::SetAttackMultiplier(class FName InComboName, float InChargeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "SetAttackMultiplier");

	Params::NocePlayerChargeComponent_SetAttackMultiplier Parms{};

	Parms.InComboName = InComboName;
	Parms.InChargeTime = InChargeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.SetWinceMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InChargeTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerChargeComponent::SetWinceMultiplier(class FName InComboName, float InChargeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "SetWinceMultiplier");

	Params::NocePlayerChargeComponent_SetWinceMultiplier Parms{};

	Parms.InComboName = InComboName;
	Parms.InChargeTime = InChargeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.StartCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerChargeComponent::StartCharge(class FName InComboName, class FName InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "StartCharge");

	Params::NocePlayerChargeComponent_StartCharge Parms{};

	Parms.InComboName = InComboName;
	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerChargeComponent.StopCharge
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerChargeComponent::StopCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerChargeComponent", "StopCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputGuideSubsystem.HideLastGuide
// (Final, Native, Public, BlueprintCallable)

void UNoceInputGuideSubsystem::HideLastGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputGuideSubsystem", "HideLastGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputGuideSubsystem.IsShowingGuide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInputGuideSubsystem::IsShowingGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputGuideSubsystem", "IsShowingGuide");

	Params::NoceInputGuideSubsystem_IsShowingGuide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputGuideSubsystem.RemoveCommonGuide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputGuideSubsystem::RemoveCommonGuide(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputGuideSubsystem", "RemoveCommonGuide");

	Params::NoceInputGuideSubsystem_RemoveCommonGuide Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputGuideSubsystem.RequestCommonGuide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InGuide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceInputGuideSubsystem::RequestCommonGuide(class FName InGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputGuideSubsystem", "RequestCommonGuide");

	Params::NoceInputGuideSubsystem_RequestCommonGuide Parms{};

	Parms.InGuide = InGuide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputGuideSubsystem.ShowLastGuide
// (Final, Native, Public, BlueprintCallable)

void UNoceInputGuideSubsystem::ShowLastGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputGuideSubsystem", "ShowLastGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewImageWidgetBase.ShowItem
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const ENoceInventoryType&               Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickPreviewImageWidgetBase::ShowItem(const ENoceInventoryType& Type, const class FName& ID, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewImageWidgetBase", "ShowItem");

	Params::NocePickPreviewImageWidgetBase_ShowItem Parms{};

	Parms.Type = Type;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceInputQueueComponent.ClearInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputQueueComponent::ClearInputAction(ENoceInputAction InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputQueueComponent", "ClearInputAction");

	Params::NoceInputQueueComponent_ClearInputAction Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputQueueComponent.CommitInputUsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InExcludeStateMachineName                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InExcludeStateName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputQueueComponent::CommitInputUsed(class FName InExcludeStateMachineName, class FName InExcludeStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputQueueComponent", "CommitInputUsed");

	Params::NoceInputQueueComponent_CommitInputUsed Parms{};

	Parms.InExcludeStateMachineName = InExcludeStateMachineName;
	Parms.InExcludeStateName = InExcludeStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputQueueComponent.GetMatchedInput
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ENocePlayerAnimStateType>& InAnimStateTypes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ENocePlayerAnimStateType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePlayerAnimStateType UNoceInputQueueComponent::GetMatchedInput(const TArray<ENocePlayerAnimStateType>& InAnimStateTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputQueueComponent", "GetMatchedInput");

	Params::NoceInputQueueComponent_GetMatchedInput Parms{};

	Parms.InAnimStateTypes = std::move(InAnimStateTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputQueueComponent.HandleInputAction
// (Final, Native, Protected)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputQueueComponent::HandleInputAction(ENoceInputAction InInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputQueueComponent", "HandleInputAction");

	Params::NoceInputQueueComponent_HandleInputAction Parms{};

	Parms.InInputAction = InInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputQueueComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputQueueComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputQueueComponent", "HandleOnPossessed");

	Params::NoceInputQueueComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputSubsystem.GetDeviceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceInputSubsystem::GetDeviceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputSubsystem", "GetDeviceType");

	Params::NoceInputSubsystem_GetDeviceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputSubsystem.GetGamepadControlType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceInputGamepadType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputGamepadType UNoceInputSubsystem::GetGamepadControlType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInputSubsystem", "GetGamepadControlType");

	Params::NoceInputSubsystem_GetGamepadControlType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInputSubsystem.ForceShowCursorIfUsingKeyboardMouse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ResetCursorPos                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputSubsystem::ForceShowCursorIfUsingKeyboardMouse(bool ResetCursorPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputSubsystem", "ForceShowCursorIfUsingKeyboardMouse");

	Params::NoceInputSubsystem_ForceShowCursorIfUsingKeyboardMouse Parms{};

	Parms.ResetCursorPos = ResetCursorPos;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputWidget.HideGuide
// (Final, Native, Protected, BlueprintCallable)

void UNoceInputWidget::HideGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputWidget", "HideGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputWidget.OnInputAction
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputWidget::OnInputAction(ENoceInputAction InInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputWidget", "OnInputAction");

	Params::NoceInputWidget_OnInputAction Parms{};

	Parms.InInputAction = InInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputWidget.OnUIInputAction
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// ENoceUIInputAction                      InUIInputAction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputWidget::OnUIInputAction(ENoceUIInputAction InUIInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputWidget", "OnUIInputAction");

	Params::NoceInputWidget_OnUIInputAction Parms{};

	Parms.InUIInputAction = InUIInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInputWidget.ShowGuide
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InGuide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInputWidget::ShowGuide(class FName InGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInputWidget", "ShowGuide");

	Params::NoceInputWidget_ShowGuide Parms{};

	Parms.InGuide = InGuide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAttackInfoComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAttackInfoComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAttackInfoComponent", "HandleOnPossessed");

	Params::NocePlayerAttackInfoComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.CanUseTrigger
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerTriggerBase::CanUseTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "CanUseTrigger");

	Params::NocePlayerTriggerBase_CanUseTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerBase.GetTriggerEnable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerTriggerBase::GetTriggerEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "GetTriggerEnable");

	Params::NocePlayerTriggerBase_GetTriggerEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerBase.IsMatchingCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerTriggerBase::IsMatchingCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "IsMatchingCondition");

	Params::NocePlayerTriggerBase_IsMatchingCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerBase.ManualCheckOverlapping
// (Native, Event, Protected, BlueprintEvent)

void ANocePlayerTriggerBase::ManualCheckOverlapping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "ManualCheckOverlapping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnAdditionalTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnAdditionalTagChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnAdditionalTagChanged");

	Params::NocePlayerTriggerBase_OnAdditionalTagChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnAdditionalTagChanged_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnAdditionalTagChanged_BP(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnAdditionalTagChanged_BP");

	Params::NocePlayerTriggerBase_OnAdditionalTagChanged_BP Parms{};

	Parms.InTag = std::move(InTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerTriggerBase.OnConditionChanged_BP
// (Event, Protected, BlueprintEvent)

void ANocePlayerTriggerBase::OnConditionChanged_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnConditionChanged_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePlayerTriggerBase.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnProgressChanged");

	Params::NocePlayerTriggerBase_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnProgressChanged_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnProgressChanged_BP(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnProgressChanged_BP");

	Params::NocePlayerTriggerBase_OnProgressChanged_BP Parms{};

	Parms.InTag = std::move(InTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerTriggerBase.OnProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnProgressInitialized(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnProgressInitialized");

	Params::NocePlayerTriggerBase_OnProgressInitialized Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnProgressInitialized_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnProgressInitialized_BP(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnProgressInitialized_BP");

	Params::NocePlayerTriggerBase_OnProgressInitialized_BP Parms{};

	Parms.InTag = std::move(InTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerTriggerBase.OnStoryEndingChanged
// (Final, Native, Protected)
// Parameters:
// ENoceEndingType                         InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::OnStoryEndingChanged(ENoceEndingType InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnStoryEndingChanged");

	Params::NocePlayerTriggerBase_OnStoryEndingChanged Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnTriggerDisabled
// (Native, Event, Protected, BlueprintEvent)

void ANocePlayerTriggerBase::OnTriggerDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnTriggerDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.OnTriggerEnabled
// (Native, Event, Protected, BlueprintEvent)

void ANocePlayerTriggerBase::OnTriggerEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "OnTriggerEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.RecheckFirstTick
// (Final, Native, Protected, BlueprintCallable)

void ANocePlayerTriggerBase::RecheckFirstTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "RecheckFirstTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerBase.SetTriggerEnable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerTriggerBase::SetTriggerEnable(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerBase", "SetTriggerEnable");

	Params::NocePlayerTriggerBase_SetTriggerEnable Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.CanInteractWithPawnBP
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractorPawn                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::CanInteractWithPawnBP(class AActor* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "CanInteractWithPawnBP");

	Params::NoceInteractableBase_CanInteractWithPawnBP Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.ExecuteForbitFeedback
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::ExecuteForbitFeedback(class AActor* InteractPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "ExecuteForbitFeedback");

	Params::NoceInteractableBase_ExecuteForbitFeedback Parms{};

	Parms.InteractPawn = InteractPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.ExecuteInstantFeedback
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::ExecuteInstantFeedback(class AActor* InteractPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "ExecuteInstantFeedback");

	Params::NoceInteractableBase_ExecuteInstantFeedback Parms{};

	Parms.InteractPawn = InteractPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.GetAvailableStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::GetAvailableStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "GetAvailableStatus");

	Params::NoceInteractableBase_GetAvailableStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.GetCooldownTime
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceInteractableBase::GetCooldownTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "GetCooldownTime");

	Params::NoceInteractableBase_GetCooldownTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.GetHintLocationBP
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceInteractableBase::GetHintLocationBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "GetHintLocationBP");

	Params::NoceInteractableBase_GetHintLocationBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.GetPromptTextBP
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ANoceInteractableBase::GetPromptTextBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "GetPromptTextBP");

	Params::NoceInteractableBase_GetPromptTextBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.HasExceededUsageLimit
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::HasExceededUsageLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "HasExceededUsageLimit");

	Params::NoceInteractableBase_HasExceededUsageLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.IsInteractionForbit
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::IsInteractionForbit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "IsInteractionForbit");

	Params::NoceInteractableBase_IsInteractionForbit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.IsInteractionForbitBP
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::IsInteractionForbitBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "IsInteractionForbitBP");

	Params::NoceInteractableBase_IsInteractionForbitBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.OnBeginOverlapHint
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::OnBeginOverlapHint(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnBeginOverlapHint");

	Params::NoceInteractableBase_OnBeginOverlapHint Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.OnBeginOverlapPrompt
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::OnBeginOverlapPrompt(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnBeginOverlapPrompt");

	Params::NoceInteractableBase_OnBeginOverlapPrompt Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.OnBeginUsingBP
// (Native, Event, Protected, BlueprintEvent)

void ANoceInteractableBase::OnBeginUsingBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnBeginUsingBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.OnEndOverlapHint
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::OnEndOverlapHint(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnEndOverlapHint");

	Params::NoceInteractableBase_OnEndOverlapHint Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.OnEndOverlapPrompt
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::OnEndOverlapPrompt(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnEndOverlapPrompt");

	Params::NoceInteractableBase_OnEndOverlapPrompt Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.OnEndUsingBP
// (Native, Event, Protected, BlueprintEvent)

void ANoceInteractableBase::OnEndUsingBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "OnEndUsingBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.RequestInstantFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InteractPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceInteractableBase::RequestInstantFeedback(class AActor* InteractPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "RequestInstantFeedback");

	Params::NoceInteractableBase_RequestInstantFeedback Parms{};

	Parms.InteractPawn = InteractPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractableBase.SetAvaliableStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::SetAvaliableStatus(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "SetAvaliableStatus");

	Params::NoceInteractableBase_SetAvaliableStatus Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.SetInteractEnable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::SetInteractEnable(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "SetInteractEnable");

	Params::NoceInteractableBase_SetInteractEnable Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.SetIsUsingInteract
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InIsUsing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::SetIsUsingInteract(bool InIsUsing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "SetIsUsingInteract");

	Params::NoceInteractableBase_SetIsUsingInteract Parms{};

	Parms.InIsUsing = InIsUsing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.UndoUseCountOnce
// (Final, Native, Protected, BlueprintCallable)

void ANoceInteractableBase::UndoUseCountOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "UndoUseCountOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractableBase.UpdateButtonIcon
// (Final, Native, Protected)
// Parameters:
// bool                                    ShowPrompt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowHint                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowForbit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceInteractableBase::UpdateButtonIcon(bool ShowPrompt, bool ShowHint, bool ShowForbit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractableBase", "UpdateButtonIcon");

	Params::NoceInteractableBase_UpdateButtonIcon Parms{};

	Parms.ShowPrompt = ShowPrompt;
	Parms.ShowHint = ShowHint;
	Parms.ShowForbit = ShowForbit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_PCPreset.GetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceSetting_PCPreset::GetText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_PCPreset", "GetText");

	Params::NoceSetting_PCPreset_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSetting_PCPreset.SetIsSetPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSetting_PCPreset::SetIsSetPreset(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_PCPreset", "SetIsSetPreset");

	Params::NoceSetting_PCPreset_SetIsSetPreset Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_PCPreset.SetPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceGameSettingPreset                  InPreset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSetting_PCPreset::SetPreset(ENoceGameSettingPreset InPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_PCPreset", "SetPreset");

	Params::NoceSetting_PCPreset_SetPreset Parms{};

	Parms.InPreset = InPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractComponent.GetCandidateDistanceXY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceInteractComponent::GetCandidateDistanceXY()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "GetCandidateDistanceXY");

	Params::NoceInteractComponent_GetCandidateDistanceXY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractComponent.GetCandidateDistanceZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceInteractComponent::GetCandidateDistanceZ()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "GetCandidateDistanceZ");

	Params::NoceInteractComponent_GetCandidateDistanceZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractComponent.HandleInputAction
// (Final, Native, Protected)
// Parameters:
// ENoceInputAction                        InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInteractComponent::HandleInputAction(ENoceInputAction InInputAction, bool InPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "HandleInputAction");

	Params::NoceInteractComponent_HandleInputAction Parms{};

	Parms.InInputAction = InInputAction;
	Parms.InPressed = InPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInteractComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "HandleOnPossessed");

	Params::NoceInteractComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractComponent.IsInteractTypeValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInteractType                       InInteractType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInteractComponent::IsInteractTypeValid(ENoceInteractType InInteractType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "IsInteractTypeValid");

	Params::NoceInteractComponent_IsInteractTypeValid Parms{};

	Parms.InInteractType = InInteractType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractComponent.IsTargetInstantFeedback
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInteractComponent::IsTargetInstantFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "IsTargetInstantFeedback");

	Params::NoceInteractComponent_IsTargetInstantFeedback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractComponent.IsUsingInteract
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInteractComponent::IsUsingInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "IsUsingInteract");

	Params::NoceInteractComponent_IsUsingInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInteractComponent.PauseInteract
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInteractComponent::PauseInteract(bool InPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "PauseInteract");

	Params::NoceInteractComponent_PauseInteract Parms{};

	Parms.InPause = InPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractComponent.SetIsUseInteract
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInteractComponent::SetIsUseInteract(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractComponent", "SetIsUseInteract");

	Params::NoceInteractComponent_SetIsUseInteract Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.RegisterPickup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupBase*                  Pickup                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::RegisterPickup(class ANocePickupBase* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "RegisterPickup");

	Params::NocePickupsHelperSubsystem_RegisterPickup Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.RegisterPickupsPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupsPoint*                PickupsPoint                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::RegisterPickupsPoint(class ANocePickupsPoint* PickupsPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "RegisterPickupsPoint");

	Params::NocePickupsHelperSubsystem_RegisterPickupsPoint Parms{};

	Parms.PickupsPoint = PickupsPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.RegisterRummage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            Rummage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::RegisterRummage(class ANoceInteractableBase* Rummage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "RegisterRummage");

	Params::NocePickupsHelperSubsystem_RegisterRummage Parms{};

	Parms.Rummage = Rummage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.UnregisterPickup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupBase*                  Pickup                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::UnregisterPickup(class ANocePickupBase* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "UnregisterPickup");

	Params::NocePickupsHelperSubsystem_UnregisterPickup Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.UnregisterPickupsPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupsPoint*                PickupsPoint                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::UnregisterPickupsPoint(class ANocePickupsPoint* PickupsPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "UnregisterPickupsPoint");

	Params::NocePickupsHelperSubsystem_UnregisterPickupsPoint Parms{};

	Parms.PickupsPoint = PickupsPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsHelperSubsystem.UnregisterRummage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            Rummage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsHelperSubsystem::UnregisterRummage(class ANoceInteractableBase* Rummage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsHelperSubsystem", "UnregisterRummage");

	Params::NocePickupsHelperSubsystem_UnregisterRummage Parms{};

	Parms.Rummage = Rummage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractIconBase.SetPromptText
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      PromptText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceInteractIconBase::SetPromptText(const class FText& PromptText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractIconBase", "SetPromptText");

	Params::NoceInteractIconBase_SetPromptText Parms{};

	Parms.PromptText = std::move(PromptText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInteractIconBase.UpdateIcon
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENoceInteractIconState                  TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   IconLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInteractIconBase::UpdateIcon(ENoceInteractIconState TargetState, const struct FVector& IconLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInteractIconBase", "UpdateIcon");

	Params::NoceInteractIconBase_UpdateIcon Parms{};

	Parms.TargetState = TargetState;
	Parms.IconLocation = std::move(IconLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectiblePage.OnListMouseConfirm
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryCollectiblePage::OnListMouseConfirm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectiblePage", "OnListMouseConfirm");

	Params::NoceInventoryCollectiblePage_OnListMouseConfirm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectiblePage.OnListUpdateSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryCollectiblePage::OnListUpdateSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectiblePage", "OnListUpdateSelection");

	Params::NoceInventoryCollectiblePage_OnListUpdateSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceShortcutWeaponChildWidget.SetDisable
// (Final, Native, Public, BlueprintCallable)

void UNoceShortcutWeaponChildWidget::SetDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShortcutWeaponChildWidget", "SetDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceShortcutWeaponChildWidget.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurability                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InEquipped                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceShortcutWeaponChildWidget::SetEnable(class FName ID, float InDurability, bool InEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceShortcutWeaponChildWidget", "SetEnable");

	Params::NoceShortcutWeaponChildWidget_SetEnable Parms{};

	Parms.ID = ID;
	Parms.InDurability = InDurability;
	Parms.InEquipped = InEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectibleWidget.OnShowHideTab
// (Final, Native, Protected)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryCollectibleWidget::OnShowHideTab(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectibleWidget", "OnShowHideTab");

	Params::NoceInventoryCollectibleWidget_OnShowHideTab Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectibleWidget.OnSwitchTab
// (Final, Native, Protected, BlueprintCallable)

void UNoceInventoryCollectibleWidget::OnSwitchTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectibleWidget", "OnSwitchTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectibleWidget.OnSwitchTabCompleted
// (Final, Native, Protected)

void UNoceInventoryCollectibleWidget::OnSwitchTabCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectibleWidget", "OnSwitchTabCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectibleWidget.OnTabMouseDown
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryCollectibleWidget::OnTabMouseDown(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectibleWidget", "OnTabMouseDown");

	Params::NoceInventoryCollectibleWidget_OnTabMouseDown Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryCollectibleWidget.SwitchTabIndex
// (Final, Native, Protected)

void UNoceInventoryCollectibleWidget::SwitchTabIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryCollectibleWidget", "SwitchTabIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.AddClawTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::AddClawTransform(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "AddClawTransform");

	Params::NocePlayerClawTransformComponent_AddClawTransform Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.ApplyAttrackSoulDamageToTarget
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerClawTransformComponent::ApplyAttrackSoulDamageToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "ApplyAttrackSoulDamageToTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.CostClawTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::CostClawTransform(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "CostClawTransform");

	Params::NocePlayerClawTransformComponent_CostClawTransform Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.FillClawTransformToFull
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerClawTransformComponent::FillClawTransformToFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "FillClawTransformToFull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.GetAttrackSoulTargetDistanceXY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerClawTransformComponent::GetAttrackSoulTargetDistanceXY()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "GetAttrackSoulTargetDistanceXY");

	Params::NocePlayerClawTransformComponent_GetAttrackSoulTargetDistanceXY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.GetAttrackSoulTargetDistanceZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerClawTransformComponent::GetAttrackSoulTargetDistanceZ()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "GetAttrackSoulTargetDistanceZ");

	Params::NocePlayerClawTransformComponent_GetAttrackSoulTargetDistanceZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.GetAttractSoulTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceEnemyCharacter*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceEnemyCharacter* UNocePlayerClawTransformComponent::GetAttractSoulTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "GetAttractSoulTarget");

	Params::NocePlayerClawTransformComponent_GetAttractSoulTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.GetClawTransform
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerClawTransformComponent::GetClawTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "GetClawTransform");

	Params::NocePlayerClawTransformComponent_GetClawTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.HandleEnemyDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::HandleEnemyDead(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "HandleEnemyDead");

	Params::NocePlayerClawTransformComponent_HandleEnemyDead Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "HandleOnPossessed");

	Params::NocePlayerClawTransformComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.HaveAttrackSoulTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerClawTransformComponent::HaveAttrackSoulTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "HaveAttrackSoulTarget");

	Params::NocePlayerClawTransformComponent_HaveAttrackSoulTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.IsClawTransformEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerClawTransformComponent::IsClawTransformEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "IsClawTransformEmpty");

	Params::NocePlayerClawTransformComponent_IsClawTransformEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.IsClawTransformFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerClawTransformComponent::IsClawTransformFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "IsClawTransformFull");

	Params::NocePlayerClawTransformComponent_IsClawTransformFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerClawTransformComponent.OnCanShowWidgetChanged
// (Final, Native, Public)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::OnCanShowWidgetChanged(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "OnCanShowWidgetChanged");

	Params::NocePlayerClawTransformComponent_OnCanShowWidgetChanged Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.OnClawTransformed
// (Final, Native, Protected)
// Parameters:
// bool                                    InIsClawG                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::OnClawTransformed(bool InIsClawG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "OnClawTransformed");

	Params::NocePlayerClawTransformComponent_OnClawTransformed Parms{};

	Parms.InIsClawG = InIsClawG;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.OnEnemyDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsDead                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::OnEnemyDamage(class AActor* InHitActor, float InDamage, bool InIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "OnEnemyDamage");

	Params::NocePlayerClawTransformComponent_OnEnemyDamage Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InDamage = InDamage;
	Parms.InIsDead = InIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.OnPlayerPreDamage
// (Final, Native, Protected)
// Parameters:
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSanityDamage                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::OnPlayerPreDamage(float InHealthDamage, float InMaxSanityDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "OnPlayerPreDamage");

	Params::NocePlayerClawTransformComponent_OnPlayerPreDamage Parms{};

	Parms.InHealthDamage = InHealthDamage;
	Parms.InMaxSanityDamage = InMaxSanityDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.RegisterOnPossessed
// (Final, Native, Protected)

void UNocePlayerClawTransformComponent::RegisterOnPossessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "RegisterOnPossessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.SetAttractSoulWidgetRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::SetAttractSoulWidgetRatio(float InRatio, class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "SetAttractSoulWidgetRatio");

	Params::NocePlayerClawTransformComponent_SetAttractSoulWidgetRatio Parms{};

	Parms.InRatio = InRatio;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.ShowAttrackSoulHintWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::ShowAttrackSoulHintWidget(bool InShow, class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "ShowAttrackSoulHintWidget");

	Params::NocePlayerClawTransformComponent_ShowAttrackSoulHintWidget Parms{};

	Parms.InShow = InShow;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerClawTransformComponent.ShowAttrackSoulWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerClawTransformComponent::ShowAttrackSoulWidget(bool InShow, class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerClawTransformComponent", "ShowAttrackSoulWidget");

	Params::NocePlayerClawTransformComponent_ShowAttrackSoulWidget Parms{};

	Parms.InShow = InShow;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryItem.SetItemImage
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           ImagePath                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryItem::SetItemImage(const struct FSoftObjectPath& ImagePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryItem", "SetItemImage");

	Params::NoceInventoryItem_SetItemImage Parms{};

	Parms.ImagePath = std::move(ImagePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.BackFromEdit
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::BackFromEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "BackFromEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.DisableEdit
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::DisableEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "DisableEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.EnableEdit
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::EnableEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "EnableEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.Equip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSelecting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryConsumableItem::Equip(bool IsSelecting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "Equip");

	Params::NoceInventoryConsumableItem_Equip Parms{};

	Parms.IsSelecting = IsSelecting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.EquipFail
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::EquipFail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "EquipFail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.HideEquipIconGroup
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::HideEquipIconGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "HideEquipIconGroup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.OnBackListCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceInventoryConsumableItem::OnBackListCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "OnBackListCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.OnEquipChangedCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceInventoryConsumableItem::OnEquipChangedCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "OnEquipChangedCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.PlayUnfocusMark
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryConsumableItem::PlayUnfocusMark(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "PlayUnfocusMark");

	Params::NoceInventoryConsumableItem_PlayUnfocusMark Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceInventoryConsumableItem.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryConsumableItem::SetCount(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "SetCount");

	Params::NoceInventoryConsumableItem_SetCount Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.SetDisable
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::SetDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "SetDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryConsumableItem::SetEnable(class FName ID, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "SetEnable");

	Params::NoceInventoryConsumableItem_SetEnable Parms{};

	Parms.ID = ID;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.ToEdit
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryConsumableItem::ToEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "ToEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryConsumableItem.Unequip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSelecting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryConsumableItem::Unequip(bool IsSelecting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryConsumableItem", "Unequip");

	Params::NoceInventoryConsumableItem_Unequip Parms{};

	Parms.IsSelecting = IsSelecting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryEquipmentWidget.SetDefaultIndex
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryEquipmentWidget::SetDefaultIndex(int32 InIndex, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryEquipmentWidget", "SetDefaultIndex");

	Params::NoceInventoryEquipmentWidget_SetDefaultIndex Parms{};

	Parms.InIndex = InIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetCharacterData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookContentData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookContentData UNoceInventoryFunctionLibrary::GetCharacterData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetCharacterData");

	Params::NoceInventoryFunctionLibrary_GetCharacterData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetCharacterNameData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCategoryData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCategoryData UNoceInventoryFunctionLibrary::GetCharacterNameData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetCharacterNameData");

	Params::NoceInventoryFunctionLibrary_GetCharacterNameData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetCharacterPageData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCharacterPageData   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCharacterPageData UNoceInventoryFunctionLibrary::GetCharacterPageData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetCharacterPageData");

	Params::NoceInventoryFunctionLibrary_GetCharacterPageData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetConsumableData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceConsumableData              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceConsumableData UNoceInventoryFunctionLibrary::GetConsumableData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetConsumableData");

	Params::NoceInventoryFunctionLibrary_GetConsumableData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetConsumableRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetConsumableRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetConsumableRowNames");

	Params::NoceInventoryFunctionLibrary_GetConsumableRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetEnemyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookContentData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookContentData UNoceInventoryFunctionLibrary::GetEnemyData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetEnemyData");

	Params::NoceInventoryFunctionLibrary_GetEnemyData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetEnemyNameData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCategoryData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCategoryData UNoceInventoryFunctionLibrary::GetEnemyNameData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetEnemyNameData");

	Params::NoceInventoryFunctionLibrary_GetEnemyNameData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetEnemyPageData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookEnemyPageData       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookEnemyPageData UNoceInventoryFunctionLibrary::GetEnemyPageData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetEnemyPageData");

	Params::NoceInventoryFunctionLibrary_GetEnemyPageData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetExpandInventoryData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceExpandInventoryData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceExpandInventoryData UNoceInventoryFunctionLibrary::GetExpandInventoryData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetExpandInventoryData");

	Params::NoceInventoryFunctionLibrary_GetExpandInventoryData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetExpandInventoryRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetExpandInventoryRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetExpandInventoryRowNames");

	Params::NoceInventoryFunctionLibrary_GetExpandInventoryRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetInfoData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookContentData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookContentData UNoceInventoryFunctionLibrary::GetInfoData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetInfoData");

	Params::NoceInventoryFunctionLibrary_GetInfoData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetInfoNameData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCategoryData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCategoryData UNoceInventoryFunctionLibrary::GetInfoNameData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetInfoNameData");

	Params::NoceInventoryFunctionLibrary_GetInfoNameData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetInfoPageData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookInfoPageData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookInfoPageData UNoceInventoryFunctionLibrary::GetInfoPageData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetInfoPageData");

	Params::NoceInventoryFunctionLibrary_GetInfoPageData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetKeyItemData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceKeyItemData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceKeyItemData UNoceInventoryFunctionLibrary::GetKeyItemData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetKeyItemData");

	Params::NoceInventoryFunctionLibrary_GetKeyItemData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetKeyItemEmaRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetKeyItemEmaRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetKeyItemEmaRowNames");

	Params::NoceInventoryFunctionLibrary_GetKeyItemEmaRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetKeyItemRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetKeyItemRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetKeyItemRowNames");

	Params::NoceInventoryFunctionLibrary_GetKeyItemRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetLetterData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLetterData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLetterData UNoceInventoryFunctionLibrary::GetLetterData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetLetterData");

	Params::NoceInventoryFunctionLibrary_GetLetterData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetLetterGroupData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLetterGroupData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLetterGroupData UNoceInventoryFunctionLibrary::GetLetterGroupData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetLetterGroupData");

	Params::NoceInventoryFunctionLibrary_GetLetterGroupData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetLetterGroupRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetLetterGroupRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetLetterGroupRowNames");

	Params::NoceInventoryFunctionLibrary_GetLetterGroupRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetLetterRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetLetterRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetLetterRowNames");

	Params::NoceInventoryFunctionLibrary_GetLetterRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookCharacterNameRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookCharacterNameRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookCharacterNameRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookCharacterNameRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookCharacterPageRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookCharacterPageRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookCharacterPageRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookCharacterPageRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookCharacterRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookCharacterRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookCharacterRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookCharacterRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookEnemyNameRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookEnemyNameRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookEnemyNameRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookEnemyNameRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookEnemyPageRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookEnemyPageRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookEnemyPageRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookEnemyPageRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookEnemyRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookEnemyRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookEnemyRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookEnemyRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookInfoNameRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookInfoNameRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookInfoNameRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookInfoNameRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookInfoPageRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookInfoPageRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookInfoPageRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookInfoPageRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookInfoRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookInfoRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookInfoRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookInfoRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookPuzzleNameRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookPuzzleNameRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookPuzzleNameRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookPuzzleNameRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookPuzzlePageRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookPuzzlePageRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookPuzzlePageRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookPuzzlePageRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookPuzzleRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookPuzzleRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookPuzzleRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookPuzzleRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookTutorialNameRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookTutorialNameRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookTutorialNameRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookTutorialNameRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookTutorialPageRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookTutorialPageRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookTutorialPageRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookTutorialPageRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetNotebookTutorialRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetNotebookTutorialRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetNotebookTutorialRowNames");

	Params::NoceInventoryFunctionLibrary_GetNotebookTutorialRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetOmamoriData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceOmamoriData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceOmamoriData UNoceInventoryFunctionLibrary::GetOmamoriData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetOmamoriData");

	Params::NoceInventoryFunctionLibrary_GetOmamoriData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetOmamoriRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetOmamoriRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetOmamoriRowNames");

	Params::NoceInventoryFunctionLibrary_GetOmamoriRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetPuzzleData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookMultiContentData    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookMultiContentData UNoceInventoryFunctionLibrary::GetPuzzleData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetPuzzleData");

	Params::NoceInventoryFunctionLibrary_GetPuzzleData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetPuzzleNameData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCategoryData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCategoryData UNoceInventoryFunctionLibrary::GetPuzzleNameData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetPuzzleNameData");

	Params::NoceInventoryFunctionLibrary_GetPuzzleNameData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetPuzzlePageData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookPuzzlePageData      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookPuzzlePageData UNoceInventoryFunctionLibrary::GetPuzzlePageData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetPuzzlePageData");

	Params::NoceInventoryFunctionLibrary_GetPuzzlePageData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetTutorialData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookContentData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookContentData UNoceInventoryFunctionLibrary::GetTutorialData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetTutorialData");

	Params::NoceInventoryFunctionLibrary_GetTutorialData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetTutorialNameData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookCategoryData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookCategoryData UNoceInventoryFunctionLibrary::GetTutorialNameData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetTutorialNameData");

	Params::NoceInventoryFunctionLibrary_GetTutorialNameData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetTutorialPageData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceNotebookTutorialPageData    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceNotebookTutorialPageData UNoceInventoryFunctionLibrary::GetTutorialPageData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetTutorialPageData");

	Params::NoceInventoryFunctionLibrary_GetTutorialPageData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetWeaponData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceWeaponData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceWeaponData UNoceInventoryFunctionLibrary::GetWeaponData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetWeaponData");

	Params::NoceInventoryFunctionLibrary_GetWeaponData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryFunctionLibrary.GetWeaponRowNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNoceInventoryFunctionLibrary::GetWeaponRowNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceInventoryFunctionLibrary", "GetWeaponRowNames");

	Params::NoceInventoryFunctionLibrary_GetWeaponRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryImageDialogWidget.Confirm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInventoryImageDialogWidget::Confirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "Confirm");

	Params::NoceInventoryImageDialogWidget_Confirm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryImageDialogWidget.HideGuide
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryImageDialogWidget::HideGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "HideGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.OnPageAnimationCompleted
// (Final, Native, Protected)

void UNoceInventoryImageDialogWidget::OnPageAnimationCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "OnPageAnimationCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.OnRefreshSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryImageDialogWidget::OnRefreshSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "OnRefreshSelection");

	Params::NoceInventoryImageDialogWidget_OnRefreshSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.SelectNext
// (Final, Native, Protected)

void UNoceInventoryImageDialogWidget::SelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "SelectNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.SelectPrevious
// (Final, Native, Protected)

void UNoceInventoryImageDialogWidget::SelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "SelectPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.SetLetterGroupData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InGroupName                                            (Parm, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InLetterNames                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceInventoryImageDialogWidget::SetLetterGroupData(const class FText& InGroupName, const TArray<class FName>& InLetterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "SetLetterGroupData");

	Params::NoceInventoryImageDialogWidget_SetLetterGroupData Parms{};

	Parms.InGroupName = std::move(InGroupName);
	Parms.InLetterNames = std::move(InLetterNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryImageDialogWidget.UpdateInput
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInputEvent&               InInputEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInventoryImageDialogWidget::UpdateInput(const struct FInputEvent& InInputEvent, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageDialogWidget", "UpdateInput");

	Params::NoceInventoryImageDialogWidget_UpdateInput Parms{};

	Parms.InInputEvent = std::move(InInputEvent);
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInventoryImageWidget.LoadInventoryImage
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryImageWidget::LoadInventoryImage(const struct FSoftObjectPath& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryImageWidget", "LoadInventoryImage");

	Params::NoceInventoryImageWidget_LoadInventoryImage Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddFaithValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddFaithValue(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddFaithValue");

	Params::NocePlayerState_AddFaithValue Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddGeneralMapIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNoceMapGeneralIconData&   InNewData                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::AddGeneralMapIcon(const struct FNoceMapGeneralIconData& InNewData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddGeneralMapIcon");

	Params::NocePlayerState_AddGeneralMapIcon Parms{};

	Parms.InNewData = std::move(InNewData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.AddMapIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconType&          InIconType                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMapIcon(const ENoceDynamicMapIconType& InIconType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMapIcon");

	Params::NocePlayerState_AddMapIcon Parms{};

	Parms.InIconType = InIconType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddMapIconV2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconChapterType&   InChapterType                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceDynamicMapIconIndexType&     InIndexType                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMapIconV2(const ENoceDynamicMapIconChapterType& InChapterType, const ENoceDynamicMapIconIndexType& InIndexType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMapIconV2");

	Params::NocePlayerState_AddMapIconV2 Parms{};

	Parms.InChapterType = InChapterType;
	Parms.InIndexType = InIndexType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddMapLocation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapLocation&                 InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMapLocation(const ENoceMapLocation& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMapLocation");

	Params::NocePlayerState_AddMapLocation Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddMaxHealthLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMaxHealthLevel(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMaxHealthLevel");

	Params::NocePlayerState_AddMaxHealthLevel Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddMaxSanityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMaxSanityLevel(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMaxSanityLevel");

	Params::NocePlayerState_AddMaxSanityLevel Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddMaxStaminaLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddMaxStaminaLevel(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddMaxStaminaLevel");

	Params::NocePlayerState_AddMaxStaminaLevel Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddOmamoriDrawingCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddOmamoriDrawingCount(int32 Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddOmamoriDrawingCount");

	Params::NocePlayerState_AddOmamoriDrawingCount Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddToViewedCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddToViewedCutscene(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddToViewedCutscene");

	Params::NocePlayerState_AddToViewedCutscene Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.AddUpgradeLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::AddUpgradeLevel(ENoceUpgradeType Type, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "AddUpgradeLevel");

	Params::NocePlayerState_AddUpgradeLevel Parms{};

	Parms.Type = Type;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyAllAddMaxByLevel
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ApplyAllAddMaxByLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyAllAddMaxByLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyAttributeRatio
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ApplyAttributeRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyAttributeRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyClawAlterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceClawAlterType                      InClawAlterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::ApplyClawAlterType(ENoceClawAlterType InClawAlterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyClawAlterType");

	Params::NocePlayerState_ApplyClawAlterType Parms{};

	Parms.InClawAlterType = InClawAlterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyFullHealth
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ApplyFullHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyFullHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyFullSanity
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ApplyFullSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyFullSanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyFullStamina
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ApplyFullStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyFullStamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyFullWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::ApplyFullWeaponDurability(const int32 Index_0, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyFullWeaponDurability");

	Params::NocePlayerState_ApplyFullWeaponDurability Parms{};

	Parms.Index_0 = Index_0;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ApplyGameplayEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftClassPath>&    GameplayEffects                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ANocePlayerState::ApplyGameplayEffects(const TArray<struct FSoftClassPath>& GameplayEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ApplyGameplayEffects");

	Params::NocePlayerState_ApplyGameplayEffects Parms{};

	Parms.GameplayEffects = std::move(GameplayEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.BP_AddHealth
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   AddValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::BP_AddHealth(float AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "BP_AddHealth");

	Params::NocePlayerState_BP_AddHealth Parms{};

	Parms.AddValue = AddValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerState.BP_AddSanity
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   AddValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::BP_AddSanity(float AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "BP_AddSanity");

	Params::NocePlayerState_BP_AddSanity Parms{};

	Parms.AddValue = AddValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NocePlayerState.BP_ApplyFullHealth
// (Event, Protected, BlueprintEvent)

void ANocePlayerState::BP_ApplyFullHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "BP_ApplyFullHealth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePlayerState.BP_ApplyFullSanity
// (Event, Protected, BlueprintEvent)

void ANocePlayerState::BP_ApplyFullSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "BP_ApplyFullSanity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePlayerState.BP_ApplyFullStamina
// (Event, Protected, BlueprintEvent)

void ANocePlayerState::BP_ApplyFullStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "BP_ApplyFullStamina");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePlayerState.CanUseConsumableType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InTypeBitmask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumableType(int32 InTypeBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumableType");

	Params::NocePlayerState_CanUseConsumableType Parms{};

	Parms.InTypeBitmask = InTypeBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.CanUseConsumableTypeHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumableTypeHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumableTypeHealth");

	Params::NocePlayerState_CanUseConsumableTypeHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.CanUseConsumaleTypeClawTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumaleTypeClawTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumaleTypeClawTransform");

	Params::NocePlayerState_CanUseConsumaleTypeClawTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.CanUseConsumaleTypeCurrentMaxSanity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumaleTypeCurrentMaxSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumaleTypeCurrentMaxSanity");

	Params::NocePlayerState_CanUseConsumaleTypeCurrentMaxSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.CanUseConsumaleTypeSanity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumaleTypeSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumaleTypeSanity");

	Params::NocePlayerState_CanUseConsumaleTypeSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.CanUseConsumaleTypeWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::CanUseConsumaleTypeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "CanUseConsumaleTypeWeapon");

	Params::NocePlayerState_CanUseConsumaleTypeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.ClaimDLCBoosterPack
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ClaimDLCBoosterPack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ClaimDLCBoosterPack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ClaimDLCOmamori
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ClaimDLCOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ClaimDLCOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.FixWeaponDurabilityByCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Percent                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::FixWeaponDurabilityByCost(ENoceActionLevel ActionLevel, const int32 Index_0, const int32 Percent, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "FixWeaponDurabilityByCost");

	Params::NocePlayerState_FixWeaponDurabilityByCost Parms{};

	Parms.ActionLevel = ActionLevel;
	Parms.Index_0 = Index_0;
	Parms.Percent = Percent;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.GetCanShowSavePointFixWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetCanShowSavePointFixWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetCanShowSavePointFixWeapon");

	Params::NocePlayerState_GetCanShowSavePointFixWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetDisableMultiRoundIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetDisableMultiRoundIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetDisableMultiRoundIcon");

	Params::NocePlayerState_GetDisableMultiRoundIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetEnableMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetEnableMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetEnableMap");

	Params::NocePlayerState_GetEnableMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetEnableSavePointFixWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetEnableSavePointFixWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetEnableSavePointFixWeapon");

	Params::NocePlayerState_GetEnableSavePointFixWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetEnableSavePointOffering
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetEnableSavePointOffering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetEnableSavePointOffering");

	Params::NocePlayerState_GetEnableSavePointOffering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetEnableSavePointUpgrade
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetEnableSavePointUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetEnableSavePointUpgrade");

	Params::NocePlayerState_GetEnableSavePointUpgrade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetFaithItemIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ANocePlayerState::GetFaithItemIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetFaithItemIDs");

	Params::NocePlayerState_GetFaithItemIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetFaithValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetFaithValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetFaithValue");

	Params::NocePlayerState_GetFaithValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetFixCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        InActionLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::GetFixCost(ENoceActionLevel InActionLevel, class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetFixCost");

	Params::NocePlayerState_GetFixCost Parms{};

	Parms.InActionLevel = InActionLevel;
	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetGeneralMapIconData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNoceMapGeneralIconData>* OutResult                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ANocePlayerState::GetGeneralMapIconData(TArray<struct FNoceMapGeneralIconData>* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetGeneralMapIconData");

	Params::NocePlayerState_GetGeneralMapIconData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function GameNoce.NocePlayerState.GetHealthHealAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::GetHealthHealAmount(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetHealthHealAmount");

	Params::NocePlayerState_GetHealthHealAmount Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetHealthHealCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetHealthHealCost(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetHealthHealCost");

	Params::NocePlayerState_GetHealthHealCost Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetHinaCharMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANocePlayerState::GetHinaCharMesh(ENocePlayerType InPlayerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetHinaCharMesh");

	Params::NocePlayerState_GetHinaCharMesh Parms{};

	Parms.InPlayerType = InPlayerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetIsUnderHellModeAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::GetIsUnderHellModeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetIsUnderHellModeAttack");

	Params::NocePlayerState_GetIsUnderHellModeAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetLastMapArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceMapArea                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceMapArea ANocePlayerState::GetLastMapArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetLastMapArea");

	Params::NocePlayerState_GetLastMapArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetLastMissionText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ANocePlayerState::GetLastMissionText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetLastMissionText");

	Params::NocePlayerState_GetLastMissionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMapAreaScale
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapArea&                     InArea                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::GetMapAreaScale(const ENoceMapArea& InArea, float DefaultScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMapAreaScale");

	Params::NocePlayerState_GetMapAreaScale Parms{};

	Parms.InArea = InArea;
	Parms.DefaultScale = DefaultScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMapIconStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconType&          InIconType                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceMapStatus                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceMapStatus ANocePlayerState::GetMapIconStatus(const ENoceDynamicMapIconType& InIconType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMapIconStatus");

	Params::NocePlayerState_GetMapIconStatus Parms{};

	Parms.InIconType = InIconType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMapIconStatusV2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconChapterType&   InChapterType                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceDynamicMapIconIndexType&     InIndexType                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceMapStatus                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceMapStatus ANocePlayerState::GetMapIconStatusV2(const ENoceDynamicMapIconChapterType& InChapterType, const ENoceDynamicMapIconIndexType& InIndexType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMapIconStatusV2");

	Params::NocePlayerState_GetMapIconStatusV2 Parms{};

	Parms.InChapterType = InChapterType;
	Parms.InIndexType = InIndexType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMaxHealthLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetMaxHealthLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMaxHealthLevel");

	Params::NocePlayerState_GetMaxHealthLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMaxSanityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetMaxSanityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMaxSanityLevel");

	Params::NocePlayerState_GetMaxSanityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetMaxStaminaLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetMaxStaminaLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetMaxStaminaLevel");

	Params::NocePlayerState_GetMaxStaminaLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetOmamoriDrawingCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetOmamoriDrawingCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetOmamoriDrawingCount");

	Params::NocePlayerState_GetOmamoriDrawingCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetSanityHealAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::GetSanityHealAmount(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetSanityHealAmount");

	Params::NocePlayerState_GetSanityHealAmount Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetSanityHealCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetSanityHealCost(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetSanityHealCost");

	Params::NocePlayerState_GetSanityHealCost Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetSanityHealRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::GetSanityHealRatio(ENoceActionLevel ActionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetSanityHealRatio");

	Params::NocePlayerState_GetSanityHealRatio Parms{};

	Parms.ActionLevel = ActionLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetUpgradeLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetUpgradeLevel(ENoceUpgradeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetUpgradeLevel");

	Params::NocePlayerState_GetUpgradeLevel Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.GetWeaponDurabilityFixCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANocePlayerState::GetWeaponDurabilityFixCost(ENoceActionLevel ActionLevel, const int32 Index_0, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "GetWeaponDurabilityFixCost");

	Params::NocePlayerState_GetWeaponDurabilityFixCost Parms{};

	Parms.ActionLevel = ActionLevel;
	Parms.Index_0 = Index_0;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HasBroochKeyItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::HasBroochKeyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HasBroochKeyItem");

	Params::NocePlayerState_HasBroochKeyItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HasExorcismPotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::HasExorcismPotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HasExorcismPotion");

	Params::NocePlayerState_HasExorcismPotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HasMapLocation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapLocation&                 InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::HasMapLocation(const ENoceMapLocation& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HasMapLocation");

	Params::NocePlayerState_HasMapLocation Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HasSacredSword
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::HasSacredSword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HasSacredSword");

	Params::NocePlayerState_HasSacredSword Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HasUsedDebugTeleport
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::HasUsedDebugTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HasUsedDebugTeleport");

	Params::NocePlayerState_HasUsedDebugTeleport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.HealHealthByCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::HealHealthByCost(ENoceActionLevel ActionLevel, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HealHealthByCost");

	Params::NocePlayerState_HealHealthByCost Parms{};

	Parms.ActionLevel = ActionLevel;
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.HealSanityByCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceActionLevel                        ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::HealSanityByCost(ENoceActionLevel ActionLevel, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "HealSanityByCost");

	Params::NocePlayerState_HealSanityByCost Parms{};

	Parms.ActionLevel = ActionLevel;
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.IsClawAlterTypeApplied
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceClawAlterType                      InClawAlterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsClawAlterTypeApplied(ENoceClawAlterType InClawAlterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsClawAlterTypeApplied");

	Params::NocePlayerState_IsClawAlterTypeApplied Parms{};

	Parms.InClawAlterType = InClawAlterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsDLCBoosterPackClaimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsDLCBoosterPackClaimed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsDLCBoosterPackClaimed");

	Params::NocePlayerState_IsDLCBoosterPackClaimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsDLCOmamoriClaimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsDLCOmamoriClaimed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsDLCOmamoriClaimed");

	Params::NocePlayerState_IsDLCOmamoriClaimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsFullHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsFullHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsFullHealth");

	Params::NocePlayerState_IsFullHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsFullSanity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsFullSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsFullSanity");

	Params::NocePlayerState_IsFullSanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsFullWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsFullWeaponDurability(const int32 Index_0, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsFullWeaponDurability");

	Params::NocePlayerState_IsFullWeaponDurability Parms{};

	Parms.Index_0 = Index_0;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsNewCutscene
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsNewCutscene(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsNewCutscene");

	Params::NocePlayerState_IsNewCutscene Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsNotebookHintBlocked
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsBlocked                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::IsNotebookHintBlocked(bool* IsBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsNotebookHintBlocked");

	Params::NocePlayerState_IsNotebookHintBlocked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsBlocked != nullptr)
		*IsBlocked = Parms.IsBlocked;
}


// Function GameNoce.NocePlayerState.IsRestrictionMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsRestrictionMatch(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsRestrictionMatch");

	Params::NocePlayerState_IsRestrictionMatch Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsRestrictionMatchFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerRestriction                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsRestrictionMatchFlag(ENocePlayerRestriction Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsRestrictionMatchFlag");

	Params::NocePlayerState_IsRestrictionMatchFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsStoryEndingBranchMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsStoryEndingBranchMatch(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsStoryEndingBranchMatch");

	Params::NocePlayerState_IsStoryEndingBranchMatch Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.IsStoryEndingBranchMatchFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceStoryEndingBranch                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePlayerState::IsStoryEndingBranchMatchFlag(ENoceStoryEndingBranch Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "IsStoryEndingBranchMatchFlag");

	Params::NocePlayerState_IsStoryEndingBranchMatchFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.MassRemoveMapIconV2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<ENoceDynamicMapIconChapterType>&InChapterTypes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TMap<ENoceDynamicMapIconChapterType, struct FNoceMapDynamicIconArray>&InExceptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ANocePlayerState::MassRemoveMapIconV2(const TArray<ENoceDynamicMapIconChapterType>& InChapterTypes, const TMap<ENoceDynamicMapIconChapterType, struct FNoceMapDynamicIconArray>& InExceptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "MassRemoveMapIconV2");

	Params::NocePlayerState_MassRemoveMapIconV2 Parms{};

	Parms.InChapterTypes = std::move(InChapterTypes);
	Parms.InExceptions = std::move(InExceptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OmamoriRandRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePlayerState::OmamoriRandRange(float InMin, float InMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OmamoriRandRange");

	Params::NocePlayerState_OmamoriRandRange Parms{};

	Parms.InMin = InMin;
	Parms.InMax = InMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerState.OnAddNewItem
// (Final, Native, Protected)
// Parameters:
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnAddNewItem(ENoceInventoryType InventoryType, class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnAddNewItem");

	Params::NocePlayerState_OnAddNewItem Parms{};

	Parms.InventoryType = InventoryType;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnAddNewWeapon
// (Final, Native, Protected)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnAddNewWeapon(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnAddNewWeapon");

	Params::NocePlayerState_OnAddNewWeapon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnBeforeChangeWeapon
// (Final, Native, Protected)

void ANocePlayerState::OnBeforeChangeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnBeforeChangeWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnChangeOmamori
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OldID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnChangeOmamori(int32 Index_0, class FName OldID, class FName NewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnChangeOmamori");

	Params::NocePlayerState_OnChangeOmamori Parms{};

	Parms.Index_0 = Index_0;
	Parms.OldID = OldID;
	Parms.NewID = NewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnChangeWeapon
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnChangeWeapon(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnChangeWeapon");

	Params::NocePlayerState_OnChangeWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnDiscardEquippedWeapon
// (Final, Native, Protected)

void ANocePlayerState::OnDiscardEquippedWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnDiscardEquippedWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnSetOmamoriSlotNum
// (Final, Native, Protected)
// Parameters:
// int32                                   NewSlotNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnSetOmamoriSlotNum(int32 NewSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnSetOmamoriSlotNum");

	Params::NocePlayerState_OnSetOmamoriSlotNum Parms{};

	Parms.NewSlotNum = NewSlotNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnUseConsumableItem
// (Final, Native, Protected)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnUseConsumableItem(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnUseConsumableItem");

	Params::NocePlayerState_OnUseConsumableItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnWeaponChanged
// (Final, Native, Protected)
// Parameters:
// class ANoceWeapon*                      NewWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnWeaponChanged(class ANoceWeapon* NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnWeaponChanged");

	Params::NocePlayerState_OnWeaponChanged Parms{};

	Parms.NewWeapon = NewWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.OnWeaponDurabilityChanged
// (Final, Native, Protected)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurability                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsDiscarded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsBroken                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::OnWeaponDurabilityChanged(class FName InWeaponName, float InDurability, bool InIsDiscarded, bool InIsBroken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "OnWeaponDurabilityChanged");

	Params::NocePlayerState_OnWeaponDurabilityChanged Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDurability = InDurability;
	Parms.InIsDiscarded = InIsDiscarded;
	Parms.InIsBroken = InIsBroken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RecordAttributeRatio
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::RecordAttributeRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RecordAttributeRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RefreshGameplayTagsForClawAlterType
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::RefreshGameplayTagsForClawAlterType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RefreshGameplayTagsForClawAlterType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveAllAddMaxByLevel
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::RemoveAllAddMaxByLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveAllAddMaxByLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveClawAlterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceClawAlterType                      InClawAlterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveClawAlterType(ENoceClawAlterType InClawAlterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveClawAlterType");

	Params::NocePlayerState_RemoveClawAlterType Parms{};

	Parms.InClawAlterType = InClawAlterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveFromViewedCutscene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveFromViewedCutscene(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveFromViewedCutscene");

	Params::NocePlayerState_RemoveFromViewedCutscene Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveGameplayEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftClassPath>&    GameplayEffects                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveGameplayEffects(const TArray<struct FSoftClassPath>& GameplayEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveGameplayEffects");

	Params::NocePlayerState_RemoveGameplayEffects Parms{};

	Parms.GameplayEffects = std::move(GameplayEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveMapIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconType&          InIconType                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveMapIcon(const ENoceDynamicMapIconType& InIconType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveMapIcon");

	Params::NocePlayerState_RemoveMapIcon Parms{};

	Parms.InIconType = InIconType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveMapIconV2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconChapterType&   InChapterType                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceDynamicMapIconIndexType&     InIndexType                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveMapIconV2(const ENoceDynamicMapIconChapterType& InChapterType, const ENoceDynamicMapIconIndexType& InIndexType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveMapIconV2");

	Params::NocePlayerState_RemoveMapIconV2 Parms{};

	Parms.InChapterType = InChapterType;
	Parms.InIndexType = InIndexType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveMapLocation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapLocation&                 InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveMapLocation(const ENoceMapLocation& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveMapLocation");

	Params::NocePlayerState_RemoveMapLocation Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveRestriction(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveRestriction");

	Params::NocePlayerState_RemoveRestriction Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveRestrictionFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerRestriction                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveRestrictionFlag(ENocePlayerRestriction Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveRestrictionFlag");

	Params::NocePlayerState_RemoveRestrictionFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveStoryEndingBranch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveStoryEndingBranch(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveStoryEndingBranch");

	Params::NocePlayerState_RemoveStoryEndingBranch Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.RemoveStoryEndingBranchFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceStoryEndingBranch                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::RemoveStoryEndingBranchFlag(ENoceStoryEndingBranch Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "RemoveStoryEndingBranchFlag");

	Params::NocePlayerState_RemoveStoryEndingBranchFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.ResetForTheNewRound
// (Final, Native, Public, BlueprintCallable)

void ANocePlayerState::ResetForTheNewRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "ResetForTheNewRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetDisableMultiRoundIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InDisableMultiRoundIcon                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetDisableMultiRoundIcon(bool InDisableMultiRoundIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetDisableMultiRoundIcon");

	Params::NocePlayerState_SetDisableMultiRoundIcon Parms{};

	Parms.InDisableMultiRoundIcon = InDisableMultiRoundIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetEnableMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnableMap                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetEnableMap(bool InEnableMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetEnableMap");

	Params::NocePlayerState_SetEnableMap Parms{};

	Parms.InEnableMap = InEnableMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetEnableSavePointFixWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetEnableSavePointFixWeapon(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetEnableSavePointFixWeapon");

	Params::NocePlayerState_SetEnableSavePointFixWeapon Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetEnableSavePointOffering
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetEnableSavePointOffering(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetEnableSavePointOffering");

	Params::NocePlayerState_SetEnableSavePointOffering Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetEnableSavePointUpgrade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetEnableSavePointUpgrade(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetEnableSavePointUpgrade");

	Params::NocePlayerState_SetEnableSavePointUpgrade Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetHinaCharMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerType                         InPlayerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCharMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetHinaCharMesh(ENocePlayerType InPlayerType, class FName InCharMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetHinaCharMesh");

	Params::NocePlayerState_SetHinaCharMesh Parms{};

	Parms.InPlayerType = InPlayerType;
	Parms.InCharMesh = InCharMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetIsUnderHellModeAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetIsUnderHellModeAttack(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetIsUnderHellModeAttack");

	Params::NocePlayerState_SetIsUnderHellModeAttack Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetLastMapArea
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapArea&                     InArea                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetLastMapArea(const ENoceMapArea& InArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetLastMapArea");

	Params::NocePlayerState_SetLastMapArea Parms{};

	Parms.InArea = InArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetLastMissionText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void ANocePlayerState::SetLastMissionText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetLastMissionText");

	Params::NocePlayerState_SetLastMissionText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetMapAreaScale
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceMapArea&                     InArea                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            InScale                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetMapAreaScale(const ENoceMapArea& InArea, const float& InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetMapAreaScale");

	Params::NocePlayerState_SetMapAreaScale Parms{};

	Parms.InArea = InArea;
	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetMapIconStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconType&          InIconType                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceMapStatus&                   InStatus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetMapIconStatus(const ENoceDynamicMapIconType& InIconType, const ENoceMapStatus& InStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetMapIconStatus");

	Params::NocePlayerState_SetMapIconStatus Parms{};

	Parms.InIconType = InIconType;
	Parms.InStatus = InStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetMapIconStatusV2
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceDynamicMapIconChapterType&   InChapterType                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceDynamicMapIconIndexType&     InIndexType                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceMapStatus&                   InStatus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetMapIconStatusV2(const ENoceDynamicMapIconChapterType& InChapterType, const ENoceDynamicMapIconIndexType& InIndexType, const ENoceMapStatus& InStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetMapIconStatusV2");

	Params::NocePlayerState_SetMapIconStatusV2 Parms{};

	Parms.InChapterType = InChapterType;
	Parms.InIndexType = InIndexType;
	Parms.InStatus = InStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetRestriction(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetRestriction");

	Params::NocePlayerState_SetRestriction Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetRestrictionFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENocePlayerRestriction                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetRestrictionFlag(ENocePlayerRestriction Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetRestrictionFlag");

	Params::NocePlayerState_SetRestrictionFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetStoryEndingBranch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetStoryEndingBranch(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetStoryEndingBranch");

	Params::NocePlayerState_SetStoryEndingBranch Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetStoryEndingBranchFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceStoryEndingBranch                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetStoryEndingBranchFlag(ENoceStoryEndingBranch Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetStoryEndingBranchFlag");

	Params::NocePlayerState_SetStoryEndingBranchFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.SetUsedDebugTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::SetUsedDebugTeleport(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "SetUsedDebugTeleport");

	Params::NocePlayerState_SetUsedDebugTeleport Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.UpdateGeneralMapIconVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::UpdateGeneralMapIconVisibility(int32 Index_0, bool InIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "UpdateGeneralMapIconVisibility");

	Params::NocePlayerState_UpdateGeneralMapIconVisibility Parms{};

	Parms.Index_0 = Index_0;
	Parms.InIsVisible = InIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerState.UpdateLastSavePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InSavePointActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePlayerState::UpdateLastSavePoint(class AActor* InSavePointActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerState", "UpdateLastSavePoint");

	Params::NocePlayerState_UpdateLastSavePoint Parms{};

	Parms.InSavePointActor = InSavePointActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.AttachScabbardToHand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::AttachScabbardToHand(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "AttachScabbardToHand");

	Params::NocePlayerKatanaComponent_AttachScabbardToHand Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.CanAutoAbilityBasic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerKatanaComponent::CanAutoAbilityBasic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "CanAutoAbilityBasic");

	Params::NocePlayerKatanaComponent_CanAutoAbilityBasic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerKatanaComponent.HandleHideWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::HandleHideWeapon(bool InHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "HandleHideWeapon");

	Params::NocePlayerKatanaComponent_HandleHideWeapon Parms{};

	Parms.InHide = InHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "HandleOnPossessed");

	Params::NocePlayerKatanaComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.HandlePlayerShowHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::HandlePlayerShowHide(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "HandlePlayerShowHide");

	Params::NocePlayerKatanaComponent_HandlePlayerShowHide Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.OnAddNewWeapon
// (Final, Native, Protected)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::OnAddNewWeapon(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "OnAddNewWeapon");

	Params::NocePlayerKatanaComponent_OnAddNewWeapon Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.OnChangeWeapon
// (Final, Native, Protected)
// Parameters:
// int32                                   InNewIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::OnChangeWeapon(int32 InNewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "OnChangeWeapon");

	Params::NocePlayerKatanaComponent_OnChangeWeapon Parms{};

	Parms.InNewIndex = InNewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.OnDiscardWeapon
// (Final, Native, Protected)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::OnDiscardWeapon(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "OnDiscardWeapon");

	Params::NocePlayerKatanaComponent_OnDiscardWeapon Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.OnEnemyDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsDead                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::OnEnemyDamage(class AActor* InHitActor, float InDamage, bool InIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "OnEnemyDamage");

	Params::NocePlayerKatanaComponent_OnEnemyDamage Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InDamage = InDamage;
	Parms.InIsDead = InIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.OnGameplayTagChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::OnGameplayTagChanged(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "OnGameplayTagChanged");

	Params::NocePlayerKatanaComponent_OnGameplayTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerKatanaComponent.ShowScabbardKatana
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerKatanaComponent::ShowScabbardKatana(bool InShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerKatanaComponent", "ShowScabbardKatana");

	Params::NocePlayerKatanaComponent_ShowScabbardKatana Parms{};

	Parms.InShow = InShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListItemWidget.EquipFailed
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryListItemWidget::EquipFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListItemWidget", "EquipFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListItemWidget.OnSelectEquipFailCompleted
// (Final, Native, Protected)

void UNoceInventoryListItemWidget::OnSelectEquipFailCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListItemWidget", "OnSelectEquipFailCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListItemWidget.OnSelectToEquipCompleted
// (Final, Native, Protected)

void UNoceInventoryListItemWidget::OnSelectToEquipCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListItemWidget", "OnSelectToEquipCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListItemWidget.PlaySelectToEquip
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryListItemWidget::PlaySelectToEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListItemWidget", "PlaySelectToEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListItemWidget.RefreshEquipped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsEquipped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryListItemWidget::RefreshEquipped(bool InIsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListItemWidget", "RefreshEquipped");

	Params::NoceInventoryListItemWidget_RefreshEquipped Parms{};

	Parms.InIsEquipped = InIsEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.DiscardItem
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryListWidget::DiscardItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "DiscardItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.PlayEquipFailed
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryListWidget::PlayEquipFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "PlayEquipFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.RefreshEquipped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              EquippedItem                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceInventoryListWidget::RefreshEquipped(const TArray<class FName>& EquippedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "RefreshEquipped");

	Params::NoceInventoryListWidget_RefreshEquipped Parms{};

	Parms.EquippedItem = std::move(EquippedItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.SelectItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryListWidget::SelectItem(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "SelectItem");

	Params::NoceInventoryListWidget_SelectItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.SetAllData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UInventoryItemListObject*>&Items                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceInventoryListWidget::SetAllData(const TArray<class UInventoryItemListObject*>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "SetAllData");

	Params::NoceInventoryListWidget_SetAllData Parms{};

	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.SetConsumableData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FNoceInventoryConsumable>&Items                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              EquippedItems                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   InPointNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InEmaNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryListWidget::SetConsumableData(const TArray<struct FNoceInventoryConsumable>& Items, const TArray<class FName>& EquippedItems, int32 InPointNum, int32 InEmaNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "SetConsumableData");

	Params::NoceInventoryListWidget_SetConsumableData Parms{};

	Parms.Items = std::move(Items);
	Parms.EquippedItems = std::move(EquippedItems);
	Parms.InPointNum = InPointNum;
	Parms.InEmaNum = InEmaNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryListWidget.SetOmamoriData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FNoceInventoryData>&Items                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              EquippedItems                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceInventoryListWidget::SetOmamoriData(const TArray<struct FNoceInventoryData>& Items, const TArray<class FName>& EquippedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryListWidget", "SetOmamoriData");

	Params::NoceInventoryListWidget_SetOmamoriData Parms{};

	Parms.Items = std::move(Items);
	Parms.EquippedItems = std::move(EquippedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowBtnWidget.UpdateText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InActionName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      InBtnText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNocePopWindowBtnWidget::UpdateText(const class FName& InActionName, const class FText& InBtnText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowBtnWidget", "UpdateText");

	Params::NocePopWindowBtnWidget_UpdateText Parms{};

	Parms.InActionName = InActionName;
	Parms.InBtnText = std::move(InBtnText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryPopWindowWidget.ShowAddSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   OldSlotNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewSlotNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryPopWindowWidget::ShowAddSlot(int32 OldSlotNum, int32 NewSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryPopWindowWidget", "ShowAddSlot");

	Params::NoceInventoryPopWindowWidget_ShowAddSlot Parms{};

	Parms.OldSlotNum = OldSlotNum;
	Parms.NewSlotNum = NewSlotNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMeshDissolveComponent.OnDie
// (Final, Native, Protected)

void UNoceMeshDissolveComponent::OnDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMeshDissolveComponent", "OnDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTabChildWidget.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceTabChildWidget::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTabChildWidget", "SetText");

	Params::NoceTabChildWidget_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerShowHideComponent.GetIsOverlapingPlayerMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerShowHideComponent::GetIsOverlapingPlayerMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerShowHideComponent", "GetIsOverlapingPlayerMesh");

	Params::NocePlayerShowHideComponent_GetIsOverlapingPlayerMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerShowHideComponent.SetForceUpateIsOverlapingPlayerMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerShowHideComponent::SetForceUpateIsOverlapingPlayerMesh(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerShowHideComponent", "SetForceUpateIsOverlapingPlayerMesh");

	Params::NocePlayerShowHideComponent_SetForceUpateIsOverlapingPlayerMesh Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerShowHideComponent.UpdateTickCallBack
// (Final, Native, Public)

void UNocePlayerShowHideComponent::UpdateTickCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerShowHideComponent", "UpdateTickCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponItem.Discard
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryWeaponItem::Discard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponItem", "Discard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponItem.Equip
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryWeaponItem::Equip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponItem", "Equip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponItem.OnEquipSelectDropCompleted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNoceInventoryWeaponItem::OnEquipSelectDropCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponItem", "OnEquipSelectDropCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponItem.Unequip
// (Final, Native, Public, BlueprintCallable)

void UNoceInventoryWeaponItem::Unequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponItem", "Unequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponWidget.OnListMouseConfirm
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryWeaponWidget::OnListMouseConfirm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponWidget", "OnListMouseConfirm");

	Params::NoceInventoryWeaponWidget_OnListMouseConfirm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponWidget.OnPopWindowClose
// (Final, Native, Protected)

void UNoceInventoryWeaponWidget::OnPopWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponWidget", "OnPopWindowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInventoryWeaponWidget.UpdateSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInventoryWeaponWidget::UpdateSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInventoryWeaponWidget", "UpdateSelection");

	Params::NoceInventoryWeaponWidget_UpdateSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInvincibleComponent.EndInvincible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInvincibleComponent::EndInvincible(class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "EndInvincible");

	Params::NoceInvincibleComponent_EndInvincible Parms{};

	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInvincibleComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInvincibleComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "HandleOnPossessed");

	Params::NoceInvincibleComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInvincibleComponent.IsInvincible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInvincibleComponent::IsInvincible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "IsInvincible");

	Params::NoceInvincibleComponent_IsInvincible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInvincibleComponent.IsTokenInvincible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceInvincibleComponent::IsTokenInvincible(class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "IsTokenInvincible");

	Params::NoceInvincibleComponent_IsTokenInvincible Parms{};

	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceInvincibleComponent.OnTimerUp
// (Final, Native, Protected)

void UNoceInvincibleComponent::OnTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "OnTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInvincibleComponent.StartInvincible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInvincibleComponent::StartInvincible(class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "StartInvincible");

	Params::NoceInvincibleComponent_StartInvincible Parms{};

	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceInvincibleComponent.StartInvincibleWithDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InToken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceInvincibleComponent::StartInvincibleWithDuration(float InDuration, class FName InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceInvincibleComponent", "StartInvincibleWithDuration");

	Params::NoceInvincibleComponent_StartInvincibleWithDuration Parms{};

	Parms.InDuration = InDuration;
	Parms.InToken = InToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceItemChildGroupWidget.Init
// (Final, Native, Public, BlueprintCallable)

void UNoceItemChildGroupWidget::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemChildGroupWidget", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceItemChildGroupWidget.SetNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TotalNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceItemChildGroupWidget::SetNum(int32 TotalNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemChildGroupWidget", "SetNum");

	Params::NoceItemChildGroupWidget_SetNum Parms{};

	Parms.TotalNum = TotalNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerFunctionLibrary.CanPlayerActivateTrigger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::CanPlayerActivateTrigger(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "CanPlayerActivateTrigger");

	Params::NocePlayerFunctionLibrary_CanPlayerActivateTrigger Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.GetNocePlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerController* UNocePlayerFunctionLibrary::GetNocePlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "GetNocePlayerController");

	Params::NocePlayerFunctionLibrary_GetNocePlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.GetNocePlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANocePlayerState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerState* UNocePlayerFunctionLibrary::GetNocePlayerState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "GetNocePlayerState");

	Params::NocePlayerFunctionLibrary_GetNocePlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.GetPlayerCameraLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNocePlayerFunctionLibrary::GetPlayerCameraLocation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "GetPlayerCameraLocation");

	Params::NocePlayerFunctionLibrary_GetPlayerCameraLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.GetPlayerCameraRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UNocePlayerFunctionLibrary::GetPlayerCameraRotation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "GetPlayerCameraRotation");

	Params::NocePlayerFunctionLibrary_GetPlayerCameraRotation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.GetRandomLocationAroundPlayer
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InPlayer                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNocePlayerFunctionLibrary::GetRandomLocationAroundPlayer(const class AActor* InPlayer, float InDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "GetRandomLocationAroundPlayer");

	Params::NocePlayerFunctionLibrary_GetRandomLocationAroundPlayer Parms{};

	Parms.InPlayer = InPlayer;
	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsActorInPlayerSightViewRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 RangeX                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 RangeY                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsActorInPlayerSightViewRange(const class AActor* InActor, const struct FVector2D& RangeX, const struct FVector2D& RangeY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsActorInPlayerSightViewRange");

	Params::NocePlayerFunctionLibrary_IsActorInPlayerSightViewRange Parms{};

	Parms.InActor = InActor;
	Parms.RangeX = std::move(RangeX);
	Parms.RangeY = std::move(RangeY);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsActorVisuallyBlocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsActorVisuallyBlocked(const class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsActorVisuallyBlocked");

	Params::NocePlayerFunctionLibrary_IsActorVisuallyBlocked Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsCurrentDarkHinako
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsCurrentDarkHinako(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsCurrentDarkHinako");

	Params::NocePlayerFunctionLibrary_IsCurrentDarkHinako Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsCurrentFogHinako
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsCurrentFogHinako(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsCurrentFogHinako");

	Params::NocePlayerFunctionLibrary_IsCurrentFogHinako Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsInPlayerFrustum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsInPlayerFrustum(const class AActor* InActor, float SphereRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsInPlayerFrustum");

	Params::NocePlayerFunctionLibrary_IsInPlayerFrustum Parms{};

	Parms.InActor = InActor;
	Parms.SphereRatio = SphereRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsPointInPlayerFrustum
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWorld*                     InWorld                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsPointInPlayerFrustum(const class UWorld* InWorld, const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsPointInPlayerFrustum");

	Params::NocePlayerFunctionLibrary_IsPointInPlayerFrustum Parms{};

	Parms.InWorld = InWorld;
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsPointInPlayerSightViewRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     InPlayer                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 RangeX                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 RangeY                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsPointInPlayerSightViewRange(const struct FVector& InPoint, const class AActor* InPlayer, const struct FVector2D& RangeX, const struct FVector2D& RangeY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsPointInPlayerSightViewRange");

	Params::NocePlayerFunctionLibrary_IsPointInPlayerSightViewRange Parms{};

	Parms.InPoint = std::move(InPoint);
	Parms.InPlayer = InPlayer;
	Parms.RangeX = std::move(RangeX);
	Parms.RangeY = std::move(RangeY);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsPointVisuallyBlocked
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWorld*                     InWorld                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsShowDebugLine                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsPointVisuallyBlocked(const class UWorld* InWorld, const struct FVector& InPoint, const class AActor* InActor, bool IsShowDebugLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsPointVisuallyBlocked");

	Params::NocePlayerFunctionLibrary_IsPointVisuallyBlocked Parms{};

	Parms.InWorld = InWorld;
	Parms.InPoint = std::move(InPoint);
	Parms.InActor = InActor;
	Parms.IsShowDebugLine = IsShowDebugLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.IsSphereInPlayerFrustum
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    InObject                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerFunctionLibrary::IsSphereInPlayerFrustum(const class UObject* InObject, const struct FVector& Point, float SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "IsSphereInPlayerFrustum");

	Params::NocePlayerFunctionLibrary_IsSphereInPlayerFrustum Parms{};

	Parms.InObject = InObject;
	Parms.Point = std::move(Point);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerFunctionLibrary.SimulateNoceInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInputAction                        InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerFunctionLibrary::SimulateNoceInputAction(const class UObject* WorldContextObject, ENoceInputAction InputAction, bool IsPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePlayerFunctionLibrary", "SimulateNoceInputAction");

	Params::NocePlayerFunctionLibrary_SimulateNoceInputAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputAction = InputAction;
	Parms.IsPressed = IsPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceItemShortcutItemWidget.SelectMark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Select                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceItemShortcutItemWidget::SelectMark(bool Select)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemShortcutItemWidget", "SelectMark");

	Params::NoceItemShortcutItemWidget_SelectMark Parms{};

	Parms.Select = Select;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceItemShortcutItemWidget.SetItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsDisable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceItemShortcutItemWidget::SetItem(bool InIsDisable, class FName InID, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemShortcutItemWidget", "SetItem");

	Params::NoceItemShortcutItemWidget_SetItem Parms{};

	Parms.InIsDisable = InIsDisable;
	Parms.InID = InID;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceItemSubsystem.GetSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FNoceActorRecord>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceActorRecord> UNoceItemSubsystem::GetSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemSubsystem", "GetSaveData");

	Params::NoceItemSubsystem_GetSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceItemSubsystem.IsSaveDataExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceItemSubsystem::IsSaveDataExist(class ANoceInteractableBase* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemSubsystem", "IsSaveDataExist");

	Params::NoceItemSubsystem_IsSaveDataExist Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceItemSubsystem.RegisterSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceItemSubsystem::RegisterSaveData(class ANoceInteractableBase* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceItemSubsystem", "RegisterSaveData");

	Params::NoceItemSubsystem_RegisterSaveData Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceKanbanWidget.ShowText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceKanbanWidget::ShowText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceKanbanWidget", "ShowText");

	Params::NoceKanbanWidget_ShowText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceKeyBindingWidget.ApplyModifiedKeys
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceKeyBindingWidget::ApplyModifiedKeys(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceKeyBindingWidget", "ApplyModifiedKeys");

	Params::NoceKeyBindingWidget_ApplyModifiedKeys Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NocePostProcessVolume.OnExitNotebook
// (Final, Native, Protected)

void ANocePostProcessVolume::OnExitNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessVolume", "OnExitNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessVolume.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePostProcessVolume::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessVolume", "OnGameProgressChanged");

	Params::NocePostProcessVolume_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessVolume.OnGameProgressInitialized
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePostProcessVolume::OnGameProgressInitialized(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessVolume", "OnGameProgressInitialized");

	Params::NocePostProcessVolume_OnGameProgressInitialized Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePostProcessVolume.OnOpenNotebook
// (Final, Native, Protected)

void ANocePostProcessVolume::OnOpenNotebook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePostProcessVolume", "OnOpenNotebook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceKuzunohaIconWidget.ResetAnimations
// (Final, Native, Public, BlueprintCallable)

void UNoceKuzunohaIconWidget::ResetAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceKuzunohaIconWidget", "ResetAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLetterPointGroupWidget.UpdateIsNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<bool>&                     IsNew                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceLetterPointGroupWidget::UpdateIsNew(const TArray<bool>& IsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLetterPointGroupWidget", "UpdateIsNew");

	Params::NoceLetterPointGroupWidget_UpdateIsNew Parms{};

	Parms.IsNew = std::move(IsNew);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLetterPointWidget.SetIsNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsNew                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLetterPointWidget::SetIsNew(bool IsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLetterPointWidget", "SetIsNew");

	Params::NoceLetterPointWidget_SetIsNew Parms{};

	Parms.IsNew = IsNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.CanApplyLookAtIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerPPAnimInstance::CanApplyLookAtIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "CanApplyLookAtIK");

	Params::NocePlayerPPAnimInstance_CanApplyLookAtIK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerPPAnimInstance.OnAttackTraceHit
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<struct FNoceAttackHitResult>&InHitResults                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNocePlayerPPAnimInstance::OnAttackTraceHit(const TArray<struct FNoceAttackHitResult>& InHitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "OnAttackTraceHit");

	Params::NocePlayerPPAnimInstance_OnAttackTraceHit Parms{};

	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyAimIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePlayerPPAnimInstance::UpdateApplyAimIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyAimIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyFootIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerPPAnimInstance::UpdateApplyFootIK(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyFootIK");

	Params::NocePlayerPPAnimInstance_UpdateApplyFootIK Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyFullBodyIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePlayerPPAnimInstance::UpdateApplyFullBodyIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyFullBodyIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyLookAtIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerPPAnimInstance::UpdateApplyLookAtIK(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyLookAtIK");

	Params::NocePlayerPPAnimInstance_UpdateApplyLookAtIK Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyPoseDriver
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePlayerPPAnimInstance::UpdateApplyPoseDriver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyPoseDriver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateApplyRigidBody
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePlayerPPAnimInstance::UpdateApplyRigidBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateApplyRigidBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateAttachObject
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UNocePlayerPPAnimInstance::UpdateAttachObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateAttachObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerPPAnimInstance.UpdateFootIK
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerPPAnimInstance::UpdateFootIK(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerPPAnimInstance", "UpdateFootIK");

	Params::NocePlayerPPAnimInstance_UpdateFootIK Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLetterTabWidget.Init
// (Final, Native, Public, BlueprintCallable)

void UNoceLetterTabWidget::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLetterTabWidget", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLetterTabWidget.SetLetters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CurrentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceLetterTabWidget::SetLetters(int32 CurrentIndex, int32 TotalNum, const TArray<bool>& IsNews)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLetterTabWidget", "SetLetters");

	Params::NoceLetterTabWidget_SetLetters Parms{};

	Parms.CurrentIndex = CurrentIndex;
	Parms.TotalNum = TotalNum;
	Parms.IsNews = std::move(IsNews);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.AddFSMClassReferenceByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InClassName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USMInstance*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USMInstance* UNoceLevelFunctionLibrary::AddFSMClassReferenceByName(class AActor* InActor, const class FString& InClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "AddFSMClassReferenceByName");

	Params::NoceLevelFunctionLibrary_AddFSMClassReferenceByName Parms{};

	Parms.InActor = InActor;
	Parms.InClassName = std::move(InClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyDarknessDataToMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDarknessSetting&      InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     TargetComp                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyDarknessDataToMaterial(class UObject* WorldContextObject, const struct FNoceDarknessSetting& InData, class UMaterialParameterCollection* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyDarknessDataToMaterial");

	Params::NoceLevelFunctionLibrary_ApplyDarknessDataToMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyDirectionalLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceDirectionalLightSetting&InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyDirectionalLightData(const struct FNoceDirectionalLightSetting& InData, class UDirectionalLightComponent* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyDirectionalLightData");

	Params::NoceLevelFunctionLibrary_ApplyDirectionalLightData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyExpFogDataToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceExpFogSetting&        InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UExponentialHeightFogComponent*   TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyExpFogDataToComponent(const struct FNoceExpFogSetting& InData, class UExponentialHeightFogComponent* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyExpFogDataToComponent");

	Params::NoceLevelFunctionLibrary_ApplyExpFogDataToComponent Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyFogNiagaraParameterCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceFogNiagaraSetting&    InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*InNPCEnvFog                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*InAllAreaFog                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*InHellSmoke                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyFogNiagaraParameterCollection(const struct FNoceFogNiagaraSetting& InData, class UNiagaraParameterCollectionInstance* InNPCEnvFog, class UNiagaraParameterCollectionInstance* InAllAreaFog, class UNiagaraParameterCollectionInstance* InHellSmoke)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyFogNiagaraParameterCollection");

	Params::NoceLevelFunctionLibrary_ApplyFogNiagaraParameterCollection Parms{};

	Parms.InData = std::move(InData);
	Parms.InNPCEnvFog = InNPCEnvFog;
	Parms.InAllAreaFog = InAllAreaFog;
	Parms.InHellSmoke = InHellSmoke;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyHellSmokeMPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceFogNiagaraSetting&    InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UMaterialParameterCollectionInstance*InMPC                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyHellSmokeMPC(const struct FNoceFogNiagaraSetting& InData, class UMaterialParameterCollectionInstance* InMPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyHellSmokeMPC");

	Params::NoceLevelFunctionLibrary_ApplyHellSmokeMPC Parms{};

	Parms.InData = std::move(InData);
	Parms.InMPC = InMPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpDarknessDataToMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     TargetComp                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDarknessSetting&      SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceDarknessSetting&      TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpDarknessDataToMaterial(class UObject* WorldContextObject, class UMaterialParameterCollection* TargetComp, const struct FNoceDarknessSetting& SourceData, const struct FNoceDarknessSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpDarknessDataToMaterial");

	Params::NoceLevelFunctionLibrary_ApplyLerpDarknessDataToMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpDirectionalLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDirectionalLightComponent*       TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceDirectionalLightSetting&SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceDirectionalLightSetting&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpDirectionalLightData(class UDirectionalLightComponent* TargetComp, const struct FNoceDirectionalLightSetting& SourceData, const struct FNoceDirectionalLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpDirectionalLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpDirectionalLightData Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpExpFogDataToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceExpFogSetting&        SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceExpFogSetting&        TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpExpFogDataToComponent(class UExponentialHeightFogComponent* TargetComp, const struct FNoceExpFogSetting& SourceData, const struct FNoceExpFogSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpExpFogDataToComponent");

	Params::NoceLevelFunctionLibrary_ApplyLerpExpFogDataToComponent Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                TargetNC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceLanternNiagaraSetting&SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceLanternNiagaraSetting&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpNiagaraData(class UNiagaraComponent* TargetNC, const struct FNoceLanternNiagaraSetting& SourceData, const struct FNoceLanternNiagaraSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpNiagaraData");

	Params::NoceLevelFunctionLibrary_ApplyLerpNiagaraData Parms{};

	Parms.TargetNC = TargetNC;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpPointLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPointLightComponent*             TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpPointLightData(class UPointLightComponent* TargetComp, const struct FNoceSpotLightSetting& SourceData, const struct FNoceSpotLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpPointLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpPointLightData Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpSkyAtmosphereLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyAtmosphereComponent*          TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSkyAtmosphereSetting& SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyAtmosphereSetting& TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpSkyAtmosphereLightData(class USkyAtmosphereComponent* TargetComp, const struct FNoceSkyAtmosphereSetting& SourceData, const struct FNoceSkyAtmosphereSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpSkyAtmosphereLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpSkyAtmosphereLightData Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpSkyDomeLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         TargetMI                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSkyDomeSetting&       SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyDomeSetting&       TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpSkyDomeLightData(class UMaterialInstanceDynamic* TargetMI, const struct FNoceSkyDomeSetting& SourceData, const struct FNoceSkyDomeSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpSkyDomeLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpSkyDomeLightData Parms{};

	Parms.TargetMI = TargetMI;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpSkyLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSkyLightSetting&      SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyLightSetting&      TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpSkyLightData(class USkyLightComponent* TargetComp, const struct FNoceSkyLightSetting& SourceData, const struct FNoceSkyLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpSkyLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpSkyLightData Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpSpotLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USpotLightComponent*              TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpSpotLightData(class USpotLightComponent* TargetComp, const struct FNoceSpotLightSetting& SourceData, const struct FNoceSpotLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpSpotLightData");

	Params::NoceLevelFunctionLibrary_ApplyLerpSpotLightData Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyLerpVolumetricFogDataToMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         TargetComp                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFogTown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyLerpVolumetricFogDataToMaterial(class UMaterialInstanceDynamic* TargetComp, const struct FNoceVolumetricFogSetting& SourceData, const struct FNoceVolumetricFogSetting& TargetData, float Alpha, bool IsFogTown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyLerpVolumetricFogDataToMaterial");

	Params::NoceLevelFunctionLibrary_ApplyLerpVolumetricFogDataToMaterial Parms{};

	Parms.TargetComp = TargetComp;
	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;
	Parms.IsFogTown = IsFogTown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceLanternNiagaraSetting&InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                TargetNC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyNiagaraData(const struct FNoceLanternNiagaraSetting& InData, class UNiagaraComponent* TargetNC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyNiagaraData");

	Params::NoceLevelFunctionLibrary_ApplyNiagaraData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetNC = TargetNC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyPointLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSpotLightSetting&     InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UPointLightComponent*             TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyPointLightData(const struct FNoceSpotLightSetting& InData, class UPointLightComponent* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyPointLightData");

	Params::NoceLevelFunctionLibrary_ApplyPointLightData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplySkyAtmosphereData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyAtmosphereSetting& InData                                                 (Parm, NativeAccessSpecifierPublic)
// class USkyAtmosphereComponent*          TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplySkyAtmosphereData(const struct FNoceSkyAtmosphereSetting& InData, class USkyAtmosphereComponent* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplySkyAtmosphereData");

	Params::NoceLevelFunctionLibrary_ApplySkyAtmosphereData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplySkyDomeData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyDomeSetting&       InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         TargetMI                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplySkyDomeData(const struct FNoceSkyDomeSetting& InData, class UMaterialInstanceDynamic* TargetMI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplySkyDomeData");

	Params::NoceLevelFunctionLibrary_ApplySkyDomeData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetMI = TargetMI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplySkyLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyLightSetting&      InData                                                 (Parm, NativeAccessSpecifierPublic)
// class USkyLightComponent*               TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceRecaptureSky                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplySkyLightData(const struct FNoceSkyLightSetting& InData, class USkyLightComponent* TargetComp, bool ForceRecaptureSky)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplySkyLightData");

	Params::NoceLevelFunctionLibrary_ApplySkyLightData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;
	Parms.ForceRecaptureSky = ForceRecaptureSky;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplySpotLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSpotLightSetting&     InData                                                 (Parm, NativeAccessSpecifierPublic)
// class USpotLightComponent*              TargetComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplySpotLightData(const struct FNoceSpotLightSetting& InData, class USpotLightComponent* TargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplySpotLightData");

	Params::NoceLevelFunctionLibrary_ApplySpotLightData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyVolumetricFogDataToMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceVolumetricFogSetting& InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         TargetComp                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFogTown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyVolumetricFogDataToMaterial(const struct FNoceVolumetricFogSetting& InData, class UMaterialInstanceDynamic* TargetComp, bool IsFogTown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyVolumetricFogDataToMaterial");

	Params::NoceLevelFunctionLibrary_ApplyVolumetricFogDataToMaterial Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetComp = TargetComp;
	Parms.IsFogTown = IsFogTown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyVolumetricFogDataToMPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     TargetMPC                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyVolumetricFogDataToMPC(class UObject* WorldContextObject, const struct FNoceVolumetricFogSetting& InData, class UMaterialParameterCollection* TargetMPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyVolumetricFogDataToMPC");

	Params::NoceLevelFunctionLibrary_ApplyVolumetricFogDataToMPC Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InData = std::move(InData);
	Parms.TargetMPC = TargetMPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.ApplyWindData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceWindSetting&          InData                                                 (Parm, NativeAccessSpecifierPublic)
// class UNeoWindComponent*                TargetWindComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ResetCurves                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceInstantSwitch                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLevelFunctionLibrary::ApplyWindData(const struct FNoceWindSetting& InData, class UNeoWindComponent* TargetWindComp, bool ResetCurves, bool ForceInstantSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "ApplyWindData");

	Params::NoceLevelFunctionLibrary_ApplyWindData Parms{};

	Parms.InData = std::move(InData);
	Parms.TargetWindComp = TargetWindComp;
	Parms.ResetCurves = ResetCurves;
	Parms.ForceInstantSwitch = ForceInstantSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLevelFunctionLibrary.CanSkipGimmick
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLevelFunctionLibrary::CanSkipGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "CanSkipGimmick");

	Params::NoceLevelFunctionLibrary_CanSkipGimmick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetCombatTestMapPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UNoceLevelFunctionLibrary::GetCombatTestMapPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetCombatTestMapPath");

	Params::NoceLevelFunctionLibrary_GetCombatTestMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetDarknessData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDarknessSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDarknessSetting UNoceLevelFunctionLibrary::GetDarknessData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetDarknessData");

	Params::NoceLevelFunctionLibrary_GetDarknessData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetDirLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDirectionalLightSetting     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDirectionalLightSetting UNoceLevelFunctionLibrary::GetDirLightData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetDirLightData");

	Params::NoceLevelFunctionLibrary_GetDirLightData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetDirLightDataFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDirectionalLightComponent*       InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDirectionalLightSetting     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDirectionalLightSetting UNoceLevelFunctionLibrary::GetDirLightDataFromComponent(class UDirectionalLightComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetDirLightDataFromComponent");

	Params::NoceLevelFunctionLibrary_GetDirLightDataFromComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetExpFogDataFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceExpFogSetting               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceExpFogSetting UNoceLevelFunctionLibrary::GetExpFogDataFromComponent(class UExponentialHeightFogComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetExpFogDataFromComponent");

	Params::NoceLevelFunctionLibrary_GetExpFogDataFromComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetFogNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceFogNiagaraSetting           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceFogNiagaraSetting UNoceLevelFunctionLibrary::GetFogNiagaraData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetFogNiagaraData");

	Params::NoceLevelFunctionLibrary_GetFogNiagaraData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetFogNiagaraDataFromNPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraParameterCollectionInstance*InNPCEnvFog                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*InAllAreaFog                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*InHellSmoke                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceFogNiagaraSetting           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceFogNiagaraSetting UNoceLevelFunctionLibrary::GetFogNiagaraDataFromNPC(class UNiagaraParameterCollectionInstance* InNPCEnvFog, class UNiagaraParameterCollectionInstance* InAllAreaFog, class UNiagaraParameterCollectionInstance* InHellSmoke)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetFogNiagaraDataFromNPC");

	Params::NoceLevelFunctionLibrary_GetFogNiagaraDataFromNPC Parms{};

	Parms.InNPCEnvFog = InNPCEnvFog;
	Parms.InAllAreaFog = InAllAreaFog;
	Parms.InHellSmoke = InHellSmoke;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetGameMapPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UNoceLevelFunctionLibrary::GetGameMapPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetGameMapPath");

	Params::NoceLevelFunctionLibrary_GetGameMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetHeightFogData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceExpFogSetting               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceExpFogSetting UNoceLevelFunctionLibrary::GetHeightFogData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetHeightFogData");

	Params::NoceLevelFunctionLibrary_GetHeightFogData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetLanternNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLanternNiagaraSetting       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLanternNiagaraSetting UNoceLevelFunctionLibrary::GetLanternNiagaraData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetLanternNiagaraData");

	Params::NoceLevelFunctionLibrary_GetLanternNiagaraData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetLumenTranlucencyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLumenTranslucencySetting    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLumenTranslucencySetting UNoceLevelFunctionLibrary::GetLumenTranlucencyData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetLumenTranlucencyData");

	Params::NoceLevelFunctionLibrary_GetLumenTranlucencyData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetNiagaraPCInstance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InNPCPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraParameterCollectionInstance*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraParameterCollectionInstance* UNoceLevelFunctionLibrary::GetNiagaraPCInstance(class UObject* WorldContextObject, const struct FSoftObjectPath& InNPCPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetNiagaraPCInstance");

	Params::NoceLevelFunctionLibrary_GetNiagaraPCInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InNPCPath = std::move(InNPCPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetNiagaraSettingFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                InNC                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLanternNiagaraSetting       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLanternNiagaraSetting UNoceLevelFunctionLibrary::GetNiagaraSettingFromComponent(class UNiagaraComponent* InNC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetNiagaraSettingFromComponent");

	Params::NoceLevelFunctionLibrary_GetNiagaraSettingFromComponent Parms{};

	Parms.InNC = InNC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSkyAtmosphereData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyAtmosphereSetting        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyAtmosphereSetting UNoceLevelFunctionLibrary::GetSkyAtmosphereData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSkyAtmosphereData");

	Params::NoceLevelFunctionLibrary_GetSkyAtmosphereData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSkyAtmosphereDataFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyAtmosphereComponent*          InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyAtmosphereSetting        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyAtmosphereSetting UNoceLevelFunctionLibrary::GetSkyAtmosphereDataFromComponent(class USkyAtmosphereComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSkyAtmosphereDataFromComponent");

	Params::NoceLevelFunctionLibrary_GetSkyAtmosphereDataFromComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSkyDomeData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyDomeSetting              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyDomeSetting UNoceLevelFunctionLibrary::GetSkyDomeData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSkyDomeData");

	Params::NoceLevelFunctionLibrary_GetSkyDomeData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSkyLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyLightSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyLightSetting UNoceLevelFunctionLibrary::GetSkyLightData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSkyLightData");

	Params::NoceLevelFunctionLibrary_GetSkyLightData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSkyLightDataFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyLightSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyLightSetting UNoceLevelFunctionLibrary::GetSkyLightDataFromComponent(class USkyLightComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSkyLightDataFromComponent");

	Params::NoceLevelFunctionLibrary_GetSkyLightDataFromComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSpotLightDataFromComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USpotLightComponent*              InComp                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSpotLightSetting            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSpotLightSetting UNoceLevelFunctionLibrary::GetSpotLightDataFromComponent(class USpotLightComponent* InComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSpotLightDataFromComponent");

	Params::NoceLevelFunctionLibrary_GetSpotLightDataFromComponent Parms{};

	Parms.InComp = InComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSSFSData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSSFSSetting                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSSFSSetting UNoceLevelFunctionLibrary::GetSSFSData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSSFSData");

	Params::NoceLevelFunctionLibrary_GetSSFSData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetSweetLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSpotLightSetting            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSpotLightSetting UNoceLevelFunctionLibrary::GetSweetLightData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetSweetLightData");

	Params::NoceLevelFunctionLibrary_GetSweetLightData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetTitleMapPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UNoceLevelFunctionLibrary::GetTitleMapPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetTitleMapPath");

	Params::NoceLevelFunctionLibrary_GetTitleMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetVolumetricFogData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceVolumetricFogSetting        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceVolumetricFogSetting UNoceLevelFunctionLibrary::GetVolumetricFogData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetVolumetricFogData");

	Params::NoceLevelFunctionLibrary_GetVolumetricFogData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.GetWindData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceWindSetting                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceWindSetting UNoceLevelFunctionLibrary::GetWindData(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "GetWindData");

	Params::NoceLevelFunctionLibrary_GetWindData Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.IsTargetLocationStreamingComplete
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class FName>&                InTargetGrids                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLevelFunctionLibrary::IsTargetLocationStreamingComplete(const class AActor* InActor, const TSet<class FName>& InTargetGrids, const struct FVector& InLocation, const struct FRotator& InRotation, float InRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "IsTargetLocationStreamingComplete");

	Params::NoceLevelFunctionLibrary_IsTargetLocationStreamingComplete Parms{};

	Parms.InActor = InActor;
	Parms.InTargetGrids = std::move(InTargetGrids);
	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpDarknessData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceDarknessSetting&      SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceDarknessSetting&      TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDarknessSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDarknessSetting UNoceLevelFunctionLibrary::LerpDarknessData(const struct FNoceDarknessSetting& SourceData, const struct FNoceDarknessSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpDarknessData");

	Params::NoceLevelFunctionLibrary_LerpDarknessData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpDirectionalLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceDirectionalLightSetting&SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceDirectionalLightSetting&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDirectionalLightSetting     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDirectionalLightSetting UNoceLevelFunctionLibrary::LerpDirectionalLightData(const struct FNoceDirectionalLightSetting& SourceData, const struct FNoceDirectionalLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpDirectionalLightData");

	Params::NoceLevelFunctionLibrary_LerpDirectionalLightData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpExpFogData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceExpFogSetting&        SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceExpFogSetting&        TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceExpFogSetting               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceExpFogSetting UNoceLevelFunctionLibrary::LerpExpFogData(const struct FNoceExpFogSetting& SourceData, const struct FNoceExpFogSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpExpFogData");

	Params::NoceLevelFunctionLibrary_LerpExpFogData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpFogNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceFogNiagaraSetting&    SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceFogNiagaraSetting&    TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceFogNiagaraSetting           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceFogNiagaraSetting UNoceLevelFunctionLibrary::LerpFogNiagaraData(const struct FNoceFogNiagaraSetting& SourceData, const struct FNoceFogNiagaraSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpFogNiagaraData");

	Params::NoceLevelFunctionLibrary_LerpFogNiagaraData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpNiagaraData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceLanternNiagaraSetting&SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceLanternNiagaraSetting&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLanternNiagaraSetting       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLanternNiagaraSetting UNoceLevelFunctionLibrary::LerpNiagaraData(const struct FNoceLanternNiagaraSetting& SourceData, const struct FNoceLanternNiagaraSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpNiagaraData");

	Params::NoceLevelFunctionLibrary_LerpNiagaraData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpSkyAtmosphereData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyAtmosphereSetting& SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyAtmosphereSetting& TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyAtmosphereSetting        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyAtmosphereSetting UNoceLevelFunctionLibrary::LerpSkyAtmosphereData(const struct FNoceSkyAtmosphereSetting& SourceData, const struct FNoceSkyAtmosphereSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpSkyAtmosphereData");

	Params::NoceLevelFunctionLibrary_LerpSkyAtmosphereData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpSkyDomeData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyDomeSetting&       SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyDomeSetting&       TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyDomeSetting              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyDomeSetting UNoceLevelFunctionLibrary::LerpSkyDomeData(const struct FNoceSkyDomeSetting& SourceData, const struct FNoceSkyDomeSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpSkyDomeData");

	Params::NoceLevelFunctionLibrary_LerpSkyDomeData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpSkyLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSkyLightSetting&      SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSkyLightSetting&      TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSkyLightSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSkyLightSetting UNoceLevelFunctionLibrary::LerpSkyLightData(const struct FNoceSkyLightSetting& SourceData, const struct FNoceSkyLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpSkyLightData");

	Params::NoceLevelFunctionLibrary_LerpSkyLightData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpSpotLightData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceSpotLightSetting&     SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceSpotLightSetting&     TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceSpotLightSetting            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceSpotLightSetting UNoceLevelFunctionLibrary::LerpSpotLightData(const struct FNoceSpotLightSetting& SourceData, const struct FNoceSpotLightSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpSpotLightData");

	Params::NoceLevelFunctionLibrary_LerpSpotLightData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelFunctionLibrary.LerpVolumetricFogData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FNoceVolumetricFogSetting& SourceData                                             (Parm, NativeAccessSpecifierPublic)
// const struct FNoceVolumetricFogSetting& TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceVolumetricFogSetting        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceVolumetricFogSetting UNoceLevelFunctionLibrary::LerpVolumetricFogData(const struct FNoceVolumetricFogSetting& SourceData, const struct FNoceVolumetricFogSetting& TargetData, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceLevelFunctionLibrary", "LerpVolumetricFogData");

	Params::NoceLevelFunctionLibrary_LerpVolumetricFogData Parms{};

	Parms.SourceData = std::move(SourceData);
	Parms.TargetData = std::move(TargetData);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLevelSequenceActor.Play
// (Final, Native, Public, BlueprintCallable)

void ANoceLevelSequenceActor::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLevelSequenceActor", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceQuestWidget.ShowQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      Text                                                   (Parm, NativeAccessSpecifierPublic)

void UNoceQuestWidget::ShowQuest(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceQuestWidget", "ShowQuest");

	Params::NoceQuestWidget_ShowQuest Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightFadeComponent.FixLightFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFixed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLightFadeComponent::FixLightFadeDistance(bool IsFixed, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightFadeComponent", "FixLightFadeDistance");

	Params::NoceLightFadeComponent_FixLightFadeDistance Parms{};

	Parms.IsFixed = IsFixed;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightFadeInterface.GetAttenuationRadius
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float INoceLightFadeInterface::GetAttenuationRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceLightFadeInterface", "GetAttenuationRadius");

	Params::NoceLightFadeInterface_GetAttenuationRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightFadeInterface.GetEmissiveIntensity
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float INoceLightFadeInterface::GetEmissiveIntensity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceLightFadeInterface", "GetEmissiveIntensity");

	Params::NoceLightFadeInterface_GetEmissiveIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightFadeInterface.GetIntensity
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float INoceLightFadeInterface::GetIntensity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceLightFadeInterface", "GetIntensity");

	Params::NoceLightFadeInterface_GetIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightFadeInterface.GetMaterialInstance
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* INoceLightFadeInterface::GetMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceLightFadeInterface", "GetMaterialInstance");

	Params::NoceLightFadeInterface_GetMaterialInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightFadeInterface.NeedManualInitialize
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceLightFadeInterface::NeedManualInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceLightFadeInterface", "NeedManualInitialize");

	Params::NoceLightFadeInterface_NeedManualInitialize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightProps.InitRigidBodyWire
// (Final, Native, Protected, BlueprintCallable)

void ANoceLightProps::InitRigidBodyWire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "InitRigidBodyWire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightProps.SetLightMaxDistanceFadeRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceLightProps::SetLightMaxDistanceFadeRange(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "SetLightMaxDistanceFadeRange");

	Params::NoceLightProps_SetLightMaxDistanceFadeRange Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightProps.SetLightMaxDrawDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceLightProps::SetLightMaxDrawDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "SetLightMaxDrawDistance");

	Params::NoceLightProps_SetLightMaxDrawDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightProps.SetReplaceLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InValue                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceLightProps::SetReplaceLightFunctionMaterial(class UMaterialInterface* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "SetReplaceLightFunctionMaterial");

	Params::NoceLightProps_SetReplaceLightFunctionMaterial Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLightProps.UpdateSavablePropertiesBPWhenCreateRecord
// (Event, Protected, BlueprintEvent)

void ANoceLightProps::UpdateSavablePropertiesBPWhenCreateRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "UpdateSavablePropertiesBPWhenCreateRecord");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceLightProps.GetLightComp
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightComponent* ANoceLightProps::GetLightComp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "GetLightComp");

	Params::NoceLightProps_GetLightComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightProps.GetLightMaxDistanceFadeRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceLightProps::GetLightMaxDistanceFadeRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "GetLightMaxDistanceFadeRange");

	Params::NoceLightProps_GetLightMaxDistanceFadeRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightProps.GetLightMaxDrawDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANoceLightProps::GetLightMaxDrawDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "GetLightMaxDrawDistance");

	Params::NoceLightProps_GetLightMaxDrawDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightProps.GetReplaceLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ANoceLightProps::GetReplaceLightFunctionMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "GetReplaceLightFunctionMaterial");

	Params::NoceLightProps_GetReplaceLightFunctionMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLightProps.IsLoadLoadRecordData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceLightProps::IsLoadLoadRecordData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLightProps", "IsLoadLoadRecordData");

	Params::NoceLightProps_IsLoadLoadRecordData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.CanRegisterSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupsPoint::CanRegisterSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "CanRegisterSaveData");

	Params::NocePickupsPoint_CanRegisterSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.CheckIfDeployedDataFit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupsPoint::CheckIfDeployedDataFit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "CheckIfDeployedDataFit");

	Params::NocePickupsPoint_CheckIfDeployedDataFit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.DoSetTriggerBox
// (Native, Public, BlueprintCallable)

void ANocePickupsPoint::DoSetTriggerBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "DoSetTriggerBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.GenerateDynamicPickups
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ANoceInteractableBase>InInteractable                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsForceGenerate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceInteractableBase*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceInteractableBase* ANocePickupsPoint::GenerateDynamicPickups(TSubclassOf<class ANoceInteractableBase> InInteractable, bool InIsForceGenerate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "GenerateDynamicPickups");

	Params::NocePickupsPoint_GenerateDynamicPickups Parms{};

	Parms.InInteractable = InInteractable;
	Parms.InIsForceGenerate = InIsForceGenerate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.GeneratePickupsByCurrentState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceInteractableBase* ANocePickupsPoint::GeneratePickupsByCurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "GeneratePickupsByCurrentState");

	Params::NocePickupsPoint_GeneratePickupsByCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.OnActorModified_BP
// (Event, Public, BlueprintEvent)

void ANocePickupsPoint::OnActorModified_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "OnActorModified_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePickupsPoint.OnPickupsGenerateDynamically_BP
// (Event, Public, BlueprintEvent)

void ANocePickupsPoint::OnPickupsGenerateDynamically_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "OnPickupsGenerateDynamically_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePickupsPoint.OnSetupPickups_BP
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANocePickupsPoint::OnSetupPickups_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "OnSetupPickups_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePickupsPoint.RemovePickups
// (Final, Native, Public, BlueprintCallable)

void ANocePickupsPoint::RemovePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "RemovePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.SetupEvntPickups_BP
// (Event, Public, BlueprintEvent)

void ANocePickupsPoint::SetupEvntPickups_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "SetupEvntPickups_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NocePickupsPoint.SetupSpawnedPickups
// (Final, Native, Public, BlueprintCallable)

void ANocePickupsPoint::SetupSpawnedPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "SetupSpawnedPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.ShowDebugSelection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePickupsPoint::ShowDebugSelection(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "ShowDebugSelection");

	Params::NocePickupsPoint_ShowDebugSelection Parms{};

	Parms.IsShow = IsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.ShowDynamicPickupsDebugInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ANocePickupsPoint::ShowDynamicPickupsDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "ShowDynamicPickupsDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.UpdateSpawnedPickups
// (Final, Native, Public, BlueprintCallable)

void ANocePickupsPoint::UpdateSpawnedPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "UpdateSpawnedPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsPoint.CanBeDynamicCandidate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InGroupTypeBitmask                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupsPoint::CanBeDynamicCandidate(int32 InGroupTypeBitmask) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "CanBeDynamicCandidate");

	Params::NocePickupsPoint_CanBeDynamicCandidate Parms{};

	Parms.InGroupTypeBitmask = InGroupTypeBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsPoint.IsCurrentDynamicProgressTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANocePickupsPoint::IsCurrentDynamicProgressTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsPoint", "IsCurrentDynamicProgressTag");

	Params::NocePickupsPoint_IsCurrentDynamicProgressTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerSubsystem.RegisterPlayerTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerTriggerSubsystem::RegisterPlayerTrigger(class UObject* InTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerSubsystem", "RegisterPlayerTrigger");

	Params::NocePlayerTriggerSubsystem_RegisterPlayerTrigger Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerSubsystem.UnregisterPlayerTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerTriggerSubsystem::UnregisterPlayerTrigger(class UObject* InTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerTriggerSubsystem", "UnregisterPlayerTrigger");

	Params::NocePlayerTriggerSubsystem_UnregisterPlayerTrigger Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.LinkRequest.SetLinkRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinkPriority                           InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InExecutionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InBankID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMotionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkRequest::SetLinkRequest(class AActor* InOwner, class AActor* InTarget, ELinkPriority InPriority, bool InExecutionType, int32 InBankID, int32 InMotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkRequest", "SetLinkRequest");

	Params::LinkRequest_SetLinkRequest Parms{};

	Parms.InOwner = InOwner;
	Parms.InTarget = InTarget;
	Parms.InPriority = InPriority;
	Parms.InExecutionType = InExecutionType;
	Parms.InBankID = InBankID;
	Parms.InMotionID = InMotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.BP_GetEntryWidgetFromItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceListView::BP_GetEntryWidgetFromItem(const class UObject* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "BP_GetEntryWidgetFromItem");

	Params::NoceListView_BP_GetEntryWidgetFromItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceListView.BP_ItemFromEntryWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UNoceListView::BP_ItemFromEntryWidget(class UUserWidget* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "BP_ItemFromEntryWidget");

	Params::NoceListView_BP_ItemFromEntryWidget Parms{};

	Parms.EntryWidget = EntryWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceListView.BP_UpdateScrollbarVisibility
// (Final, Native, Public, BlueprintCallable)

void UNoceListView::BP_UpdateScrollbarVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "BP_UpdateScrollbarVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.DisableInputs
// (Final, Native, Public, BlueprintCallable)

void UNoceListView::DisableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "DisableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.EnableInputs
// (Final, Native, Public, BlueprintCallable)

void UNoceListView::EnableInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "EnableInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.GetSelectingIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceListView::GetSelectingIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "GetSelectingIndex");

	Params::NoceListView_GetSelectingIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceListView.IsUserScrolling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceListView::IsUserScrolling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "IsUserScrolling");

	Params::NoceListView_IsUserScrolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceListView.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  TriggerId                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceListView::PlaySound(const struct FNeoAudioTriggerIdHandle& TriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "PlaySound");

	Params::NoceListView_PlaySound Parms{};

	Parms.TriggerId = std::move(TriggerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.ScrollToTopWithoutAnimation
// (Final, Native, Public, BlueprintCallable)

void UNoceListView::ScrollToTopWithoutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "ScrollToTopWithoutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.SetSelectedIndexWithoutAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceListView::SetSelectedIndexWithoutAnimation(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "SetSelectedIndexWithoutAnimation");

	Params::NoceListView_SetSelectedIndexWithoutAnimation Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  InSelectSound                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FNeoAudioTriggerIdHandle&  InMouseHoverSound                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceListView::SetSound(const struct FNeoAudioTriggerIdHandle& InSelectSound, const struct FNeoAudioTriggerIdHandle& InMouseHoverSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "SetSound");

	Params::NoceListView_SetSound Parms{};

	Parms.InSelectSound = std::move(InSelectSound);
	Parms.InMouseHoverSound = std::move(InMouseHoverSound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceListView.UpdateInput
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInputEvent&               InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceListView::UpdateInput(const struct FInputEvent& InputEvent, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceListView", "UpdateInput");

	Params::NoceListView_UpdateInput Parms{};

	Parms.InputEvent = std::move(InputEvent);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.CheckAllSettingValid
// (Final, Native, Public, BlueprintCallable)

void UNoceLocalGameUserSettings::CheckAllSettingValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "CheckAllSettingValid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.GetAASuperSamplingWithCheck
// (Final, Native, Public)
// Parameters:
// bool                                    UseViewport                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceGraphicAASuperSamplingMode         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGraphicAASuperSamplingMode UNoceLocalGameUserSettings::GetAASuperSamplingWithCheck(bool UseViewport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetAASuperSamplingWithCheck");

	Params::NoceLocalGameUserSettings_GetAASuperSamplingWithCheck Parms{};

	Parms.UseViewport = UseViewport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetAvailableAASuperSamplingModes
// (Final, Native, Public)
// Parameters:
// bool                                    UseViewport                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ENoceGraphicAASuperSamplingMode> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ENoceGraphicAASuperSamplingMode> UNoceLocalGameUserSettings::GetAvailableAASuperSamplingModes(bool UseViewport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetAvailableAASuperSamplingModes");

	Params::NoceLocalGameUserSettings_GetAvailableAASuperSamplingModes Parms{};

	Parms.UseViewport = UseViewport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetGamepadIconDeviceType
// (Final, Native, Public)
// Parameters:
// ENoceInputDeviceType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputDeviceType UNoceLocalGameUserSettings::GetGamepadIconDeviceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetGamepadIconDeviceType");

	Params::NoceLocalGameUserSettings_GetGamepadIconDeviceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetIsInitialized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::GetIsInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetIsInitialized");

	Params::NoceLocalGameUserSettings_GetIsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetLastBenchmark
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float*                                  CPU                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  GPU                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::GetLastBenchmark(float* CPU, float* GPU)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetLastBenchmark");

	Params::NoceLocalGameUserSettings_GetLastBenchmark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CPU != nullptr)
		*CPU = Parms.CPU;

	if (GPU != nullptr)
		*GPU = Parms.GPU;
}


// Function GameNoce.NoceLocalGameUserSettings.GetLastPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceGameSettingPreset                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingPreset UNoceLocalGameUserSettings::GetLastPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetLastPreset");

	Params::NoceLocalGameUserSettings_GetLastPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetLastPreset2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceGameSettingPreset                  CurrentPreset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceGameSettingPreset                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingPreset UNoceLocalGameUserSettings::GetLastPreset2(ENoceGameSettingPreset CurrentPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetLastPreset2");

	Params::NoceLocalGameUserSettings_GetLastPreset2 Parms{};

	Parms.CurrentPreset = CurrentPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.IsHDRValidEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::IsHDRValidEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "IsHDRValidEnabled");

	Params::NoceLocalGameUserSettings_IsHDRValidEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.LoadAudioOutputDeviceId
// (Final, Native, Public, BlueprintCallable)

void UNoceLocalGameUserSettings::LoadAudioOutputDeviceId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "LoadAudioOutputDeviceId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.RunNoceBenchmark
// (Final, Native, Public, BlueprintCallable)

void UNoceLocalGameUserSettings::RunNoceBenchmark()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "RunNoceBenchmark");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetAASuperSampling
// (Final, Native, Public)
// Parameters:
// ENoceGraphicAASuperSamplingMode         InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetAASuperSampling(ENoceGraphicAASuperSamplingMode InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetAASuperSampling");

	Params::NoceLocalGameUserSettings_SetAASuperSampling Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetAASuperSamplingQuality
// (Final, Native, Public)
// Parameters:
// uint32                                  InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetAASuperSamplingQuality(uint32 InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetAASuperSamplingQuality");

	Params::NoceLocalGameUserSettings_SetAASuperSamplingQuality Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetAudioOutputDeviceId
// (Final, Native, Public)
// Parameters:
// const class FString&                    InAudioOutputDeviceId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetAudioOutputDeviceId");

	Params::NoceLocalGameUserSettings_SetAudioOutputDeviceId Parms{};

	Parms.InAudioOutputDeviceId = std::move(InAudioOutputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetEnableHDR
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetEnableHDR(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetEnableHDR");

	Params::NoceLocalGameUserSettings_SetEnableHDR Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetFullscreenModeAndApply
// (Final, Native, Public)
// Parameters:
// EWindowMode                             InFullscreenMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetFullscreenModeAndApply(EWindowMode InFullscreenMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetFullscreenModeAndApply");

	Params::NoceLocalGameUserSettings_SetFullscreenModeAndApply Parms{};

	Parms.InFullscreenMode = InFullscreenMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetGamepadIconType
// (Final, Native, Public)
// Parameters:
// ENoceInputGamepadType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetGamepadIconType(ENoceInputGamepadType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetGamepadIconType");

	Params::NoceLocalGameUserSettings_SetGamepadIconType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetMotionBlur
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetMotionBlur(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetMotionBlur");

	Params::NoceLocalGameUserSettings_SetMotionBlur Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetPaniniProjectionEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetPaniniProjectionEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetPaniniProjectionEnabled");

	Params::NoceLocalGameUserSettings_SetPaniniProjectionEnabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceGameSettingPreset                  InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetPreset(ENoceGameSettingPreset InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetPreset");

	Params::NoceLocalGameUserSettings_SetPreset Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetScreenPercentage
// (Final, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLocalGameUserSettings::SetScreenPercentage(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetScreenPercentage");

	Params::NoceLocalGameUserSettings_SetScreenPercentage Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SetToDefaultIfNotInitialized
// (Final, Native, Public, BlueprintCallable)

void UNoceLocalGameUserSettings::SetToDefaultIfNotInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SetToDefaultIfNotInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLocalGameUserSettings.SupportAASuperSamplingQuality
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::SupportAASuperSamplingQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "SupportAASuperSamplingQuality");

	Params::NoceLocalGameUserSettings_SupportAASuperSamplingQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.CanPaniniProjectionEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::CanPaniniProjectionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "CanPaniniProjectionEnabled");

	Params::NoceLocalGameUserSettings_CanPaniniProjectionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetAASuperSampling
// (Final, Native, Public, Const)
// Parameters:
// ENoceGraphicAASuperSamplingMode         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGraphicAASuperSamplingMode UNoceLocalGameUserSettings::GetAASuperSampling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetAASuperSampling");

	Params::NoceLocalGameUserSettings_GetAASuperSampling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetAASuperSamplingQuality
// (Final, Native, Public, Const)
// Parameters:
// uint32                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint32 UNoceLocalGameUserSettings::GetAASuperSamplingQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetAASuperSamplingQuality");

	Params::NoceLocalGameUserSettings_GetAASuperSamplingQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetAudioOutputDeviceId
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNoceLocalGameUserSettings::GetAudioOutputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetAudioOutputDeviceId");

	Params::NoceLocalGameUserSettings_GetAudioOutputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetFullscreenModeInt
// (Final, Native, Public, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UNoceLocalGameUserSettings::GetFullscreenModeInt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetFullscreenModeInt");

	Params::NoceLocalGameUserSettings_GetFullscreenModeInt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetGamepadIconType
// (Final, Native, Public, Const)
// Parameters:
// ENoceInputGamepadType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputGamepadType UNoceLocalGameUserSettings::GetGamepadIconType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetGamepadIconType");

	Params::NoceLocalGameUserSettings_GetGamepadIconType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetMotionBlur
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::GetMotionBlur() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetMotionBlur");

	Params::NoceLocalGameUserSettings_GetMotionBlur Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetPaniniProjectionEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::GetPaniniProjectionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetPaniniProjectionEnabled");

	Params::NoceLocalGameUserSettings_GetPaniniProjectionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetResolutionSizeX
// (Final, Native, Public, Const)
// Parameters:
// const uint32                            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const uint32 UNoceLocalGameUserSettings::GetResolutionSizeX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetResolutionSizeX");

	Params::NoceLocalGameUserSettings_GetResolutionSizeX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetResolutionSizeY
// (Final, Native, Public, Const)
// Parameters:
// const uint32                            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const uint32 UNoceLocalGameUserSettings::GetResolutionSizeY() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetResolutionSizeY");

	Params::NoceLocalGameUserSettings_GetResolutionSizeY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetScreenPercentage
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceLocalGameUserSettings::GetScreenPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetScreenPercentage");

	Params::NoceLocalGameUserSettings_GetScreenPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLocalGameUserSettings.GetVSyncEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLocalGameUserSettings::GetVSyncEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLocalGameUserSettings", "GetVSyncEnabled");

	Params::NoceLocalGameUserSettings_GetVSyncEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockLocationComponent.GetCanBeLockedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceLockLocationComponent::GetCanBeLockedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "GetCanBeLockedOn");

	Params::NoceLockLocationComponent_GetCanBeLockedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceLockLocationComponent.OnAIControllerThinkEnableChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockLocationComponent::OnAIControllerThinkEnableChanged(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "OnAIControllerThinkEnableChanged");

	Params::NoceLockLocationComponent_OnAIControllerThinkEnableChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockLocationComponent.OnEnemyDie
// (Final, Native, Protected)

void UNoceLockLocationComponent::OnEnemyDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "OnEnemyDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockLocationComponent.OnEnemyFakeDead
// (Final, Native, Protected)

void UNoceLockLocationComponent::OnEnemyFakeDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "OnEnemyFakeDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockLocationComponent.OnEnemyResurrect
// (Final, Native, Protected)

void UNoceLockLocationComponent::OnEnemyResurrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "OnEnemyResurrect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockLocationComponent.OnPossessedPawnChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            InOldPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            InNewPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockLocationComponent::OnPossessedPawnChanged(class APawn* InOldPawn, class APawn* InNewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "OnPossessedPawnChanged");

	Params::NoceLockLocationComponent_OnPossessedPawnChanged Parms{};

	Parms.InOldPawn = InOldPawn;
	Parms.InNewPawn = InNewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceLockLocationComponent.SetCanBeLockedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceLockLocationComponent::SetCanBeLockedOn(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceLockLocationComponent", "SetCanBeLockedOn");

	Params::NoceLockLocationComponent_SetCanBeLockedOn Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapAreaWidget.GetAllMapBackgroundWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UNoceMapBackgroundWidget*> ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UNoceMapBackgroundWidget*> UNoceMapAreaWidget::GetAllMapBackgroundWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapAreaWidget", "GetAllMapBackgroundWidgets");

	Params::NoceMapAreaWidget_GetAllMapBackgroundWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapAreaWidget.GetAllMapDynamicMapIconWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UNoceDynamicMapIconWidget*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UNoceDynamicMapIconWidget*> UNoceMapAreaWidget::GetAllMapDynamicMapIconWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapAreaWidget", "GetAllMapDynamicMapIconWidgets");

	Params::NoceMapAreaWidget_GetAllMapDynamicMapIconWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapAreaWidget.GetAllMapLocationWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UNoceMapLocationWidget*>   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UNoceMapLocationWidget*> UNoceMapAreaWidget::GetAllMapLocationWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapAreaWidget", "GetAllMapLocationWidgets");

	Params::NoceMapAreaWidget_GetAllMapLocationWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapAreaWidget.GetVisibleLocationGroups
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<ENoceMapLocationGroup>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ENoceMapLocationGroup> UNoceMapAreaWidget::GetVisibleLocationGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapAreaWidget", "GetVisibleLocationGroups");

	Params::NoceMapAreaWidget_GetVisibleLocationGroups Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapCapture.GenerateSnapshot
// (Final, Native, Public)

void ANoceMapCapture::GenerateSnapshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapCapture", "GenerateSnapshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapCapture.GetAreaBounds
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* ANoceMapCapture::GetAreaBounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapCapture", "GetAreaBounds");

	Params::NoceMapCapture_GetAreaBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconComponent.GetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNoceMapGeneralIconData          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNoceMapGeneralIconData UNoceMapIconComponent::GetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "GetData");

	Params::NoceMapIconComponent_GetData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconComponent.OnCheckConditionMatch
// (Final, Native, Protected)

void UNoceMapIconComponent::OnCheckConditionMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "OnCheckConditionMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconComponent::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "OnGameProgressChanged");

	Params::NoceMapIconComponent_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.OnInteract
// (Final, Native, Protected)

void UNoceMapIconComponent::OnInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "OnInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.OnInteractOverlapHint
// (Final, Native, Protected)

void UNoceMapIconComponent::OnInteractOverlapHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "OnInteractOverlapHint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.SetIconSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             NewIconSize                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconComponent::SetIconSize(const float NewIconSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "SetIconSize");

	Params::NoceMapIconComponent_SetIconSize Parms{};

	Parms.NewIconSize = NewIconSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.SetIconVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewVisible                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMapIconComponent::SetIconVisible(const bool bNewVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "SetIconVisible");

	Params::NoceMapIconComponent_SetIconVisible Parms{};

	Parms.bNewVisible = bNewVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMapIconComponent.DoesIconRotate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMapIconComponent::DoesIconRotate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "DoesIconRotate");

	Params::NoceMapIconComponent_DoesIconRotate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconComponent.GetIconSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MapSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceMapIconComponent::GetIconSize(float MapSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "GetIconSize");

	Params::NoceMapIconComponent_GetIconSize Parms{};

	Parms.MapSize = MapSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapIconComponent.IsIconVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceMapIconComponent::IsIconVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapIconComponent", "IsIconVisible");

	Params::NoceMapIconComponent_IsIconVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMapTrackerComponent.GetMapIcons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UNoceMapIconComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UNoceMapIconComponent*> UNoceMapTrackerComponent::GetMapIcons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMapTrackerComponent", "GetMapIcons");

	Params::NoceMapTrackerComponent_GetMapIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMaterialSanityFlowerWidget.GetMaterial
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UNoceMaterialSanityFlowerWidget::GetMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMaterialSanityFlowerWidget", "GetMaterial");

	Params::NoceMaterialSanityFlowerWidget_GetMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceMaterialSanityFlowerWidget.InitializeDynamicMaterial
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMaterialSanityFlowerWidget::InitializeDynamicMaterial(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMaterialSanityFlowerWidget", "InitializeDynamicMaterial");

	Params::NoceMaterialSanityFlowerWidget_InitializeDynamicMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceMaterialSanityFlowerWidget.UpdatePercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMaterialSanityFlowerWidget::UpdatePercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMaterialSanityFlowerWidget", "UpdatePercent");

	Params::NoceMaterialSanityFlowerWidget_UpdatePercent Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceMinimapWidget.Refresh
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceMinimapWidget::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMinimapWidget", "Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceMinimapWidget.Zoom
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ZoomIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceMinimapWidget::Zoom(bool ZoomIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceMinimapWidget", "Zoom");

	Params::NoceMinimapWidget_Zoom Parms{};

	Parms.ZoomIn = ZoomIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceNavLinkProxy.GetEndPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceNavLinkProxy::GetEndPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNavLinkProxy", "GetEndPoint");

	Params::NoceNavLinkProxy_GetEndPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNavLinkProxy.GetStartPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANoceNavLinkProxy::GetStartPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNavLinkProxy", "GetStartPoint");

	Params::NoceNavLinkProxy_GetStartPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNewIconWidget.GetIsNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceNewIconWidget::GetIsNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewIconWidget", "GetIsNew");

	Params::NoceNewIconWidget_GetIsNew Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNewIconWidget.OnFocusCompleted
// (Final, Native, Protected)

void UNoceNewIconWidget::OnFocusCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewIconWidget", "OnFocusCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNewIconWidget.OnUnfocusCompleted
// (Final, Native, Protected)

void UNoceNewIconWidget::OnUnfocusCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewIconWidget", "OnUnfocusCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNewIconWidget.SetIsNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsNew                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNewIconWidget::SetIsNew(bool InIsNew, bool NeedAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNewIconWidget", "SetIsNew");

	Params::NoceNewIconWidget_SetIsNew Parms{};

	Parms.InIsNew = InIsNew;
	Parms.NeedAnimation = NeedAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookPage.GetContents
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UNoceNotebookContent*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UNoceNotebookContent*> UNoceNotebookPage::GetContents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPage", "GetContents");

	Params::NoceNotebookPage_GetContents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookPage.IsPlayingUIAnimations
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceNotebookPage::IsPlayingUIAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPage", "IsPlayingUIAnimations");

	Params::NoceNotebookPage_IsPlayingUIAnimations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceNotebookPage.OnFadeIn
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookPage::OnFadeIn(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPage", "OnFadeIn");

	Params::NoceNotebookPage_OnFadeIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookPage.SetData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class FText>&              Texts                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FSoftObjectPath>&   Images                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsVisibles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews2                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookPage::SetData(const TArray<class FText>& Texts, const TArray<struct FSoftObjectPath>& Images, const TArray<bool>& IsVisibles, const TArray<bool>& IsNews, const TArray<bool>& IsNews2, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPage", "SetData");

	Params::NoceNotebookPage_SetData Parms{};

	Parms.Texts = std::move(Texts);
	Parms.Images = std::move(Images);
	Parms.IsVisibles = std::move(IsVisibles);
	Parms.IsNews = std::move(IsNews);
	Parms.IsNews2 = std::move(IsNews2);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceNotebookPageTabWidget.ClearNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookPageTabWidget::ClearNew(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPageTabWidget", "ClearNew");

	Params::NoceNotebookPageTabWidget_ClearNew Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookPageTabWidget.Init
// (Final, Native, Public, BlueprintCallable)

void UNoceNotebookPageTabWidget::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPageTabWidget", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceNotebookPageTabWidget.SetData
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FNoceUINotebookCategoryData>&InData                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InDefaultColor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InSelectColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InDefaultIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseMoreTabs                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceNotebookPageTabWidget::SetData(const TArray<struct FNoceUINotebookCategoryData>& InData, const struct FLinearColor& InDefaultColor, const struct FLinearColor& InSelectColor, int32 InDefaultIndex, bool UseMoreTabs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceNotebookPageTabWidget", "SetData");

	Params::NoceNotebookPageTabWidget_SetData Parms{};

	Parms.InData = std::move(InData);
	Parms.InDefaultColor = std::move(InDefaultColor);
	Parms.InSelectColor = std::move(InSelectColor);
	Parms.InDefaultIndex = InDefaultIndex;
	Parms.UseMoreTabs = UseMoreTabs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceOpenDoorByProgressComp.UpdateOpenDoor_BP
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    NeedOpen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceOpenDoorByProgressComp::UpdateOpenDoor_BP(bool NeedOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceOpenDoorByProgressComp", "UpdateOpenDoor_BP");

	Params::NoceOpenDoorByProgressComp_UpdateOpenDoor_BP Parms{};

	Parms.NeedOpen = NeedOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePageTabWidget.CanSelectNext
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePageTabWidget::CanSelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "CanSelectNext");

	Params::NocePageTabWidget_CanSelectNext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePageTabWidget.CanSelectPrevious
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePageTabWidget::CanSelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "CanSelectPrevious");

	Params::NocePageTabWidget_CanSelectPrevious Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePageTabWidget.GetSelectingIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePageTabWidget::GetSelectingIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "GetSelectingIndex");

	Params::NocePageTabWidget_GetSelectingIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePageTabWidget.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InTotalPage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCurrentPage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePageTabWidget::Init(int32 InTotalPage, int32 InCurrentPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "Init");

	Params::NocePageTabWidget_Init Parms{};

	Parms.InTotalPage = InTotalPage;
	Parms.InCurrentPage = InCurrentPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePageTabWidget.MakeSlotsAndSpacers
// (Final, Native, Protected, BlueprintCallable)

void UNocePageTabWidget::MakeSlotsAndSpacers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "MakeSlotsAndSpacers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePageTabWidget.SelectNext
// (Final, Native, Public, BlueprintCallable)

void UNocePageTabWidget::SelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "SelectNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePageTabWidget.SelectPrevious
// (Final, Native, Public, BlueprintCallable)

void UNocePageTabWidget::SelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePageTabWidget", "SelectPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseListWidget.CreateMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UPauseListObject*>&  ListItems                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   InitIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePauseListWidget::CreateMenu(const TArray<class UPauseListObject*>& ListItems, int32 InitIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListWidget", "CreateMenu");

	Params::NocePauseListWidget_CreateMenu Parms{};

	Parms.ListItems = std::move(ListItems);
	Parms.InitIndex = InitIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseListWidget.GetList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNoceVerticalList*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceVerticalList* UNocePauseListWidget::GetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListWidget", "GetList");

	Params::NocePauseListWidget_GetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePauseListWidget.InitializeList
// (Final, Native, Public, BlueprintCallable)

void UNocePauseListWidget::InitializeList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListWidget", "InitializeList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePauseListWidget.UpdateDescription
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      DescriptionText                                        (Parm, NativeAccessSpecifierPublic)

void UNocePauseListWidget::UpdateDescription(int32 Index_0, const class FText& DescriptionText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePauseListWidget", "UpdateDescription");

	Params::NocePauseListWidget_UpdateDescription Parms{};

	Parms.Index_0 = Index_0;
	Parms.DescriptionText = std::move(DescriptionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePendantLight.EnablePendantLights
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePendantLight::EnablePendantLights(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NocePendantLight", "EnablePendantLights");

	Params::NocePendantLight_EnablePendantLights Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePendantLight.SetLightMaxDistanceFadeRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePendantLight::SetLightMaxDistanceFadeRange(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "SetLightMaxDistanceFadeRange");

	Params::NocePendantLight_SetLightMaxDistanceFadeRange Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePendantLight.SetLightMaxDrawDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANocePendantLight::SetLightMaxDrawDistance(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "SetLightMaxDrawDistance");

	Params::NocePendantLight_SetLightMaxDrawDistance Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePendantLight.GetLightComp
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightComponent* ANocePendantLight::GetLightComp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "GetLightComp");

	Params::NocePendantLight_GetLightComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePendantLight.GetLightMaxDistanceFadeRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePendantLight::GetLightMaxDistanceFadeRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "GetLightMaxDistanceFadeRange");

	Params::NocePendantLight_GetLightMaxDistanceFadeRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePendantLight.GetLightMaxDrawDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePendantLight::GetLightMaxDrawDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "GetLightMaxDrawDistance");

	Params::NocePendantLight_GetLightMaxDrawDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePendantLight.GetSpotLightZOffset
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANocePendantLight::GetSpotLightZOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePendantLight", "GetSpotLightZOffset");

	Params::NocePendantLight_GetSpotLightZOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickMessageWidget.ShowItem
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      InItemID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInventoryType                      InItemType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickMessageWidget::ShowItem(const class FName& InItemID, ENoceInventoryType InItemType, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickMessageWidget", "ShowItem");

	Params::NocePickMessageWidget_ShowItem Parms{};

	Parms.InItemID = InItemID;
	Parms.InItemType = InItemType;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NocePickPreviewImageDialogWidget.OnPageAnimationCompleted
// (Final, Native, Protected)

void UNocePickPreviewImageDialogWidget::OnPageAnimationCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewImageDialogWidget", "OnPageAnimationCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewImageDialogWidget.SelectNext
// (Final, Native, Protected)

void UNocePickPreviewImageDialogWidget::SelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewImageDialogWidget", "SelectNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewImageDialogWidget.SelectPrevious
// (Final, Native, Protected)

void UNocePickPreviewImageDialogWidget::SelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewImageDialogWidget", "SelectPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewWidget.ConsumableSlotChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickPreviewWidget::ConsumableSlotChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "ConsumableSlotChanged");

	Params::NocePickPreviewWidget_ConsumableSlotChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickPreviewWidget.HasPendingItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickPreviewWidget::HasPendingItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "HasPendingItem");

	Params::NocePickPreviewWidget_HasPendingItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickPreviewWidget.HideItem
// (Final, Native, Public, BlueprintCallable)

void UNocePickPreviewWidget::HideItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "HideItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewWidget.OnInventoryPopWindowClose
// (Final, Native, Protected)

void UNocePickPreviewWidget::OnInventoryPopWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "OnInventoryPopWindowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewWidget.OnPageClosed
// (Final, Native, Protected)

void UNocePickPreviewWidget::OnPageClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "OnPageClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewWidget.SetUseForceHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InUseForceHide                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickPreviewWidget::SetUseForceHide(bool InUseForceHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "SetUseForceHide");

	Params::NocePickPreviewWidget_SetUseForceHide Parms{};

	Parms.InUseForceHide = InUseForceHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickPreviewWidget.ShowItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceInventoryType&               Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickPreviewWidget::ShowItem(const ENoceInventoryType& Type, const class FName& ID, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "ShowItem");

	Params::NocePickPreviewWidget_ShowItem Parms{};

	Parms.Type = Type;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NocePickPreviewWidget.ShowSlotChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickPreviewWidget::ShowSlotChanged(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickPreviewWidget", "ShowSlotChanged");

	Params::NocePickPreviewWidget_ShowSlotChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NocePickupsSubsystem.CanGenerateConsumablePickups_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   RequiredTargetCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::CanGenerateConsumablePickups_BP(int32 RequiredTargetCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "CanGenerateConsumablePickups_BP");

	Params::NocePickupsSubsystem_CanGenerateConsumablePickups_BP Parms{};

	Parms.RequiredTargetCount = RequiredTargetCount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.EnableDynamicHelp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::EnableDynamicHelp(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "EnableDynamicHelp");

	Params::NocePickupsSubsystem_EnableDynamicHelp Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.EnableEventHelp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::EnableEventHelp(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "EnableEventHelp");

	Params::NocePickupsSubsystem_EnableEventHelp Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.GenerateEventConsumablePickups
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 InRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::GenerateEventConsumablePickups(const struct FVector& InLocation, const struct FVector2D& InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GenerateEventConsumablePickups");

	Params::NocePickupsSubsystem_GenerateEventConsumablePickups Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRange = std::move(InRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.GenerateEventWeaponPickups
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 InRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::GenerateEventWeaponPickups(const struct FVector& InLocation, const struct FVector2D& InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GenerateEventWeaponPickups");

	Params::NocePickupsSubsystem_GenerateEventWeaponPickups Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRange = std::move(InRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.GeneratePrepRoomPickups
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupsPoint*                InAttachParent                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ANoceInteractableBase>InInteractable                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::GeneratePrepRoomPickups(class ANocePickupsPoint* InAttachParent, TSubclassOf<class ANoceInteractableBase> InInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GeneratePrepRoomPickups");

	Params::NocePickupsSubsystem_GeneratePrepRoomPickups Parms{};

	Parms.InAttachParent = InAttachParent;
	Parms.InInteractable = InInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.HandleOnPickupEventPickups
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANoceInteractableBase*            InPickups                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::HandleOnPickupEventPickups(class ANoceInteractableBase* InPickups)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "HandleOnPickupEventPickups");

	Params::NocePickupsSubsystem_HandleOnPickupEventPickups Parms{};

	Parms.InPickups = InPickups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.IsSaveDataExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupsPoint*                InPickupsPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsSaveDataExist(class ANocePickupsPoint* InPickupsPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsSaveDataExist");

	Params::NocePickupsSubsystem_IsSaveDataExist Parms{};

	Parms.InPickupsPoint = InPickupsPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.OnPickupsDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::OnPickupsDestroyed(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "OnPickupsDestroyed");

	Params::NocePickupsSubsystem_OnPickupsDestroyed Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.OnProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::OnProgressChanged(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "OnProgressChanged");

	Params::NocePickupsSubsystem_OnProgressChanged Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.RegisterSaveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANocePickupsPoint*                InPickupsPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePickupsSubsystem::RegisterSaveData(class ANocePickupsPoint* InPickupsPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "RegisterSaveData");

	Params::NocePickupsSubsystem_RegisterSaveData Parms{};

	Parms.InPickupsPoint = InPickupsPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.RemoveAllEventPickups
// (Final, Native, Public, BlueprintCallable)

void UNocePickupsSubsystem::RemoveAllEventPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "RemoveAllEventPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.RemoveCurrentDynamicPickups
// (Final, Native, Public, BlueprintCallable)

void UNocePickupsSubsystem::RemoveCurrentDynamicPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "RemoveCurrentDynamicPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.SpawnEventConsumablePickupsPoint_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   RequiredTargetCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::SpawnEventConsumablePickupsPoint_BP(int32 RequiredTargetCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "SpawnEventConsumablePickupsPoint_BP");

	Params::NocePickupsSubsystem_SpawnEventConsumablePickupsPoint_BP Parms{};

	Parms.RequiredTargetCount = RequiredTargetCount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.SpawnEventWeaponPickupsPoint_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   RequiredTargetCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::SpawnEventWeaponPickupsPoint_BP(int32 RequiredTargetCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "SpawnEventWeaponPickupsPoint_BP");

	Params::NocePickupsSubsystem_SpawnEventWeaponPickupsPoint_BP Parms{};

	Parms.RequiredTargetCount = RequiredTargetCount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.UpdateCurrentDynamicSubData
// (Final, Native, Public, BlueprintCallable)

void UNocePickupsSubsystem::UpdateCurrentDynamicSubData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "UpdateCurrentDynamicSubData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePickupsSubsystem.CalculateConsumablePrepRoomValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePickupsSubsystem::CalculateConsumablePrepRoomValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "CalculateConsumablePrepRoomValue");

	Params::NocePickupsSubsystem_CalculateConsumablePrepRoomValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.CalculateWeaponPrepRoomValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePickupsSubsystem::CalculateWeaponPrepRoomValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "CalculateWeaponPrepRoomValue");

	Params::NocePickupsSubsystem_CalculateWeaponPrepRoomValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetConsumableDataRowByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNocePickupsConsumableDataRow    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNocePickupsConsumableDataRow UNocePickupsSubsystem::GetConsumableDataRowByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetConsumableDataRowByName");

	Params::NocePickupsSubsystem_GetConsumableDataRowByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetConsumableDataRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePickupsSubsystem::GetConsumableDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetConsumableDataRowNames");

	Params::NocePickupsSubsystem_GetConsumableDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetConsumableGroupTypeByInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ANoceInteractableBase>InInteractable                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENocePickupsConsumableGroupType         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePickupsConsumableGroupType UNocePickupsSubsystem::GetConsumableGroupTypeByInteractable(TSubclassOf<class ANoceInteractableBase> InInteractable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetConsumableGroupTypeByInteractable");

	Params::NocePickupsSubsystem_GetConsumableGroupTypeByInteractable Parms{};

	Parms.InInteractable = InInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetDeployDataByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNocePickupsDeployDataRow        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNocePickupsDeployDataRow UNocePickupsSubsystem::GetDeployDataByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetDeployDataByName");

	Params::NocePickupsSubsystem_GetDeployDataByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetDeployDataRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePickupsSubsystem::GetDeployDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetDeployDataRowNames");

	Params::NocePickupsSubsystem_GetDeployDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetDynamicDataByName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceDynamicPickupsDataRow       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceDynamicPickupsDataRow UNocePickupsSubsystem::GetDynamicDataByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetDynamicDataByName");

	Params::NocePickupsSubsystem_GetDynamicDataByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetDynamicDataRowNames
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePickupsSubsystem::GetDynamicDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetDynamicDataRowNames");

	Params::NocePickupsSubsystem_GetDynamicDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetIsDynamicHelpEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::GetIsDynamicHelpEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetIsDynamicHelpEnabled");

	Params::NocePickupsSubsystem_GetIsDynamicHelpEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetIsEventHelpEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::GetIsEventHelpEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetIsEventHelpEnable");

	Params::NocePickupsSubsystem_GetIsEventHelpEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetWeaponDataRowByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNocePickupsWeaponDataRow        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNocePickupsWeaponDataRow UNocePickupsSubsystem::GetWeaponDataRowByName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetWeaponDataRowByName");

	Params::NocePickupsSubsystem_GetWeaponDataRowByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetWeaponDataRowNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePickupsSubsystem::GetWeaponDataRowNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetWeaponDataRowNames");

	Params::NocePickupsSubsystem_GetWeaponDataRowNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.GetWeaponGroupTypeByInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ANoceInteractableBase>InInteractable                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENocePickupsWeaponGroupType             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENocePickupsWeaponGroupType UNocePickupsSubsystem::GetWeaponGroupTypeByInteractable(TSubclassOf<class ANoceInteractableBase> InInteractable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "GetWeaponGroupTypeByInteractable");

	Params::NocePickupsSubsystem_GetWeaponGroupTypeByInteractable Parms{};

	Parms.InInteractable = InInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.IsInConsumableSearchDistance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsInConsumableSearchDistance(class AActor* InActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsInConsumableSearchDistance");

	Params::NocePickupsSubsystem_IsInConsumableSearchDistance Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.IsInWeaponSearchDistance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsInWeaponSearchDistance(class AActor* InActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsInWeaponSearchDistance");

	Params::NocePickupsSubsystem_IsInWeaponSearchDistance Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.IsTargetConsumableByClass
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ANoceInteractableBase>InInteractable                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsTargetConsumableByClass(TSubclassOf<class ANoceInteractableBase> InInteractable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsTargetConsumableByClass");

	Params::NocePickupsSubsystem_IsTargetConsumableByClass Parms{};

	Parms.InInteractable = InInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.IsTargetPickups
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANocePickupConsumable*            InConsumable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsTargetPickups(class ANocePickupConsumable* InConsumable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsTargetPickups");

	Params::NocePickupsSubsystem_IsTargetPickups Parms{};

	Parms.InConsumable = InConsumable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePickupsSubsystem.IsUnseenDynamicPickupsPoint
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANocePickupsPoint*                InPickupsPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePickupsSubsystem::IsUnseenDynamicPickupsPoint(class ANocePickupsPoint* InPickupsPoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePickupsSubsystem", "IsUnseenDynamicPickupsPoint");

	Params::NocePickupsSubsystem_IsUnseenDynamicPickupsPoint Parms{};

	Parms.InPickupsPoint = InPickupsPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.BP_GetSlopeBlendRatio
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::BP_GetSlopeBlendRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "BP_GetSlopeBlendRatio");

	Params::NocePlayerAnimInstance_BP_GetSlopeBlendRatio Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.CanApplyArmCorrect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::CanApplyArmCorrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "CanApplyArmCorrect");

	Params::NocePlayerAnimInstance_CanApplyArmCorrect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.ClearDelayResetGlawG_ABP_RatioTimer
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerAnimInstance::ClearDelayResetGlawG_ABP_RatioTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "ClearDelayResetGlawG_ABP_RatioTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.DelayResetGlawG_ABP_Ratio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDelayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::DelayResetGlawG_ABP_Ratio(float InDelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "DelayResetGlawG_ABP_Ratio");

	Params::NocePlayerAnimInstance_DelayResetGlawG_ABP_Ratio Parms{};

	Parms.InDelayTime = InDelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.GetCanEnterAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetCanEnterAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetCanEnterAttack");

	Params::NocePlayerAnimInstance_GetCanEnterAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetCanEnterDodge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetCanEnterDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetCanEnterDodge");

	Params::NocePlayerAnimInstance_GetCanEnterDodge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetFootIKInterpSpeedCurrent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetFootIKInterpSpeedCurrent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetFootIKInterpSpeedCurrent");

	Params::NocePlayerAnimInstance_GetFootIKInterpSpeedCurrent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetHitReactionActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetHitReactionActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetHitReactionActive");

	Params::NocePlayerAnimInstance_GetHitReactionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetHitReactionAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetHitReactionAlpha()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetHitReactionAlpha");

	Params::NocePlayerAnimInstance_GetHitReactionAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetHitReactionTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UNocePlayerAnimInstance::GetHitReactionTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetHitReactionTransform");

	Params::NocePlayerAnimInstance_GetHitReactionTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetInSeamless
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetInSeamless()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetInSeamless");

	Params::NocePlayerAnimInstance_GetInSeamless Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetInteractType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInteractType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInteractType UNocePlayerAnimInstance::GetInteractType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetInteractType");

	Params::NocePlayerAnimInstance_GetInteractType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetIsInAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetIsInAir()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetIsInAir");

	Params::NocePlayerAnimInstance_GetIsInAir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetIsOnSlopeSkirtControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetIsOnSlopeSkirtControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetIsOnSlopeSkirtControl");

	Params::NocePlayerAnimInstance_GetIsOnSlopeSkirtControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetPlayerFSMTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNocePlayerAnimInstance::GetPlayerFSMTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetPlayerFSMTag");

	Params::NocePlayerAnimInstance_GetPlayerFSMTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetPlayerHideFromRecoverIndicator
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetPlayerHideFromRecoverIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetPlayerHideFromRecoverIndicator");

	Params::NocePlayerAnimInstance_GetPlayerHideFromRecoverIndicator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.HandleHitPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InHitPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   AttackDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::HandleHitPoint(const struct FVector& InHitPoint, const struct FVector& AttackDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "HandleHitPoint");

	Params::NocePlayerAnimInstance_HandleHitPoint Parms{};

	Parms.InHitPoint = std::move(InHitPoint);
	Parms.AttackDirection = std::move(AttackDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.IsNarrowMoveInteractType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsNarrowMoveInteractType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsNarrowMoveInteractType");

	Params::NocePlayerAnimInstance_IsNarrowMoveInteractType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsNarrowMoveNormal
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsNarrowMoveNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsNarrowMoveNormal");

	Params::NocePlayerAnimInstance_IsNarrowMoveNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsNarrowMoveShort
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsNarrowMoveShort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsNarrowMoveShort");

	Params::NocePlayerAnimInstance_IsNarrowMoveShort Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsSlopeAdjustmentEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsSlopeAdjustmentEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsSlopeAdjustmentEnable");

	Params::NocePlayerAnimInstance_IsSlopeAdjustmentEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsUFOWeaponFocusAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsUFOWeaponFocusAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsUFOWeaponFocusAttack");

	Params::NocePlayerAnimInstance_IsUFOWeaponFocusAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsUsingKatana
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsUsingKatana()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsUsingKatana");

	Params::NocePlayerAnimInstance_IsUsingKatana Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.OnDelayResetGlawG_ABP_Ratio
// (Final, Native, Public)

void UNocePlayerAnimInstance::OnDelayResetGlawG_ABP_Ratio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "OnDelayResetGlawG_ABP_Ratio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.QueueDodgeState
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerAnimInstance::QueueDodgeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "QueueDodgeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.QueueStaminaState
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerAnimInstance::QueueStaminaState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "QueueStaminaState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.ReplaceSetFurClawGRigidBodyAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::ReplaceSetFurClawGRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "ReplaceSetFurClawGRigidBodyAlpha");

	Params::NocePlayerAnimInstance_ReplaceSetFurClawGRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.ReplaceSetFurClawRigidBodyAlpha
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::ReplaceSetFurClawRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "ReplaceSetFurClawRigidBodyAlpha");

	Params::NocePlayerAnimInstance_ReplaceSetFurClawRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetClawG_ABP_Ratio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetClawG_ABP_Ratio(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetClawG_ABP_Ratio");

	Params::NocePlayerAnimInstance_SetClawG_ABP_Ratio Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetClawG_Switch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetClawG_Switch(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetClawG_Switch");

	Params::NocePlayerAnimInstance_SetClawG_Switch Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetDeathType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceDeathType                          InDeathType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetDeathType(ENoceDeathType InDeathType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetDeathType");

	Params::NocePlayerAnimInstance_SetDeathType Parms{};

	Parms.InDeathType = InDeathType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetFurClawGRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetFurClawGRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetFurClawGRigidBodyAlpha");

	Params::NocePlayerAnimInstance_SetFurClawGRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetFurClawRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetFurClawRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetFurClawRigidBodyAlpha");

	Params::NocePlayerAnimInstance_SetFurClawRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetHairRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetHairRigidBodyAlpha(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetHairRigidBodyAlpha");

	Params::NocePlayerAnimInstance_SetHairRigidBodyAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetJogStartEndBlendTimer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetJogStartEndBlendTimer(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetJogStartEndBlendTimer");

	Params::NocePlayerAnimInstance_SetJogStartEndBlendTimer Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetPlayerHideFromRecoverIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetPlayerHideFromRecoverIndicator(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetPlayerHideFromRecoverIndicator");

	Params::NocePlayerAnimInstance_SetPlayerHideFromRecoverIndicator Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetSeamlessStayInSprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetSeamlessStayInSprint(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetSeamlessStayInSprint");

	Params::NocePlayerAnimInstance_SetSeamlessStayInSprint Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetWeaponMotionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWeaponMotionType                   InWeaponMotionType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetWeaponMotionType(ENoceWeaponMotionType InWeaponMotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetWeaponMotionType");

	Params::NocePlayerAnimInstance_SetWeaponMotionType Parms{};

	Parms.InWeaponMotionType = InWeaponMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.SetWeaponName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::SetWeaponName(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "SetWeaponName");

	Params::NocePlayerAnimInstance_SetWeaponName Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.UpdateHitReaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::UpdateHitReaction(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "UpdateHitReaction");

	Params::NocePlayerAnimInstance_UpdateHitReaction Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.UpdateStateTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerAnimInstance::UpdateStateTag(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "UpdateStateTag");

	Params::NocePlayerAnimInstance_UpdateStateTag Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerAnimInstance.GetClawG_ABP_Ratio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetClawG_ABP_Ratio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetClawG_ABP_Ratio");

	Params::NocePlayerAnimInstance_GetClawG_ABP_Ratio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetClawG_Switch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetClawG_Switch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetClawG_Switch");

	Params::NocePlayerAnimInstance_GetClawG_Switch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetFurClawGRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetFurClawGRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetFurClawGRigidBodyAlpha");

	Params::NocePlayerAnimInstance_GetFurClawGRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetFurClawRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetFurClawRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetFurClawRigidBodyAlpha");

	Params::NocePlayerAnimInstance_GetFurClawRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetHairRigidBodyAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::GetHairRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetHairRigidBodyAlpha");

	Params::NocePlayerAnimInstance_GetHairRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetPlayerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANocePlayerCharacter*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANocePlayerCharacter* UNocePlayerAnimInstance::GetPlayerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetPlayerCharacter");

	Params::NocePlayerAnimInstance_GetPlayerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetSeamlessStayInSprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::GetSeamlessStayInSprint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetSeamlessStayInSprint");

	Params::NocePlayerAnimInstance_GetSeamlessStayInSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetSeamlessToIdle
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UNocePlayerAnimInstance::GetSeamlessToIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetSeamlessToIdle");

	Params::NocePlayerAnimInstance_GetSeamlessToIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.GetWeaponMotionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceWeaponMotionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWeaponMotionType UNocePlayerAnimInstance::GetWeaponMotionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "GetWeaponMotionType");

	Params::NocePlayerAnimInstance_GetWeaponMotionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.IsDuringChagneWeaponMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerAnimInstance::IsDuringChagneWeaponMotion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "IsDuringChagneWeaponMotion");

	Params::NocePlayerAnimInstance_IsDuringChagneWeaponMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.ReplaceGetFurClawGRigidBodyAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::ReplaceGetFurClawGRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "ReplaceGetFurClawGRigidBodyAlpha");

	Params::NocePlayerAnimInstance_ReplaceGetFurClawGRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerAnimInstance.ReplaceGetFurClawRigidBodyAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerAnimInstance::ReplaceGetFurClawRigidBodyAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerAnimInstance", "ReplaceGetFurClawRigidBodyAlpha");

	Params::NocePlayerAnimInstance_ReplaceGetFurClawRigidBodyAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.ClearUsePlaneConstrain
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerCapsuleShrinkComp::ClearUsePlaneConstrain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "ClearUsePlaneConstrain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.EndCapsuleShrik
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerCapsuleShrinkComp::EndCapsuleShrik()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "EndCapsuleShrik");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerCapsuleShrinkComp::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "HandleOnPossessed");

	Params::NocePlayerCapsuleShrinkComp_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.OnGameplayTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TagExist                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerCapsuleShrinkComp::OnGameplayTagChanged(const struct FGameplayTag& Tag, bool TagExist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "OnGameplayTagChanged");

	Params::NocePlayerCapsuleShrinkComp_OnGameplayTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.TagExist = TagExist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.SetEnableDrawDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerCapsuleShrinkComp::SetEnableDrawDebug(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "SetEnableDrawDebug");

	Params::NocePlayerCapsuleShrinkComp_SetEnableDrawDebug Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.SetEnableHeadPushEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerCapsuleShrinkComp::SetEnableHeadPushEnemy(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "SetEnableHeadPushEnemy");

	Params::NocePlayerCapsuleShrinkComp_SetEnableHeadPushEnemy Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.SetEnableUse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerCapsuleShrinkComp::SetEnableUse(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "SetEnableUse");

	Params::NocePlayerCapsuleShrinkComp_SetEnableUse Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerCapsuleShrinkComp.StartCapsuleShrink
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerCapsuleShrinkComp::StartCapsuleShrink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerCapsuleShrinkComp", "StartCapsuleShrink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerDamageHandleComponent.CanApplyWinceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceWinceType                          InCurrentWinceType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          InNewWinceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerDamageHandleComponent::CanApplyWinceType(ENoceWinceType InCurrentWinceType, ENoceWinceType InNewWinceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerDamageHandleComponent", "CanApplyWinceType");

	Params::NocePlayerDamageHandleComponent_CanApplyWinceType Parms{};

	Parms.InCurrentWinceType = InCurrentWinceType;
	Parms.InNewWinceType = InNewWinceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerDamageHandleComponent.HandleDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHealthDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWinceDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSanityDamage                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStaminaDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSanityDamageToHealthDamageRatio                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsForceWince                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          InWinceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComboName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceDeathType                          DeathType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHealthDamageEffectedByDamageRatio                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InApplyGutsCheck                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsLimitHealth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCheckOmamoriKagami                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCanEndFocus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCheckDamageWinceToAdditive                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWinceType UNocePlayerDamageHandleComponent::HandleDamage(float InHealthDamage, float InWinceDamage, float InMaxSanityDamage, float InStaminaDamage, float InMaxSanityDamageToHealthDamageRatio, bool InIsForceWince, ENoceWinceType InWinceType, class AActor* Attacker, class FName ComboName, ENoceDeathType DeathType, bool InHealthDamageEffectedByDamageRatio, bool InApplyGutsCheck, bool InIsLimitHealth, bool InCheckOmamoriKagami, bool InCanEndFocus, bool InCheckDamageWinceToAdditive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerDamageHandleComponent", "HandleDamage");

	Params::NocePlayerDamageHandleComponent_HandleDamage Parms{};

	Parms.InHealthDamage = InHealthDamage;
	Parms.InWinceDamage = InWinceDamage;
	Parms.InMaxSanityDamage = InMaxSanityDamage;
	Parms.InStaminaDamage = InStaminaDamage;
	Parms.InMaxSanityDamageToHealthDamageRatio = InMaxSanityDamageToHealthDamageRatio;
	Parms.InIsForceWince = InIsForceWince;
	Parms.InWinceType = InWinceType;
	Parms.Attacker = Attacker;
	Parms.ComboName = ComboName;
	Parms.DeathType = DeathType;
	Parms.InHealthDamageEffectedByDamageRatio = InHealthDamageEffectedByDamageRatio;
	Parms.InApplyGutsCheck = InApplyGutsCheck;
	Parms.InIsLimitHealth = InIsLimitHealth;
	Parms.InCheckOmamoriKagami = InCheckOmamoriKagami;
	Parms.InCanEndFocus = InCanEndFocus;
	Parms.InCheckDamageWinceToAdditive = InCheckDamageWinceToAdditive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerDamageHandleComponent.HandleDamageByAttackHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNoceAttackHitResult&      InAttackHitResult                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    InCheckOmamoriKagami                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceWinceType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceWinceType UNocePlayerDamageHandleComponent::HandleDamageByAttackHitResult(const struct FNoceAttackHitResult& InAttackHitResult, bool InCheckOmamoriKagami)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerDamageHandleComponent", "HandleDamageByAttackHitResult");

	Params::NocePlayerDamageHandleComponent_HandleDamageByAttackHitResult Parms{};

	Parms.InAttackHitResult = std::move(InAttackHitResult);
	Parms.InCheckOmamoriKagami = InCheckOmamoriKagami;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerDamageHandleComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerDamageHandleComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerDamageHandleComponent", "HandleOnPossessed");

	Params::NocePlayerDamageHandleComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.AddConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ConsumableActorName                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddConsumable(const class FName ID, const int32 Quantity, const class FName ConsumableActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddConsumable");

	Params::NocePlayerInventoryComponent_AddConsumable Parms{};

	Parms.ID = ID;
	Parms.Quantity = Quantity;
	Parms.ConsumableActorName = ConsumableActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddKeyItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddKeyItem(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddKeyItem");

	Params::NocePlayerInventoryComponent_AddKeyItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddLetter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddLetter(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddLetter");

	Params::NocePlayerInventoryComponent_AddLetter Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddNotebookID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddNotebookID(const class FName ID, const ENoceNotebookType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddNotebookID");

	Params::NocePlayerInventoryComponent_AddNotebookID Parms{};

	Parms.ID = ID;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddOmamori
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddOmamori(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddOmamori");

	Params::NocePlayerInventoryComponent_AddOmamori Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddToViewedItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::AddToViewedItem(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddToViewedItem");

	Params::NocePlayerInventoryComponent_AddToViewedItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.AddToViewedItemInInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::AddToViewedItemInInventory(const class FName ID, ENoceInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddToViewedItemInInventory");

	Params::NocePlayerInventoryComponent_AddToViewedItemInInventory Parms{};

	Parms.ID = ID;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.AddToViewedNotebookID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddToViewedNotebookID(const class FName ID, const ENoceNotebookType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddToViewedNotebookID");

	Params::NocePlayerInventoryComponent_AddToViewedNotebookID Parms{};

	Parms.ID = ID;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.AddUsedItemEma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EmaName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::AddUsedItemEma(class FName EmaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddUsedItemEma");

	Params::NocePlayerInventoryComponent_AddUsedItemEma Parms{};

	Parms.EmaName = EmaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.AddWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Durability                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::AddWeapon(const class FName ID, const float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "AddWeapon");

	Params::NocePlayerInventoryComponent_AddWeapon Parms{};

	Parms.ID = ID;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.CanAddConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::CanAddConsumable(const class FName ID, const int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "CanAddConsumable");

	Params::NocePlayerInventoryComponent_CanAddConsumable Parms{};

	Parms.ID = ID;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.CanAddConsumables
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FNoceInventoryConsumable>&InConsumables                                          (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::CanAddConsumables(const TArray<struct FNoceInventoryConsumable>& InConsumables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "CanAddConsumables");

	Params::NocePlayerInventoryComponent_CanAddConsumables Parms{};

	Parms.InConsumables = std::move(InConsumables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.CanSpawnFaithItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           FaithItemActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::CanSpawnFaithItem(class FName ID, class AActor* FaithItemActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "CanSpawnFaithItem");

	Params::NocePlayerInventoryComponent_CanSpawnFaithItem Parms{};

	Parms.ID = ID;
	Parms.FaithItemActor = FaithItemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.ChangeWeapon
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ChangeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ChangeWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.CheckDLCOmamori
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::CheckDLCOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "CheckDLCOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ClaimDLCOmamori
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ClaimDLCOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ClaimDLCOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ClearLastUseConsumableID
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ClearLastUseConsumableID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ClearLastUseConsumableID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ClearNotShownHintNotebookIDs
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ClearNotShownHintNotebookIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ClearNotShownHintNotebookIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.DiscardWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::DiscardWeapon(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "DiscardWeapon");

	Params::NocePlayerInventoryComponent_DiscardWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.EquipConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::EquipConsumable(const class FName ID, const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "EquipConsumable");

	Params::NocePlayerInventoryComponent_EquipConsumable Parms{};

	Parms.ID = ID;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.EquipOmamori
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::EquipOmamori(const class FName ID, const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "EquipOmamori");

	Params::NocePlayerInventoryComponent_EquipOmamori Parms{};

	Parms.ID = ID;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::EquipWeapon(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "EquipWeapon");

	Params::NocePlayerInventoryComponent_EquipWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ExchangeWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Durability                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::ExchangeWeapon(const int32 Index_0, const class FName ID, const float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ExchangeWeapon");

	Params::NocePlayerInventoryComponent_ExchangeWeapon Parms{};

	Parms.Index_0 = Index_0;
	Parms.ID = ID;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllConsumables
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNoceInventoryConsumable>*OutConsumables                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllConsumables(TArray<struct FNoceInventoryConsumable>* OutConsumables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllConsumables");

	Params::NocePlayerInventoryComponent_GetAllConsumables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConsumables != nullptr)
		*OutConsumables = std::move(Parms.OutConsumables);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllInventoryIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceNotebookType                       NotebookType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePlayerInventoryComponent::GetAllInventoryIDs(ENoceInventoryType InventoryType, ENoceNotebookType NotebookType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllInventoryIDs");

	Params::NocePlayerInventoryComponent_GetAllInventoryIDs Parms{};

	Parms.InventoryType = InventoryType;
	Parms.NotebookType = NotebookType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllKeyItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>*                          OutKeyItems                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllKeyItems(TArray<int32>* OutKeyItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllKeyItems");

	Params::NocePlayerInventoryComponent_GetAllKeyItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeyItems != nullptr)
		*OutKeyItems = std::move(Parms.OutKeyItems);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllLetters
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>*                          OutLetters                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllLetters(TArray<int32>* OutLetters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllLetters");

	Params::NocePlayerInventoryComponent_GetAllLetters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLetters != nullptr)
		*OutLetters = std::move(Parms.OutLetters);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllNotebookIDs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllNotebookIDs(const ENoceNotebookType Type, TArray<class FName>* OutIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllNotebookIDs");

	Params::NocePlayerInventoryComponent_GetAllNotebookIDs Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIDs != nullptr)
		*OutIDs = std::move(Parms.OutIDs);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllOmamories
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNoceInventoryData>*      OutOmamories                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllOmamories(TArray<struct FNoceInventoryData>* OutOmamories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllOmamories");

	Params::NocePlayerInventoryComponent_GetAllOmamories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOmamories != nullptr)
		*OutOmamories = std::move(Parms.OutOmamories);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAllViewedNotebookIDs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetAllViewedNotebookIDs(const ENoceNotebookType Type, TArray<class FName>* OutIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAllViewedNotebookIDs");

	Params::NocePlayerInventoryComponent_GetAllViewedNotebookIDs Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIDs != nullptr)
		*OutIDs = std::move(Parms.OutIDs);
}


// Function GameNoce.NocePlayerInventoryComponent.GetAvailableWeaponNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetAvailableWeaponNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetAvailableWeaponNumber");

	Params::NocePlayerInventoryComponent_GetAvailableWeaponNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetConsumableSlotNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetConsumableSlotNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetConsumableSlotNum");

	Params::NocePlayerInventoryComponent_GetConsumableSlotNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetConsumableTotalNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IDIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetConsumableTotalNum(int32 IDIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetConsumableTotalNum");

	Params::NocePlayerInventoryComponent_GetConsumableTotalNum Parms{};

	Parms.IDIndex = IDIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetCurrentOmamories
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UNocePlayerInventoryComponent::GetCurrentOmamories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetCurrentOmamories");

	Params::NocePlayerInventoryComponent_GetCurrentOmamories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetCurrentWeaponData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFogWeapon                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FNoceInventoryWeapon>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceInventoryWeapon> UNocePlayerInventoryComponent::GetCurrentWeaponData(bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetCurrentWeaponData");

	Params::NocePlayerInventoryComponent_GetCurrentWeaponData Parms{};

	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetCurrentWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetCurrentWeaponIndex(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetCurrentWeaponIndex");

	Params::NocePlayerInventoryComponent_GetCurrentWeaponIndex Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetCurrentWeaponsDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerInventoryComponent::GetCurrentWeaponsDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetCurrentWeaponsDurability");

	Params::NocePlayerInventoryComponent_GetCurrentWeaponsDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetDLCOmamoriID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetDLCOmamoriID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetDLCOmamoriID");

	Params::NocePlayerInventoryComponent_GetDLCOmamoriID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetEquippedOmamories
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNoceInventoryData>*      OutOmamories                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetEquippedOmamories(TArray<struct FNoceInventoryData>* OutOmamories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetEquippedOmamories");

	Params::NocePlayerInventoryComponent_GetEquippedOmamories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOmamories != nullptr)
		*OutOmamories = std::move(Parms.OutOmamories);
}


// Function GameNoce.NocePlayerInventoryComponent.GetEquippedOrTargetWeaponIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetEquippedOrTargetWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetEquippedOrTargetWeaponIndex");

	Params::NocePlayerInventoryComponent_GetEquippedOrTargetWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetEquippedWeaponIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetEquippedWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetEquippedWeaponIndex");

	Params::NocePlayerInventoryComponent_GetEquippedWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetExpandInventoryIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePlayerInventoryComponent::GetExpandInventoryIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetExpandInventoryIDs");

	Params::NocePlayerInventoryComponent_GetExpandInventoryIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetFaithItemIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNocePlayerInventoryComponent::GetFaithItemIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetFaithItemIDs");

	Params::NocePlayerInventoryComponent_GetFaithItemIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetFirstEmaName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetFirstEmaName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetFirstEmaName");

	Params::NocePlayerInventoryComponent_GetFirstEmaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetFirstWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetFirstWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetFirstWeaponIndex");

	Params::NocePlayerInventoryComponent_GetFirstWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetIsTryingToChangeWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::GetIsTryingToChangeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetIsTryingToChangeWeapon");

	Params::NocePlayerInventoryComponent_GetIsTryingToChangeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetIsTryingToUseConsumableItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::GetIsTryingToUseConsumableItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetIsTryingToUseConsumableItem");

	Params::NocePlayerInventoryComponent_GetIsTryingToUseConsumableItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetKatanaWeaponName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetKatanaWeaponName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetKatanaWeaponName");

	Params::NocePlayerInventoryComponent_GetKatanaWeaponName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetKeyItemEmaNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetKeyItemEmaNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetKeyItemEmaNum");

	Params::NocePlayerInventoryComponent_GetKeyItemEmaNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastAdddedInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ENoceInventoryType*                     OutType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetLastAdddedInfo(ENoceInventoryType* OutType, class FName* OutID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastAdddedInfo");

	Params::NocePlayerInventoryComponent_GetLastAdddedInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutType != nullptr)
		*OutType = Parms.OutType;

	if (OutID != nullptr)
		*OutID = Parms.OutID;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastNotebookContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetLastNotebookContent(const ENoceNotebookType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastNotebookContent");

	Params::NocePlayerInventoryComponent_GetLastNotebookContent Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastNotebookNameIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetLastNotebookNameIndex(const ENoceNotebookType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastNotebookNameIndex");

	Params::NocePlayerInventoryComponent_GetLastNotebookNameIndex Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastNotebookType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceNotebookType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceNotebookType UNocePlayerInventoryComponent::GetLastNotebookType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastNotebookType");

	Params::NocePlayerInventoryComponent_GetLastNotebookType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastSelectConsumableIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetLastSelectConsumableIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastSelectConsumableIndex");

	Params::NocePlayerInventoryComponent_GetLastSelectConsumableIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastUseConsumableID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetLastUseConsumableID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastUseConsumableID");

	Params::NocePlayerInventoryComponent_GetLastUseConsumableID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastViewedConsumablesNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetLastViewedConsumablesNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastViewedConsumablesNum");

	Params::NocePlayerInventoryComponent_GetLastViewedConsumablesNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetLastViewedLetterIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetLastViewedLetterIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetLastViewedLetterIndex");

	Params::NocePlayerInventoryComponent_GetLastViewedLetterIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetMaxQuantity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IDIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetMaxQuantity(int32 IDIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetMaxQuantity");

	Params::NocePlayerInventoryComponent_GetMaxQuantity Parms{};

	Parms.IDIndex = IDIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetMaxWeaponNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetMaxWeaponNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetMaxWeaponNumber");

	Params::NocePlayerInventoryComponent_GetMaxWeaponNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetNextAvailableWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetNextAvailableWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetNextAvailableWeaponIndex");

	Params::NocePlayerInventoryComponent_GetNextAvailableWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetNotShownHintNotebookIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FNoceNotebookHintIDData>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceNotebookHintIDData> UNocePlayerInventoryComponent::GetNotShownHintNotebookIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetNotShownHintNotebookIDs");

	Params::NocePlayerInventoryComponent_GetNotShownHintNotebookIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetOmamoriID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIDIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNocePlayerInventoryComponent::GetOmamoriID(int32 InIDIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetOmamoriID");

	Params::NocePlayerInventoryComponent_GetOmamoriID Parms{};

	Parms.InIDIndex = InIDIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetOmamoriSlotNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetOmamoriSlotNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetOmamoriSlotNum");

	Params::NocePlayerInventoryComponent_GetOmamoriSlotNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetShortcutConsumables
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNoceInventoryConsumable>*OutConsumables                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetShortcutConsumables(TArray<struct FNoceInventoryConsumable>* OutConsumables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetShortcutConsumables");

	Params::NocePlayerInventoryComponent_GetShortcutConsumables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConsumables != nullptr)
		*OutConsumables = std::move(Parms.OutConsumables);
}


// Function GameNoce.NocePlayerInventoryComponent.GetTargetWeaponIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNocePlayerInventoryComponent::GetTargetWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetTargetWeaponIndex");

	Params::NocePlayerInventoryComponent_GetTargetWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerInventoryComponent::GetWeaponDurability(const int32 Index_0, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetWeaponDurability");

	Params::NocePlayerInventoryComponent_GetWeaponDurability Parms{};

	Parms.Index_0 = Index_0;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.GetWeaponIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutIsFogWeapon                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::GetWeaponIndex(class FName InID, int32* OutIndex, bool* OutIsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "GetWeaponIndex");

	Params::NocePlayerInventoryComponent_GetWeaponIndex Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	if (OutIsFogWeapon != nullptr)
		*OutIsFogWeapon = Parms.OutIsFogWeapon;
}


// Function GameNoce.NocePlayerInventoryComponent.HandleRecordDataToNextRound
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::HandleRecordDataToNextRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HandleRecordDataToNextRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.HasAnyWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasAnyWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasAnyWeapon");

	Params::NocePlayerInventoryComponent_HasAnyWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasKeyItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasKeyItem(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasKeyItem");

	Params::NocePlayerInventoryComponent_HasKeyItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasLetter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasLetter(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasLetter");

	Params::NocePlayerInventoryComponent_HasLetter Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasNoteShownHintNotebookIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasNoteShownHintNotebookIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasNoteShownHintNotebookIDs");

	Params::NocePlayerInventoryComponent_HasNoteShownHintNotebookIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasOmamori
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasOmamori(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasOmamori");

	Params::NocePlayerInventoryComponent_HasOmamori Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasWeapon(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasWeapon");

	Params::NocePlayerInventoryComponent_HasWeapon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.HasWeaponSafe
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::HasWeaponSafe(const class FName ID, const bool IsFogWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "HasWeaponSafe");

	Params::NocePlayerInventoryComponent_HasWeaponSafe Parms{};

	Parms.ID = ID;
	Parms.IsFogWeapon = IsFogWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsConsumableEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsConsumableEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsConsumableEmpty");

	Params::NocePlayerInventoryComponent_IsConsumableEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsFaithItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsFaithItemType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsFaithItemType");

	Params::NocePlayerInventoryComponent_IsFaithItemType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsInShortcutConsumables
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsInShortcutConsumables(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsInShortcutConsumables");

	Params::NocePlayerInventoryComponent_IsInShortcutConsumables Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsInventoryEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsInventoryEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsInventoryEmpty");

	Params::NocePlayerInventoryComponent_IsInventoryEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsInventoryItemEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceNotebookType                       NotebookType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsInventoryItemEmpty(ENoceInventoryType InventoryType, ENoceNotebookType NotebookType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsInventoryItemEmpty");

	Params::NocePlayerInventoryComponent_IsInventoryItemEmpty Parms{};

	Parms.InventoryType = InventoryType;
	Parms.NotebookType = NotebookType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsItemEmaUsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EmaName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsItemEmaUsed(class FName EmaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsItemEmaUsed");

	Params::NocePlayerInventoryComponent_IsItemEmaUsed Parms{};

	Parms.EmaName = EmaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsKeyItemEma
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsKeyItemEma(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsKeyItemEma");

	Params::NocePlayerInventoryComponent_IsKeyItemEma Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsNewItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceNotebookType                       NotebookType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsNewItem(const class FName ID, ENoceInventoryType InventoryType, ENoceNotebookType NotebookType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsNewItem");

	Params::NocePlayerInventoryComponent_IsNewItem Parms{};

	Parms.ID = ID;
	Parms.InventoryType = InventoryType;
	Parms.NotebookType = NotebookType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsNewItemInInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsNewItemInInventory(const class FName ID, ENoceInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsNewItemInInventory");

	Params::NocePlayerInventoryComponent_IsNewItemInInventory Parms{};

	Parms.ID = ID;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsOmamoriEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsOmamoriEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsOmamoriEmpty");

	Params::NocePlayerInventoryComponent_IsOmamoriEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsSpecifyOmamoriEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsSpecifyOmamoriEquipped(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsSpecifyOmamoriEquipped");

	Params::NocePlayerInventoryComponent_IsSpecifyOmamoriEquipped Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsUseFogWeaponInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsUseFogWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsUseFogWeaponInventory");

	Params::NocePlayerInventoryComponent_IsUseFogWeaponInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.IsWeaponFull
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::IsWeaponFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "IsWeaponFull");

	Params::NocePlayerInventoryComponent_IsWeaponFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              RemovedDueSold                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::RemoveConsumable(const class FName ID, const int32 Quantity, const bool RemovedDueSold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveConsumable");

	Params::NocePlayerInventoryComponent_RemoveConsumable Parms{};

	Parms.ID = ID;
	Parms.Quantity = Quantity;
	Parms.RemovedDueSold = RemovedDueSold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveKeyItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::RemoveKeyItem(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveKeyItem");

	Params::NocePlayerInventoryComponent_RemoveKeyItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveKeyItemEma
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Quantity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::RemoveKeyItemEma(const int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveKeyItemEma");

	Params::NocePlayerInventoryComponent_RemoveKeyItemEma Parms{};

	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveLetter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::RemoveLetter(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveLetter");

	Params::NocePlayerInventoryComponent_RemoveLetter Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveOmamori
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              RemoveViewed                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerInventoryComponent::RemoveOmamori(const class FName ID, const bool RemoveViewed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveOmamori");

	Params::NocePlayerInventoryComponent_RemoveOmamori Parms{};

	Parms.ID = ID;
	Parms.RemoveViewed = RemoveViewed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerInventoryComponent.RemoveViewedItemInInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceInventoryType                      InventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::RemoveViewedItemInInventory(const class FName ID, ENoceInventoryType InventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "RemoveViewedItemInInventory");

	Params::NocePlayerInventoryComponent_RemoveViewedItemInInventory Parms{};

	Parms.ID = ID;
	Parms.InventoryType = InventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ResetConsumableAndShortcut
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ResetConsumableAndShortcut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ResetConsumableAndShortcut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ResetDarkWeaponInventory
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ResetDarkWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ResetDarkWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ResetFogWeaponInventory
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ResetFogWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ResetFogWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ResetInventory
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ResetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ResetInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.ResetWeaponInventory
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::ResetWeaponInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "ResetWeaponInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetConsumableSlotNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewSlotNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetConsumableSlotNum(int32 NewSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetConsumableSlotNum");

	Params::NocePlayerInventoryComponent_SetConsumableSlotNum Parms{};

	Parms.NewSlotNum = NewSlotNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetEquippedWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Durability                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetEquippedWeaponDurability(const class FName ID, const float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetEquippedWeaponDurability");

	Params::NocePlayerInventoryComponent_SetEquippedWeaponDurability Parms{};

	Parms.ID = ID;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetLastNotebookContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       Content                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetLastNotebookContent(const ENoceNotebookType Type, const class FName Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetLastNotebookContent");

	Params::NocePlayerInventoryComponent_SetLastNotebookContent Parms{};

	Parms.Type = Type;
	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetLastNotebookNameIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetLastNotebookNameIndex(const ENoceNotebookType Type, int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetLastNotebookNameIndex");

	Params::NocePlayerInventoryComponent_SetLastNotebookNameIndex Parms{};

	Parms.Type = Type;
	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetLastNotebookType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ENoceNotebookType                 Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetLastNotebookType(const ENoceNotebookType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetLastNotebookType");

	Params::NocePlayerInventoryComponent_SetLastNotebookType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetLastSelectConsumableIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetLastSelectConsumableIndex(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetLastSelectConsumableIndex");

	Params::NocePlayerInventoryComponent_SetLastSelectConsumableIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetLastViewedLetter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetLastViewedLetter(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetLastViewedLetter");

	Params::NocePlayerInventoryComponent_SetLastViewedLetter Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetOmamoriSlotNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewSlotNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetOmamoriSlotNum(int32 NewSlotNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetOmamoriSlotNum");

	Params::NocePlayerInventoryComponent_SetOmamoriSlotNum Parms{};

	Parms.NewSlotNum = NewSlotNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetWeaponDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsFogWeapon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Durability                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetWeaponDurability(const int32 Index_0, const bool IsFogWeapon, const float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetWeaponDurability");

	Params::NocePlayerInventoryComponent_SetWeaponDurability Parms{};

	Parms.Index_0 = Index_0;
	Parms.IsFogWeapon = IsFogWeapon;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.SetWeaponInventoryType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFogWeapon                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AutoEquipIfNeeded                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::SetWeaponInventoryType(bool IsFogWeapon, bool AutoEquipIfNeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "SetWeaponInventoryType");

	Params::NocePlayerInventoryComponent_SetWeaponInventoryType Parms{};

	Parms.IsFogWeapon = IsFogWeapon;
	Parms.AutoEquipIfNeeded = AutoEquipIfNeeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.TransferFaithItemToUsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quanity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::TransferFaithItemToUsed(class FName ID, int32 Quanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "TransferFaithItemToUsed");

	Params::NocePlayerInventoryComponent_TransferFaithItemToUsed Parms{};

	Parms.ID = ID;
	Parms.Quanity = Quanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.TryEquipLastUsedWeapon
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::TryEquipLastUsedWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "TryEquipLastUsedWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.TryToChangeWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::TryToChangeWeapon(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "TryToChangeWeapon");

	Params::NocePlayerInventoryComponent_TryToChangeWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.TryToUseConsumableItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::TryToUseConsumableItem(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "TryToUseConsumableItem");

	Params::NocePlayerInventoryComponent_TryToUseConsumableItem Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UnequipConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UnequipConsumable(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UnequipConsumable");

	Params::NocePlayerInventoryComponent_UnequipConsumable Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UnequipConsumableByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UnequipConsumableByName(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UnequipConsumableByName");

	Params::NocePlayerInventoryComponent_UnequipConsumableByName Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UnEquipCurrentWeapon
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::UnEquipCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UnEquipCurrentWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UnequipOmamori
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UnequipOmamori(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UnequipOmamori");

	Params::NocePlayerInventoryComponent_UnequipOmamori Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UpdateLastViewedConsumablesNum
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerInventoryComponent::UpdateLastViewedConsumablesNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UpdateLastViewedConsumablesNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UpdateOmamoriSlotNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RoundNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UpdateOmamoriSlotNum(int32 RoundNum, int32 SlotSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UpdateOmamoriSlotNum");

	Params::NocePlayerInventoryComponent_UpdateOmamoriSlotNum Parms{};

	Parms.RoundNum = RoundNum;
	Parms.SlotSize = SlotSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UpdateWeaponShouldBeEquipped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UpdateWeaponShouldBeEquipped(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UpdateWeaponShouldBeEquipped");

	Params::NocePlayerInventoryComponent_UpdateWeaponShouldBeEquipped Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerInventoryComponent.UseConsumable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerInventoryComponent::UseConsumable(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerInventoryComponent", "UseConsumable");

	Params::NocePlayerInventoryComponent_UseConsumable Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookAtSubsystem.FindLookAtTargetComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InHeadLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDebugDraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNocePlayerLookAtTargetComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNocePlayerLookAtTargetComponent* UNocePlayerLookAtSubsystem::FindLookAtTargetComponent(const struct FVector& InHeadLocation, bool InDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookAtSubsystem", "FindLookAtTargetComponent");

	Params::NocePlayerLookAtSubsystem_FindLookAtTargetComponent Parms{};

	Parms.InHeadLocation = std::move(InHeadLocation);
	Parms.InDebugDraw = InDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.GetDisableBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerLookTargetComponent::GetDisableBlendTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "GetDisableBlendTime");

	Params::NocePlayerLookTargetComponent_GetDisableBlendTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.GetEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerLookTargetComponent::GetEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "GetEnable");

	Params::NocePlayerLookTargetComponent_GetEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.GetEnableBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerLookTargetComponent::GetEnableBlendTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "GetEnableBlendTime");

	Params::NocePlayerLookTargetComponent_GetEnableBlendTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.GetNeedApplyLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePlayerLookTargetComponent::GetNeedApplyLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "GetNeedApplyLookAt");

	Params::NocePlayerLookTargetComponent_GetNeedApplyLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.GetPreviousLookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNocePlayerLookTargetComponent::GetPreviousLookAtLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "GetPreviousLookAtLocation");

	Params::NocePlayerLookTargetComponent_GetPreviousLookAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerLookTargetComponent.SetDisplaySystemInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookTargetComponent::SetDisplaySystemInfo(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "SetDisplaySystemInfo");

	Params::NocePlayerLookTargetComponent_SetDisplaySystemInfo Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookTargetComponent.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookTargetComponent::SetEnable(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "SetEnable");

	Params::NocePlayerLookTargetComponent_SetEnable Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookTargetComponent.SetLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InLookTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookTargetComponent::SetLookTarget(class AActor* InLookTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "SetLookTarget");

	Params::NocePlayerLookTargetComponent_SetLookTarget Parms{};

	Parms.InLookTarget = InLookTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerLookTargetComponent.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFindLookAtTarget                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerLookTargetComponent::Update(float InDeltaTime, bool InFindLookAtTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerLookTargetComponent", "Update");

	Params::NocePlayerLookTargetComponent_Update Parms{};

	Parms.InDeltaTime = InDeltaTime;
	Parms.InFindLookAtTarget = InFindLookAtTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.AddContinuousDodgeCount
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerStaminaComponent::AddContinuousDodgeCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "AddContinuousDodgeCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.CostStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InStaminaKey                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerStaminaComponent::CostStamina(class FName InStaminaKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "CostStamina");

	Params::NocePlayerStaminaComponent_CostStamina Parms{};

	Parms.InStaminaKey = InStaminaKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.GetStaminaByRowName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNocePlayerStaminaComponent::GetStaminaByRowName(class FName InRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "GetStaminaByRowName");

	Params::NocePlayerStaminaComponent_GetStaminaByRowName Parms{};

	Parms.InRowName = InRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerStaminaComponent.HandleOnPossessed
// (Final, Native, Protected)
// Parameters:
// bool                                    InPossessed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerStaminaComponent::HandleOnPossessed(bool InPossessed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "HandleOnPossessed");

	Params::NocePlayerStaminaComponent_HandleOnPossessed Parms{};

	Parms.InPossessed = InPossessed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.HandleStaminaDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InStaminaDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerStaminaComponent::HandleStaminaDamage(float InStaminaDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "HandleStaminaDamage");

	Params::NocePlayerStaminaComponent_HandleStaminaDamage Parms{};

	Parms.InStaminaDamage = InStaminaDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.OnResetDodgeCountTimerUp
// (Final, Native, Protected)

void UNocePlayerStaminaComponent::OnResetDodgeCountTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "OnResetDodgeCountTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.ResetContinuousDodgeCount
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerStaminaComponent::ResetContinuousDodgeCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "ResetContinuousDodgeCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.ResetStaminaTiredTime
// (Final, Native, Public, BlueprintCallable)

void UNocePlayerStaminaComponent::ResetStaminaTiredTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "ResetStaminaTiredTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerStaminaComponent.UpdateStaminaTiredTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InCostStamina                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePlayerStaminaComponent::UpdateStaminaTiredTime(float InCostStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePlayerStaminaComponent", "UpdateStaminaTiredTime");

	Params::NocePlayerStaminaComponent_UpdateStaminaTiredTime Parms{};

	Parms.InCostStamina = InCostStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePlayerTriggerInterface.GetDebugActiveColor
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor INocePlayerTriggerInterface::GetDebugActiveColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetDebugActiveColor");

	Params::NocePlayerTriggerInterface_GetDebugActiveColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.GetDebugTriggerInfo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString INocePlayerTriggerInterface::GetDebugTriggerInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetDebugTriggerInfo");

	Params::NocePlayerTriggerInterface_GetDebugTriggerInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.GetDebugTriggerTitle
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString INocePlayerTriggerInterface::GetDebugTriggerTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetDebugTriggerTitle");

	Params::NocePlayerTriggerInterface_GetDebugTriggerTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.GetHintboxes
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TArray<class UBoxComponent*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UBoxComponent*> INocePlayerTriggerInterface::GetHintboxes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetHintboxes");

	Params::NocePlayerTriggerInterface_GetHintboxes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.GetHintSphere
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* INocePlayerTriggerInterface::GetHintSphere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetHintSphere");

	Params::NocePlayerTriggerInterface_GetHintSphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.GetTriggerBox
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* INocePlayerTriggerInterface::GetTriggerBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "GetTriggerBox");

	Params::NocePlayerTriggerInterface_GetTriggerBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.IsPlayerOverlapping
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INocePlayerTriggerInterface::IsPlayerOverlapping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "IsPlayerOverlapping");

	Params::NocePlayerTriggerInterface_IsPlayerOverlapping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.IsTriggerAvailable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INocePlayerTriggerInterface::IsTriggerAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "IsTriggerAvailable");

	Params::NocePlayerTriggerInterface_IsTriggerAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePlayerTriggerInterface.IsTriggerEnabled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INocePlayerTriggerInterface::IsTriggerEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NocePlayerTriggerInterface", "IsTriggerEnabled");

	Params::NocePlayerTriggerInterface_IsTriggerEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePopWindowWidget.GetCurrentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUIPopWindowType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceUIPopWindowType UNocePopWindowWidget::GetCurrentType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "GetCurrentType");

	Params::NocePopWindowWidget_GetCurrentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NocePopWindowWidget.OnListMouseConfirm
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::OnListMouseConfirm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "OnListMouseConfirm");

	Params::NocePopWindowWidget_OnListMouseConfirm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.SetDefaultIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::SetDefaultIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "SetDefaultIndex");

	Params::NocePopWindowWidget_SetDefaultIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.SetDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InDialogText                                           (Parm, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::SetDialog(const class FText& InDialogText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "SetDialog");

	Params::NocePopWindowWidget_SetDialog Parms{};

	Parms.InDialogText = std::move(InDialogText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.SetProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InDialogText                                           (Parm, NativeAccessSpecifierPublic)
// const TArray<class FText>&              InButtonTexts                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InButtonActionNames                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::SetProperties(const class FText& InDialogText, const TArray<class FText>& InButtonTexts, const TArray<class FName>& InButtonActionNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "SetProperties");

	Params::NocePopWindowWidget_SetProperties Parms{};

	Parms.InDialogText = std::move(InDialogText);
	Parms.InButtonTexts = std::move(InButtonTexts);
	Parms.InButtonActionNames = std::move(InButtonActionNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FNeoAudioTriggerIdHandle&  InFadeInSound                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<struct FNeoAudioTriggerIdHandle>&InConfirmSound                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FNeoAudioTriggerIdHandle&  InCancelSound                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::SetSound(const struct FNeoAudioTriggerIdHandle& InFadeInSound, const TArray<struct FNeoAudioTriggerIdHandle>& InConfirmSound, const struct FNeoAudioTriggerIdHandle& InCancelSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "SetSound");

	Params::NocePopWindowWidget_SetSound Parms{};

	Parms.InFadeInSound = std::move(InFadeInSound);
	Parms.InConfirmSound = std::move(InConfirmSound);
	Parms.InCancelSound = std::move(InCancelSound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUIPopWindowType                    InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNocePopWindowWidget::SetType(ENoceUIPopWindowType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "SetType");

	Params::NocePopWindowWidget_SetType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NocePopWindowWidget.ShowHpAdd
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AddedHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNocePopWindowWidget::ShowHpAdd(float AddedHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NocePopWindowWidget", "ShowHpAdd");

	Params::NocePopWindowWidget_ShowHpAdd Parms{};

	Parms.AddedHP = AddedHP;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceProfilingActor.BindCmd_ReleaseFPS
// (Final, Native, Static, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceProfilingActor::BindCmd_ReleaseFPS(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceProfilingActor", "BindCmd_ReleaseFPS");

	Params::NoceProfilingActor_BindCmd_ReleaseFPS Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.BindCmd_StartProfiling
// (Final, Native, Static, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceProfilingActor::BindCmd_StartProfiling(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceProfilingActor", "BindCmd_StartProfiling");

	Params::NoceProfilingActor_BindCmd_StartProfiling Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.BindCmd_StopProfiling
// (Final, Native, Static, Public)

void ANoceProfilingActor::BindCmd_StopProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceProfilingActor", "BindCmd_StopProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.GetRobustWorld
// (Final, Native, Static, Public)
// Parameters:
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* ANoceProfilingActor::GetRobustWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceProfilingActor", "GetRobustWorld");

	Params::NoceProfilingActor_GetRobustWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceProfilingActor.IsStartProfiling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceProfilingActor::IsStartProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceProfilingActor", "IsStartProfiling");

	Params::NoceProfilingActor_IsStartProfiling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceProfilingActor.InternalStartProfiling
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bEnableMemInsight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceProfilingActor::InternalStartProfiling(bool bEnableMemInsight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "InternalStartProfiling");

	Params::NoceProfilingActor_InternalStartProfiling Parms{};

	Parms.bEnableMemInsight = bEnableMemInsight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceProfilingActor.InternalStopProfiling
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANoceProfilingActor::InternalStopProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "InternalStopProfiling");

	Params::NoceProfilingActor_InternalStopProfiling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceProfilingActor.StartDefaultProfiling
// (Final, Native, Public, BlueprintCallable)

void ANoceProfilingActor::StartDefaultProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "StartDefaultProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.StartMemProfiling
// (Final, Native, Public, BlueprintCallable)

void ANoceProfilingActor::StartMemProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "StartMemProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.StartProfiling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableMemInsight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceProfilingActor::StartProfiling(bool bEnableMemInsight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "StartProfiling");

	Params::NoceProfilingActor_StartProfiling Parms{};

	Parms.bEnableMemInsight = bEnableMemInsight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.StopProfiling
// (Final, Native, Public, BlueprintCallable)

void ANoceProfilingActor::StopProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "StopProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceProfilingActor.UpdateCPUBoundComp
// (Final, Native, Protected)

void ANoceProfilingActor::UpdateCPUBoundComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceProfilingActor", "UpdateCPUBoundComp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceConsumableWidget.OnRefreshSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceReplaceConsumableWidget::OnRefreshSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceConsumableWidget", "OnRefreshSelection");

	Params::NoceReplaceConsumableWidget_OnRefreshSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceReplaceConsumableWidget.ShowConsumable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InQuantity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PickupActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceReplaceConsumableWidget::ShowConsumable(class FName InID, int32 InQuantity, class AActor* PickupActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceReplaceConsumableWidget", "ShowConsumable");

	Params::NoceReplaceConsumableWidget_ShowConsumable Parms{};

	Parms.InID = InID;
	Parms.InQuantity = InQuantity;
	Parms.PickupActor = PickupActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetApplyOutlineToDropShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetApplyOutlineToDropShadows(const bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetApplyOutlineToDropShadows");

	Params::NoceRichTextBlock_SetApplyOutlineToDropShadows Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetColorAndOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSlateColor&               InValue                                                (ConstParm, Parm, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetColorAndOpacity(const struct FSlateColor& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetColorAndOpacity");

	Params::NoceRichTextBlock_SetColorAndOpacity Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetFontMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InValue                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetFontMaterial(class UMaterialInterface* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetFontMaterial");

	Params::NoceRichTextBlock_SetFontMaterial Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetOutlineBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetOutlineBlur(const int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetOutlineBlur");

	Params::NoceRichTextBlock_SetOutlineBlur Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetOutlineColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetOutlineColor(const struct FLinearColor& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetOutlineColor");

	Params::NoceRichTextBlock_SetOutlineColor Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetOutlineMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InValue                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetOutlineMaterial(class UMaterialInterface* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetOutlineMaterial");

	Params::NoceRichTextBlock_SetOutlineMaterial Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetOutlineSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetOutlineSize(const int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetOutlineSize");

	Params::NoceRichTextBlock_SetOutlineSize Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetSeparateFillAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetSeparateFillAlpha(const bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetSeparateFillAlpha");

	Params::NoceRichTextBlock_SetSeparateFillAlpha Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetShadowColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetShadowColorAndOpacity(const struct FLinearColor& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetShadowColorAndOpacity");

	Params::NoceRichTextBlock_SetShadowColorAndOpacity Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceRichTextBlock.SetShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceRichTextBlock::SetShadowOffset(const struct FVector2D& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceRichTextBlock", "SetShadowOffset");

	Params::NoceRichTextBlock_SetShadowOffset Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanitySpawnVolume.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceSanitySpawnVolume::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnVolume", "OnGameProgressChanged");

	Params::NoceSanitySpawnVolume_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanitySpawnVolume.OnOverlapBegin
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceSanitySpawnVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnVolume", "OnOverlapBegin");

	Params::NoceSanitySpawnVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSanitySpawnVolume.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceSanitySpawnVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSanitySpawnVolume", "OnOverlapEnd");

	Params::NoceSanitySpawnVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavableInterface.RequestCreateRecordDataBP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INoceSavableInterface::RequestCreateRecordDataBP(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceSavableInterface", "RequestCreateRecordDataBP");

	Params::NoceSavableInterface_RequestCreateRecordDataBP Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.SaveLoadUIObject.AnyEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadUIObject::AnyEndingCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadUIObject", "AnyEndingCleared");

	Params::SaveLoadUIObject_AnyEndingCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.SaveLoadUIObject.IsEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadUIObject::IsEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadUIObject", "IsEndingCleared");

	Params::SaveLoadUIObject_IsEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveLoadWidget.CacheGameClearedFlag
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveLoadWidget::CacheGameClearedFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveLoadWidget", "CacheGameClearedFlag");

	Params::NoceSaveLoadWidget_CacheGameClearedFlag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveLoadWidget.IsCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         InCheckEndingType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InEndingClearBit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveLoadWidget::IsCleared(ENoceEndingType InCheckEndingType, int32 InEndingClearBit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveLoadWidget", "IsCleared");

	Params::NoceSaveLoadWidget_IsCleared Parms{};

	Parms.InCheckEndingType = InCheckEndingType;
	Parms.InEndingClearBit = InEndingClearBit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveLoadWidget.ShowLoadGame
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InDisableClearGame                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSaveLoadWidget::ShowLoadGame(bool InDisableClearGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveLoadWidget", "ShowLoadGame");

	Params::NoceSaveLoadWidget_ShowLoadGame Parms{};

	Parms.InDisableClearGame = InDisableClearGame;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceSaveLoadWidget.ShowSaveClearGame
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InCheckFirstTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceEndingType                         InCheckEndingType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSaveLoadWidget::ShowSaveClearGame(bool InCheckFirstTime, ENoceEndingType InCheckEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveLoadWidget", "ShowSaveClearGame");

	Params::NoceSaveLoadWidget_ShowSaveClearGame Parms{};

	Parms.InCheckFirstTime = InCheckFirstTime;
	Parms.InCheckEndingType = InCheckEndingType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSaveLoadWidget.ShowSaveGame
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceSaveLoadWidget::ShowSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSaveLoadWidget", "ShowSaveGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceSavePointUpgradeDataAsset.GetAddOmamoriCosts
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceRoundType                          round                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UNoceSavePointUpgradeDataAsset::GetAddOmamoriCosts(ENoceRoundType round)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointUpgradeDataAsset", "GetAddOmamoriCosts");

	Params::NoceSavePointUpgradeDataAsset_GetAddOmamoriCosts Parms{};

	Parms.round = round;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointUpgradeDataAsset.GetCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          round                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSavePointUpgradeDataAsset::GetCost(ENoceUpgradeType Type, ENoceRoundType round, int32 CurrentLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointUpgradeDataAsset", "GetCost");

	Params::NoceSavePointUpgradeDataAsset_GetCost Parms{};

	Parms.Type = Type;
	Parms.round = round;
	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointUpgradeDataAsset.GetMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceUpgradeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceRoundType                          round                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSavePointUpgradeDataAsset::GetMaxLevel(ENoceUpgradeType Type, ENoceRoundType round)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointUpgradeDataAsset", "GetMaxLevel");

	Params::NoceSavePointUpgradeDataAsset_GetMaxLevel Parms{};

	Parms.Type = Type;
	Parms.round = round;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.CanClaimReward
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::CanClaimReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "CanClaimReward");

	Params::NoceSavePointWidget_CanClaimReward Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.CheckDLCProgressToEnableOffering
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::CheckDLCProgressToEnableOffering(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "CheckDLCProgressToEnableOffering");

	Params::NoceSavePointWidget_CheckDLCProgressToEnableOffering Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceSavePointWidget.CreatePageWidget
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceFocusableWidget**            NewWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::CreatePageWidget(const struct FSoftClassPath& Path, class UNoceFocusableWidget** NewWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "CreatePageWidget");

	Params::NoceSavePointWidget_CreatePageWidget Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewWidget != nullptr)
		*NewWidget = Parms.NewWidget;
}


// Function GameNoce.NoceSavePointWidget.ExecuteObj
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPauseListObject*                 Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::ExecuteObj(class UPauseListObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ExecuteObj");

	Params::NoceSavePointWidget_ExecuteObj Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.GetPauseListObjs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPauseListObject*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UPauseListObject*> UNoceSavePointWidget::GetPauseListObjs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "GetPauseListObjs");

	Params::NoceSavePointWidget_GetPauseListObjs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.IsInPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::IsInPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "IsInPage");

	Params::NoceSavePointWidget_IsInPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.OnListMouseConfirm
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::OnListMouseConfirm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "OnListMouseConfirm");

	Params::NoceSavePointWidget_OnListMouseConfirm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.OnPageClosed
// (Final, Native, Protected)

void UNoceSavePointWidget::OnPageClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "OnPageClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.OnUpdateEmaNum
// (Final, Native, Protected)

void UNoceSavePointWidget::OnUpdateEmaNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "OnUpdateEmaNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.OnUpdateFaithValue
// (Final, Native, Protected)

void UNoceSavePointWidget::OnUpdateFaithValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "OnUpdateFaithValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.PlayTransition
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    IsForward                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::PlayTransition(bool IsForward, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "PlayTransition");

	Params::NoceSavePointWidget_PlayTransition Parms{};

	Parms.IsForward = IsForward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceSavePointWidget.ShowEmaNum
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::ShowEmaNum(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ShowEmaNum");

	Params::NoceSavePointWidget_ShowEmaNum Parms{};

	Parms.IsShow = IsShow;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.ShowFaithValue
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::ShowFaithValue(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ShowFaithValue");

	Params::NoceSavePointWidget_ShowFaithValue Parms{};

	Parms.IsShow = IsShow;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.ToBuyItem
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToBuyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToBuyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToBuyOmamori
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToBuyOmamori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToBuyOmamori");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToClaimReward
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToClaimReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToClaimReward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToClaimRewardBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::ToClaimRewardBP(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToClaimRewardBP");

	Params::NoceSavePointWidget_ToClaimRewardBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceSavePointWidget.ToHeal
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToHealSanity
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToHealSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToHealSanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToPage
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            PageWidgetPath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceFocusableWidget**            PageWidget                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSavePointWidget::ToPage(const struct FSoftClassPath& PageWidgetPath, class UNoceFocusableWidget** PageWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToPage");

	Params::NoceSavePointWidget_ToPage Parms{};

	Parms.PageWidgetPath = std::move(PageWidgetPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PageWidget != nullptr)
		*PageWidget = Parms.PageWidget;
}


// Function GameNoce.NoceSavePointWidget.ToRepairWeapon
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToRepairWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToRepairWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToSaveGame
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToSaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToSellItem
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToSellItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToSellItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.ToSwitchOutfit
// (Final, Native, Protected, BlueprintCallable)

void UNoceSavePointWidget::ToSwitchOutfit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "ToSwitchOutfit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSavePointWidget.UpdateEmaNum
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WithAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::UpdateEmaNum(bool WithAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "UpdateEmaNum");

	Params::NoceSavePointWidget_UpdateEmaNum Parms{};

	Parms.WithAnimation = WithAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSavePointWidget.UpdateFaithValue
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WithAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSavePointWidget::UpdateFaithValue(bool WithAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSavePointWidget", "UpdateFaithValue");

	Params::NoceSavePointWidget_UpdateFaithValue Parms{};

	Parms.WithAnimation = WithAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameNoce.NoceScrollableTextBlock.SetScrollingPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsPaused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceScrollableTextBlock::SetScrollingPaused(bool InIsPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceScrollableTextBlock", "SetScrollingPaused");

	Params::NoceScrollableTextBlock_SetScrollingPaused Parms{};

	Parms.InIsPaused = InIsPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_AudioOutputDevice.DefaultDeviceChanged
// (Final, Native, Public)
// Parameters:
// EAudioDeviceChangedRole                 InRole                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSetting_AudioOutputDevice::DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_AudioOutputDevice", "DefaultDeviceChanged");

	Params::NoceSetting_AudioOutputDevice_DefaultDeviceChanged Parms{};

	Parms.InRole = InRole;
	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_AudioOutputDevice.DeviceAddedOrRemoved
// (Final, Native, Public)
// Parameters:
// const class FString&                    DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSetting_AudioOutputDevice::DeviceAddedOrRemoved(const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_AudioOutputDevice", "DeviceAddedOrRemoved");

	Params::NoceSetting_AudioOutputDevice_DeviceAddedOrRemoved Parms{};

	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_AudioOutputDevice.OnAudioOutputDevicesObtained
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<struct FAudioOutputDeviceInfo>&AvailableDevices                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceSetting_AudioOutputDevice::OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_AudioOutputDevice", "OnAudioOutputDevicesObtained");

	Params::NoceSetting_AudioOutputDevice_OnAudioOutputDevicesObtained Parms{};

	Parms.AvailableDevices = std::move(AvailableDevices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSetting_AudioOutputDevice.OnCompletedDeviceSwap
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FSwapAudioOutputResult&    SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceSetting_AudioOutputDevice::OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSetting_AudioOutputDevice", "OnCompletedDeviceSwap");

	Params::NoceSetting_AudioOutputDevice_OnCompletedDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSpeakerRegister.RegisterSpeaker
// (Final, Native, Public, BlueprintCallable)

void UNoceSpeakerRegister::RegisterSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSpeakerRegister", "RegisterSpeaker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSpeakerRegister.UnregisterSpeaker
// (Final, Native, Public, BlueprintCallable)

void UNoceSpeakerRegister::UnregisterSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSpeakerRegister", "UnregisterSpeaker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceStreamByProgressComp.EnableStreamingFromGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceStreamByProgressComp::EnableStreamingFromGame(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceStreamByProgressComp", "EnableStreamingFromGame");

	Params::NoceStreamByProgressComp_EnableStreamingFromGame Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceStreamByProgressComp.ResetHiddenInGameActors
// (Final, Native, Public, BlueprintCallable)

void UNoceStreamByProgressComp::ResetHiddenInGameActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceStreamByProgressComp", "ResetHiddenInGameActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.ForbitSubtitleForSpecifiedLanguage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InLanguage                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForbit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::ForbitSubtitleForSpecifiedLanguage(const class FString& InLanguage, bool InForbit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "ForbitSubtitleForSpecifiedLanguage");

	Params::NoceSubtitleSubsystem_ForbitSubtitleForSpecifiedLanguage Parms{};

	Parms.InLanguage = std::move(InLanguage);
	Parms.InForbit = InForbit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.GetCanShowSubtitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSubtitleSubsystem::GetCanShowSubtitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "GetCanShowSubtitle");

	Params::NoceSubtitleSubsystem_GetCanShowSubtitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSubtitleSubsystem.OnSettingChanged
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::OnSettingChanged(class UNoceSystemSaveGame* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "OnSettingChanged");

	Params::NoceSubtitleSubsystem_OnSettingChanged Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.OnSystemSaveLoaded
// (Final, Native, Protected)
// Parameters:
// class UNoceSystemSaveGame*              InSystemSave                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::OnSystemSaveLoaded(class UNoceSystemSaveGame* InSystemSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "OnSystemSaveLoaded");

	Params::NoceSubtitleSubsystem_OnSystemSaveLoaded Parms{};

	Parms.InSystemSave = InSystemSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.RemoveAllCinematicNote
// (Final, Native, Public, BlueprintCallable)

void UNoceSubtitleSubsystem::RemoveAllCinematicNote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "RemoveAllCinematicNote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.RemoveAllSubtitle
// (Final, Native, Public, BlueprintCallable)

void UNoceSubtitleSubsystem::RemoveAllSubtitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "RemoveAllSubtitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.RequestCinematicNote
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InSubstitleText                                        (Parm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::RequestCinematicNote(const class FText& InSubstitleText, float InDuration, int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "RequestCinematicNote");

	Params::NoceSubtitleSubsystem_RequestCinematicNote Parms{};

	Parms.InSubstitleText = std::move(InSubstitleText);
	Parms.InDuration = InDuration;
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.RequestSubtitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InSubstitleText                                        (Parm, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENoceSubtitleType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseItalic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AlwaysShow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::RequestSubtitle(const class FText& InSubstitleText, float InDuration, int32 InPriority, ENoceSubtitleType InType, bool UseItalic, bool AlwaysShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "RequestSubtitle");

	Params::NoceSubtitleSubsystem_RequestSubtitle Parms{};

	Parms.InSubstitleText = std::move(InSubstitleText);
	Parms.InDuration = InDuration;
	Parms.InPriority = InPriority;
	Parms.InType = InType;
	Parms.UseItalic = UseItalic;
	Parms.AlwaysShow = AlwaysShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleSubsystem.SetHideSubtitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleSubsystem::SetHideSubtitle(bool InHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleSubsystem", "SetHideSubtitle");

	Params::NoceSubtitleSubsystem_SetHideSubtitle Parms{};

	Parms.InHide = InHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.SetSubtitleBackground
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ENoceGameSettingSubtitleBackground      InBackground                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleWidgetBase::SetSubtitleBackground(ENoceGameSettingSubtitleBackground InBackground)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "SetSubtitleBackground");

	Params::NoceSubtitleWidgetBase_SetSubtitleBackground Parms{};

	Parms.InBackground = InBackground;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.SetSubtitleEmptyLineBP
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleWidgetBase::SetSubtitleEmptyLineBP(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "SetSubtitleEmptyLineBP");

	Params::NoceSubtitleWidgetBase_SetSubtitleEmptyLineBP Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.SetSubtitleLineBP
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Prefix                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      Subtitle                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    HidePrefix                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleWidgetBase::SetSubtitleLineBP(int32 Index_0, const class FText& Prefix, const class FText& Subtitle, bool HidePrefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "SetSubtitleLineBP");

	Params::NoceSubtitleWidgetBase_SetSubtitleLineBP Parms{};

	Parms.Index_0 = Index_0;
	Parms.Prefix = std::move(Prefix);
	Parms.Subtitle = std::move(Subtitle);
	Parms.HidePrefix = HidePrefix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.SetSubtitleType
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ENoceSubtitleType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseItalic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleWidgetBase::SetSubtitleType(ENoceSubtitleType InType, bool UseItalic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "SetSubtitleType");

	Params::NoceSubtitleWidgetBase_SetSubtitleType Parms{};

	Parms.InType = InType;
	Parms.UseItalic = UseItalic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.SetSubtitleVisible
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSubtitleWidgetBase::SetSubtitleVisible(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "SetSubtitleVisible");

	Params::NoceSubtitleWidgetBase_SetSubtitleVisible Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSubtitleWidgetBase.UpdateSetting
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UNoceSystemSaveGame*              Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSubtitleWidgetBase::UpdateSetting(class UNoceSystemSaveGame* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSubtitleWidgetBase", "UpdateSetting");

	Params::NoceSubtitleWidgetBase_UpdateSetting Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetAvailableConsolePresets
// (Final, Native, Static, Public)
// Parameters:
// TArray<ENoceGameSettingPreset>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ENoceGameSettingPreset> UNoceSystemSaveGame::GetAvailableConsolePresets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceSystemSaveGame", "GetAvailableConsolePresets");

	Params::NoceSystemSaveGame_GetAvailableConsolePresets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.AnyEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::AnyEndingCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "AnyEndingCleared");

	Params::NoceSystemSaveGame_AnyEndingCleared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.ApplyConsolePreset
// (Final, Native, Public)

void UNoceSystemSaveGame::ApplyConsolePreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "ApplyConsolePreset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.ApplySettings
// (Final, Native, Public, BlueprintCallable)

void UNoceSystemSaveGame::ApplySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "ApplySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.GetLastEndingType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceEndingType UNoceSystemSaveGame::GetLastEndingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetLastEndingType");

	Params::NoceSystemSaveGame_GetLastEndingType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetTitleCorruptionLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSystemSaveGame::GetTitleCorruptionLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetTitleCorruptionLevel");

	Params::NoceSystemSaveGame_GetTitleCorruptionLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.IsEndingCleared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::IsEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "IsEndingCleared");

	Params::NoceSystemSaveGame_IsEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.SetAudioDynamicRange
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingAudioDynamicRange       Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetAudioDynamicRange(ENoceGameSettingAudioDynamicRange Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetAudioDynamicRange");

	Params::NoceSystemSaveGame_SetAudioDynamicRange Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetAudioProfile
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingAudioProfileType        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetAudioProfile(ENoceGameSettingAudioProfileType Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetAudioProfile");

	Params::NoceSystemSaveGame_SetAudioProfile Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetBGMVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetBGMVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetBGMVolume");

	Params::NoceSystemSaveGame_SetBGMVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetBrightness
// (Final, Native, Public)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetBrightness(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetBrightness");

	Params::NoceSystemSaveGame_SetBrightness Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetCameraSensitivity
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetCameraSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetCameraSensitivity");

	Params::NoceSystemSaveGame_SetCameraSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetColorBlindMode
// (Final, Native, Public)
// Parameters:
// EColorBlindMode                         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetColorBlindMode(EColorBlindMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetColorBlindMode");

	Params::NoceSystemSaveGame_SetColorBlindMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetColorBlindStrength
// (Final, Native, Public)
// Parameters:
// int32                                   InColorBlindStrength                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetColorBlindStrength(int32 InColorBlindStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetColorBlindStrength");

	Params::NoceSystemSaveGame_SetColorBlindStrength Parms{};

	Parms.InColorBlindStrength = InColorBlindStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetContrast
// (Final, Native, Public)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetContrast(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetContrast");

	Params::NoceSystemSaveGame_SetContrast Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetEnableVibration
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetEnableVibration(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetEnableVibration");

	Params::NoceSystemSaveGame_SetEnableVibration Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetEndingCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetEndingCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetEndingCleared");

	Params::NoceSystemSaveGame_SetEndingCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetEndingNotCleared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetEndingNotCleared(ENoceEndingType EndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetEndingNotCleared");

	Params::NoceSystemSaveGame_SetEndingNotCleared Parms{};

	Parms.EndingType = EndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetGamepadControlType
// (Final, Native, Public)
// Parameters:
// ENoceInputGamepadType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetGamepadControlType(ENoceInputGamepadType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetGamepadControlType");

	Params::NoceSystemSaveGame_SetGamepadControlType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetInvertCameraPitchInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetInvertCameraPitchInput(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetInvertCameraPitchInput");

	Params::NoceSystemSaveGame_SetInvertCameraPitchInput Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetInvertCameraYawInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetInvertCameraYawInput(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetInvertCameraYawInput");

	Params::NoceSystemSaveGame_SetInvertCameraYawInput Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetLastEndingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceEndingType                         InEndingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetLastEndingType(ENoceEndingType InEndingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetLastEndingType");

	Params::NoceSystemSaveGame_SetLastEndingType Parms{};

	Parms.InEndingType = InEndingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetMouseCameraSensitivity
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetMouseCameraSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetMouseCameraSensitivity");

	Params::NoceSystemSaveGame_SetMouseCameraSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetOverallVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetOverallVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetOverallVolume");

	Params::NoceSystemSaveGame_SetOverallVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetPendingCulture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    NewCulture                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetPendingCulture(const class FString& NewCulture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetPendingCulture");

	Params::NoceSystemSaveGame_SetPendingCulture Parms{};

	Parms.NewCulture = std::move(NewCulture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceGameSettingPreset                  InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetPreset(ENoceGameSettingPreset InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetPreset");

	Params::NoceSystemSaveGame_SetPreset Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSettingInitialized
// (Final, Native, Public, BlueprintCallable)

void UNoceSystemSaveGame::SetSettingInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSettingInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSFXVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSFXVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSFXVolume");

	Params::NoceSystemSaveGame_SetSFXVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetShowSubtitleNames
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetShowSubtitleNames(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetShowSubtitleNames");

	Params::NoceSystemSaveGame_SetShowSubtitleNames Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetShowSubtitles
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetShowSubtitles(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetShowSubtitles");

	Params::NoceSystemSaveGame_SetShowSubtitles Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSprintToggle
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSprintToggle(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSprintToggle");

	Params::NoceSystemSaveGame_SetSprintToggle Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSubtitleBackground
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingSubtitleBackground      Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSubtitleBackground(ENoceGameSettingSubtitleBackground Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSubtitleBackground");

	Params::NoceSystemSaveGame_SetSubtitleBackground Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSubtitleColor
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingSubtitleColor           Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSubtitleColor(ENoceGameSettingSubtitleColor Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSubtitleColor");

	Params::NoceSystemSaveGame_SetSubtitleColor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSubtitleFont
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingFont                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSubtitleFont(ENoceGameSettingFont Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSubtitleFont");

	Params::NoceSystemSaveGame_SetSubtitleFont Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetSubtitleSize
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingSize                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetSubtitleSize(ENoceGameSettingSize Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetSubtitleSize");

	Params::NoceSystemSaveGame_SetSubtitleSize Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetTitleCorruptionLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceSet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetTitleCorruptionLevel(int32 InLevel, bool ForceSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetTitleCorruptionLevel");

	Params::NoceSystemSaveGame_SetTitleCorruptionLevel Parms{};

	Parms.InLevel = InLevel;
	Parms.ForceSet = ForceSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetTutorialVisibility
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetTutorialVisibility(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetTutorialVisibility");

	Params::NoceSystemSaveGame_SetTutorialVisibility Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetUIFont
// (Final, Native, Public)
// Parameters:
// ENoceGameSettingFont                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetUIFont(ENoceGameSettingFont Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetUIFont");

	Params::NoceSystemSaveGame_SetUIFont Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetUIVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetUIVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetUIVolume");

	Params::NoceSystemSaveGame_SetUIVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetVoiceLanguage
// (Final, Native, Public)
// Parameters:
// ENoceLanguageType                       Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetVoiceLanguage(ENoceLanguageType Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetVoiceLanguage");

	Params::NoceSystemSaveGame_SetVoiceLanguage Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.SetVoiceVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceSystemSaveGame::SetVoiceVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "SetVoiceVolume");

	Params::NoceSystemSaveGame_SetVoiceVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceSystemSaveGame.GetAudioDynamicRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingAudioDynamicRange       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingAudioDynamicRange UNoceSystemSaveGame::GetAudioDynamicRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetAudioDynamicRange");

	Params::NoceSystemSaveGame_GetAudioDynamicRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetAudioProfile
// (Final, Native, Public, Const)
// Parameters:
// ENoceGameSettingAudioProfileType        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingAudioProfileType UNoceSystemSaveGame::GetAudioProfile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetAudioProfile");

	Params::NoceSystemSaveGame_GetAudioProfile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetBGMVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetBGMVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetBGMVolume");

	Params::NoceSystemSaveGame_GetBGMVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetBrightness
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetBrightness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetBrightness");

	Params::NoceSystemSaveGame_GetBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetCameraSensitivity
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetCameraSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetCameraSensitivity");

	Params::NoceSystemSaveGame_GetCameraSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetColorBlindMode
// (Final, Native, Public, Const)
// Parameters:
// EColorBlindMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorBlindMode UNoceSystemSaveGame::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetColorBlindMode");

	Params::NoceSystemSaveGame_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetColorBlindStrength
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNoceSystemSaveGame::GetColorBlindStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetColorBlindStrength");

	Params::NoceSystemSaveGame_GetColorBlindStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetContrast
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetContrast() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetContrast");

	Params::NoceSystemSaveGame_GetContrast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetDefaultConsolePreset
// (Final, Native, Public, Const)
// Parameters:
// ENoceGameSettingPreset                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingPreset UNoceSystemSaveGame::GetDefaultConsolePreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetDefaultConsolePreset");

	Params::NoceSystemSaveGame_GetDefaultConsolePreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetDefaultVoiceLanguage
// (Final, Native, Public, Const)
// Parameters:
// ENoceLanguageType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceLanguageType UNoceSystemSaveGame::GetDefaultVoiceLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetDefaultVoiceLanguage");

	Params::NoceSystemSaveGame_GetDefaultVoiceLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetEnableVibration
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetEnableVibration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetEnableVibration");

	Params::NoceSystemSaveGame_GetEnableVibration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetGamepadControlType
// (Final, Native, Public, Const)
// Parameters:
// ENoceInputGamepadType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceInputGamepadType UNoceSystemSaveGame::GetGamepadControlType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetGamepadControlType");

	Params::NoceSystemSaveGame_GetGamepadControlType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetInvertCameraPitchInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetInvertCameraPitchInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetInvertCameraPitchInput");

	Params::NoceSystemSaveGame_GetInvertCameraPitchInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetInvertCameraYawInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetInvertCameraYawInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetInvertCameraYawInput");

	Params::NoceSystemSaveGame_GetInvertCameraYawInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetLastPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingPreset                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingPreset UNoceSystemSaveGame::GetLastPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetLastPreset");

	Params::NoceSystemSaveGame_GetLastPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetMouseCameraSensitivity
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetMouseCameraSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetMouseCameraSensitivity");

	Params::NoceSystemSaveGame_GetMouseCameraSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetOverallVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetOverallVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetOverallVolume");

	Params::NoceSystemSaveGame_GetOverallVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSFXVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetSFXVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSFXVolume");

	Params::NoceSystemSaveGame_GetSFXVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetShowSubtitleNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetShowSubtitleNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetShowSubtitleNames");

	Params::NoceSystemSaveGame_GetShowSubtitleNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetShowSubtitles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetShowSubtitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetShowSubtitles");

	Params::NoceSystemSaveGame_GetShowSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSprintToggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetSprintToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSprintToggle");

	Params::NoceSystemSaveGame_GetSprintToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSubtitleBackground
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingSubtitleBackground      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingSubtitleBackground UNoceSystemSaveGame::GetSubtitleBackground() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSubtitleBackground");

	Params::NoceSystemSaveGame_GetSubtitleBackground Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSubtitleColor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingSubtitleColor           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingSubtitleColor UNoceSystemSaveGame::GetSubtitleColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSubtitleColor");

	Params::NoceSystemSaveGame_GetSubtitleColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSubtitleFont
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingFont                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingFont UNoceSystemSaveGame::GetSubtitleFont() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSubtitleFont");

	Params::NoceSystemSaveGame_GetSubtitleFont Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetSubtitleSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingSize                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingSize UNoceSystemSaveGame::GetSubtitleSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetSubtitleSize");

	Params::NoceSystemSaveGame_GetSubtitleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetTutorialVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::GetTutorialVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetTutorialVisibility");

	Params::NoceSystemSaveGame_GetTutorialVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetUIFont
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENoceGameSettingFont                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceGameSettingFont UNoceSystemSaveGame::GetUIFont() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetUIFont");

	Params::NoceSystemSaveGame_GetUIFont Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetUIVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetUIVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetUIVolume");

	Params::NoceSystemSaveGame_GetUIVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetVoiceLanguage
// (Final, Native, Public, Const)
// Parameters:
// ENoceLanguageType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENoceLanguageType UNoceSystemSaveGame::GetVoiceLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetVoiceLanguage");

	Params::NoceSystemSaveGame_GetVoiceLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.GetVoiceVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceSystemSaveGame::GetVoiceVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "GetVoiceVolume");

	Params::NoceSystemSaveGame_GetVoiceVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceSystemSaveGame.IsSettingInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceSystemSaveGame::IsSettingInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceSystemSaveGame", "IsSettingInitialized");

	Params::NoceSystemSaveGame_IsSettingInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTentacleSubsystem.GetTentacleClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UNoceTentacleSubsystem::GetTentacleClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "GetTentacleClass");

	Params::NoceTentacleSubsystem_GetTentacleClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTentacleSubsystem.IsTentacleEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTentacleSubsystem::IsTentacleEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "IsTentacleEmpty");

	Params::NoceTentacleSubsystem_IsTentacleEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTentacleSubsystem.OnTentacleExist
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTentacleSubsystem::OnTentacleExist(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "OnTentacleExist");

	Params::NoceTentacleSubsystem_OnTentacleExist Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceTentacleSubsystem.RegisterTentacle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTentacleSubsystem::RegisterTentacle(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "RegisterTentacle");

	Params::NoceTentacleSubsystem_RegisterTentacle Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTentacleSubsystem.RequestTentacleLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RequestActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LinkName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTentacleSubsystem::RequestTentacleLink(class AActor* RequestActor, class AActor* TargetActor, class FName LinkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "RequestTentacleLink");

	Params::NoceTentacleSubsystem_RequestTentacleLink Parms{};

	Parms.RequestActor = RequestActor;
	Parms.TargetActor = TargetActor;
	Parms.LinkName = LinkName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTentacleSubsystem.RequestTentacleLink_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           RequestActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LinkName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTentacleSubsystem::RequestTentacleLink_BP(class AActor* RequestActor, class AActor* TargetActor, class FName LinkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "RequestTentacleLink_BP");

	Params::NoceTentacleSubsystem_RequestTentacleLink_BP Parms{};

	Parms.RequestActor = RequestActor;
	Parms.TargetActor = TargetActor;
	Parms.LinkName = LinkName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceTentacleSubsystem.UnRegisterTentacle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTentacleSubsystem::UnRegisterTentacle(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTentacleSubsystem", "UnRegisterTentacle");

	Params::NoceTentacleSubsystem_UnRegisterTentacle Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTickConditionHandler.Discontinued_BP
// (Event, Public, BlueprintEvent)

void UNoceTickConditionHandler::Discontinued_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickConditionHandler", "Discontinued_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceTickConditionHandler.StopHandleCondition
// (Native, Public, BlueprintCallable)

void UNoceTickConditionHandler::StopHandleCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTickConditionHandler", "StopHandleCondition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeComponent.AddNiagaraComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               InFXSystemComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTimeComponent::AddNiagaraComponent(class UFXSystemComponent* InFXSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "AddNiagaraComponent");

	Params::NoceTimeComponent_AddNiagaraComponent Parms{};

	Parms.InFXSystemComponent = InFXSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeComponent.ApplyHitStopTimeDilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTimeDilation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTimeComponent::ApplyHitStopTimeDilation(float InTimeDilation, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "ApplyHitStopTimeDilation");

	Params::NoceTimeComponent_ApplyHitStopTimeDilation Parms{};

	Parms.InTimeDilation = InTimeDilation;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeComponent.IsDuringHitStopTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceTimeComponent::IsDuringHitStopTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "IsDuringHitStopTimer");

	Params::NoceTimeComponent_IsDuringHitStopTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceTimeComponent.OnHitStopTimerUp
// (Final, Native, Protected)

void UNoceTimeComponent::OnHitStopTimerUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "OnHitStopTimerUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeComponent.OnPlayerEnterEvent
// (Final, Native, Protected)

void UNoceTimeComponent::OnPlayerEnterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "OnPlayerEnterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTimeComponent.RemoveNiagaraComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               InFXSystemComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceTimeComponent::RemoveNiagaraComponent(class UFXSystemComponent* InFXSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTimeComponent", "RemoveNiagaraComponent");

	Params::NoceTimeComponent_RemoveNiagaraComponent Parms{};

	Parms.InFXSystemComponent = InFXSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleGameMode.OnLoadGame
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MapNameToLoad                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTitleGameMode::OnLoadGame(class FName MapNameToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleGameMode", "OnLoadGame");

	Params::NoceTitleGameMode_OnLoadGame Parms{};

	Parms.MapNameToLoad = MapNameToLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleGameMode.OnNewGame
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MapNameToLoad                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTitleGameMode::OnNewGame(class FName MapNameToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleGameMode", "OnNewGame");

	Params::NoceTitleGameMode_OnNewGame Parms{};

	Parms.MapNameToLoad = MapNameToLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleGameMode.UpdateTitleScene
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ENoceEndingType                         EndingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CorruptLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceTitleGameMode::UpdateTitleScene(ENoceEndingType EndingType, int32 CorruptLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleGameMode", "UpdateTitleScene");

	Params::NoceTitleGameMode_UpdateTitleScene Parms{};

	Parms.EndingType = EndingType;
	Parms.CorruptLevel = CorruptLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTitleTextWidget.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InText                                                 (Parm, NativeAccessSpecifierPublic)

void UNoceTitleTextWidget::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTitleTextWidget", "SetText");

	Params::NoceTitleTextWidget_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceTutorialPopWindowWidget.ShowTutorial
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      InTitle                                                (Parm, NativeAccessSpecifierPublic)
// const TArray<struct FNoceUITutorialPopWindowPageData>&InData                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceTutorialPopWindowWidget::ShowTutorial(const class FText& InTitle, const TArray<struct FNoceUITutorialPopWindowPageData>& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceTutorialPopWindowWidget", "ShowTutorial");

	Params::NoceTutorialPopWindowWidget_ShowTutorial Parms{};

	Parms.InTitle = std::move(InTitle);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIActionImage.SetInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIActionImage::SetInputAction(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIActionImage", "SetInputAction");

	Params::NoceUIActionImage_SetInputAction Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIActionImage.UpdateIcon
// (Final, Native, Public, BlueprintCallable)

void UNoceUIActionImage::UpdateIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIActionImage", "UpdateIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIContainerInterface.OnChildMouseDown
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ChildWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply*                     Reply                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void INoceUIContainerInterface::OnChildMouseDown(class UUserWidget* ChildWidget, const struct FPointerEvent& MouseEvent, struct FEventReply* Reply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUIContainerInterface", "OnChildMouseDown");

	Params::NoceUIContainerInterface_OnChildMouseDown Parms{};

	Parms.ChildWidget = ChildWidget;
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reply != nullptr)
		*Reply = std::move(Parms.Reply);
}


// Function GameNoce.NoceUIContainerInterface.OnChildMouseEnter
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ChildWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply*                     Reply                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void INoceUIContainerInterface::OnChildMouseEnter(class UUserWidget* ChildWidget, struct FEventReply* Reply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUIContainerInterface", "OnChildMouseEnter");

	Params::NoceUIContainerInterface_OnChildMouseEnter Parms{};

	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reply != nullptr)
		*Reply = std::move(Parms.Reply);
}


// Function GameNoce.NoceUIContainerInterface.OnChildMouseLeave
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ChildWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply*                     Reply                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void INoceUIContainerInterface::OnChildMouseLeave(class UUserWidget* ChildWidget, struct FEventReply* Reply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUIContainerInterface", "OnChildMouseLeave");

	Params::NoceUIContainerInterface_OnChildMouseLeave Parms{};

	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reply != nullptr)
		*Reply = std::move(Parms.Reply);
}


// Function GameNoce.NoceUIContainerInterface.OnChildMouseUp
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ChildWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply*                     Reply                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void INoceUIContainerInterface::OnChildMouseUp(class UUserWidget* ChildWidget, const struct FPointerEvent& MouseEvent, struct FEventReply* Reply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceUIContainerInterface", "OnChildMouseUp");

	Params::NoceUIContainerInterface_OnChildMouseUp Parms{};

	Parms.ChildWidget = ChildWidget;
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reply != nullptr)
		*Reply = std::move(Parms.Reply);
}


// Function GameNoce.NoceUIAttributeWidgetData.GetHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceUIAttributeWidgetData::GetHealthPercent(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIAttributeWidgetData", "GetHealthPercent");

	Params::NoceUIAttributeWidgetData_GetHealthPercent Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIAttributeWidgetData.GetSanityFlowerNum
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SmallFlowerNum                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIAttributeWidgetData::GetSanityFlowerNum(float InValue, int32* SmallFlowerNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIAttributeWidgetData", "GetSanityFlowerNum");

	Params::NoceUIAttributeWidgetData_GetSanityFlowerNum Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SmallFlowerNum != nullptr)
		*SmallFlowerNum = Parms.SmallFlowerNum;
}


// Function GameNoce.NoceUIAttributeWidgetData.GetStaminaPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceUIAttributeWidgetData::GetStaminaPercent(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIAttributeWidgetData", "GetStaminaPercent");

	Params::NoceUIAttributeWidgetData_GetStaminaPercent Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIDurabilityWidgetData.GetImageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMaxDurabilityNum                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceUIDurabilityImageData       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceUIDurabilityImageData UNoceUIDurabilityWidgetData::GetImageData(int32 InMaxDurabilityNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIDurabilityWidgetData", "GetImageData");

	Params::NoceUIDurabilityWidgetData_GetImageData Parms{};

	Parms.InMaxDurabilityNum = InMaxDurabilityNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIDurabilityWidgetData.GetTextData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDurabilityRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceUIDurabilityWidgetData::GetTextData(float InDurabilityRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIDurabilityWidgetData", "GetTextData");

	Params::NoceUIDurabilityWidgetData_GetTextData Parms{};

	Parms.InDurabilityRatio = InDurabilityRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIChooseSkinWidgetData.GetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENocePlayerOutfit                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceUIChooseSkinData            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceUIChooseSkinData UNoceUIChooseSkinWidgetData::GetData(ENocePlayerOutfit Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIChooseSkinWidgetData", "GetData");

	Params::NoceUIChooseSkinWidgetData_GetData Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.Conv_SoftObjPathToSoftTextureRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FSoftObjectPath&           SoftObjectPath                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UNoceUIFunctionLibrary::Conv_SoftObjPathToSoftTextureRef(const struct FSoftObjectPath& SoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "Conv_SoftObjPathToSoftTextureRef");

	Params::NoceUIFunctionLibrary_Conv_SoftObjPathToSoftTextureRef Parms{};

	Parms.SoftObjectPath = std::move(SoftObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetChapterInfoTableRow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ProgressTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceChapterInfoTableRow         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceChapterInfoTableRow UNoceUIFunctionLibrary::GetChapterInfoTableRow(const struct FGameplayTag& ProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetChapterInfoTableRow");

	Params::NoceUIFunctionLibrary_GetChapterInfoTableRow Parms{};

	Parms.ProgressTag = std::move(ProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetChapterInfoText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ProgressTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceUIFunctionLibrary::GetChapterInfoText(const struct FGameplayTag& ProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetChapterInfoText");

	Params::NoceUIFunctionLibrary_GetChapterInfoText Parms{};

	Parms.ProgressTag = std::move(ProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetChapterTextByType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENoceChapterType                        ChapterType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNoceUIFunctionLibrary::GetChapterTextByType(ENoceChapterType ChapterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetChapterTextByType");

	Params::NoceUIFunctionLibrary_GetChapterTextByType Parms{};

	Parms.ChapterType = ChapterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetGamepadInputImageResource
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FNoceUIInputImageTableRow& InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UNoceUIFunctionLibrary::GetGamepadInputImageResource(const struct FNoceUIInputImageTableRow& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetGamepadInputImageResource");

	Params::NoceUIFunctionLibrary_GetGamepadInputImageResource Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetGuideDataFromHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       InData                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsRight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FNoceUIGuideData>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceUIGuideData> UNoceUIFunctionLibrary::GetGuideDataFromHandle(const struct FDataTableRowHandle& InData, bool IsRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetGuideDataFromHandle");

	Params::NoceUIFunctionLibrary_GetGuideDataFromHandle Parms{};

	Parms.InData = std::move(InData);
	Parms.IsRight = IsRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetInputImageResource
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName&                      InIconName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UNoceUIFunctionLibrary::GetInputImageResource(const class FName& InIconName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetInputImageResource");

	Params::NoceUIFunctionLibrary_GetInputImageResource Parms{};

	Parms.InIconName = InIconName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetLocationInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceLocationInfoTableRow        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceLocationInfoTableRow UNoceUIFunctionLibrary::GetLocationInfo(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetLocationInfo");

	Params::NoceUIFunctionLibrary_GetLocationInfo Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetMissionHint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ProgressTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     AdditionalProgressTag                                  (Parm, NativeAccessSpecifierPublic)
// struct FNoceMissionHintTableRow         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNoceMissionHintTableRow UNoceUIFunctionLibrary::GetMissionHint(const struct FGameplayTag& ProgressTag, const struct FGameplayTagContainer& AdditionalProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetMissionHint");

	Params::NoceUIFunctionLibrary_GetMissionHint Parms{};

	Parms.ProgressTag = std::move(ProgressTag);
	Parms.AdditionalProgressTag = std::move(AdditionalProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetMissionHintsByChapterName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InChapterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FNoceMissionHintTableRow> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FNoceMissionHintTableRow> UNoceUIFunctionLibrary::GetMissionHintsByChapterName(const class FString& InChapterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetMissionHintsByChapterName");

	Params::NoceUIFunctionLibrary_GetMissionHintsByChapterName Parms{};

	Parms.InChapterName = std::move(InChapterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.GetNeedTopDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<bool>&                     IsVisibles                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews                                                 (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NeedTop                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NeedBottom                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIFunctionLibrary::GetNeedTopDown(const TArray<bool>& IsVisibles, const TArray<bool>& IsNews, int32 StartIndex, int32 EndIndex, int32 CurrentIndex, bool* NeedTop, bool* NeedBottom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetNeedTopDown");

	Params::NoceUIFunctionLibrary_GetNeedTopDown Parms{};

	Parms.IsVisibles = std::move(IsVisibles);
	Parms.IsNews = std::move(IsNews);
	Parms.StartIndex = StartIndex;
	Parms.EndIndex = EndIndex;
	Parms.CurrentIndex = CurrentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NeedTop != nullptr)
		*NeedTop = Parms.NeedTop;

	if (NeedBottom != nullptr)
		*NeedBottom = Parms.NeedBottom;
}


// Function GameNoce.NoceUIFunctionLibrary.GetNeedTopDownWithTextCheck
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<bool>&                     IsVisibles                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews                                                 (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FText>&              Texts                                                  (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool*                                   NeedTop                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NeedBottom                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIFunctionLibrary::GetNeedTopDownWithTextCheck(const TArray<bool>& IsVisibles, const TArray<bool>& IsNews, int32 StartIndex, int32 EndIndex, int32 CurrentIndex, const TArray<class FText>& Texts, bool* NeedTop, bool* NeedBottom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetNeedTopDownWithTextCheck");

	Params::NoceUIFunctionLibrary_GetNeedTopDownWithTextCheck Parms{};

	Parms.IsVisibles = std::move(IsVisibles);
	Parms.IsNews = std::move(IsNews);
	Parms.StartIndex = StartIndex;
	Parms.EndIndex = EndIndex;
	Parms.CurrentIndex = CurrentIndex;
	Parms.Texts = std::move(Texts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NeedTop != nullptr)
		*NeedTop = Parms.NeedTop;

	if (NeedBottom != nullptr)
		*NeedBottom = Parms.NeedBottom;
}


// Function GameNoce.NoceUIFunctionLibrary.GetPriorityIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>&                          InIDIndexes                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const int32&                            InIDIndex                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>&                          InPriorities                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const int32&                            InPriority                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutArrayIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIFunctionLibrary::GetPriorityIndex(TArray<int32>& InIDIndexes, const int32& InIDIndex, TArray<int32>& InPriorities, const int32& InPriority, int32* OutArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "GetPriorityIndex");

	Params::NoceUIFunctionLibrary_GetPriorityIndex Parms{};

	Parms.InIDIndexes = std::move(InIDIndexes);
	Parms.InIDIndex = InIDIndex;
	Parms.InPriorities = std::move(InPriorities);
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InIDIndexes = std::move(Parms.InIDIndexes);
	InPriorities = std::move(Parms.InPriorities);

	if (OutArrayIndex != nullptr)
		*OutArrayIndex = Parms.OutArrayIndex;
}


// Function GameNoce.NoceUIFunctionLibrary.IsNewNotebookContent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<bool>&                     IsVisibles                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<bool>&                     IsNews                                                 (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUIFunctionLibrary::IsNewNotebookContent(const TArray<bool>& IsVisibles, const TArray<bool>& IsNews, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "IsNewNotebookContent");

	Params::NoceUIFunctionLibrary_IsNewNotebookContent Parms{};

	Parms.IsVisibles = std::move(IsVisibles);
	Parms.IsNews = std::move(IsNews);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.IsVisibleInHierarchy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUIFunctionLibrary::IsVisibleInHierarchy(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "IsVisibleInHierarchy");

	Params::NoceUIFunctionLibrary_IsVisibleInHierarchy Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIFunctionLibrary.SetImage
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UImage*                           InImage                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InResourceObjectPath                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIFunctionLibrary::SetImage(class UImage* InImage, const struct FSoftObjectPath& InResourceObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "SetImage");

	Params::NoceUIFunctionLibrary_SetImage Parms{};

	Parms.InImage = InImage;
	Parms.InResourceObjectPath = std::move(InResourceObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIFunctionLibrary.SetInputImage
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UImage*                           InImage                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      InIconName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIFunctionLibrary::SetInputImage(class UImage* InImage, const class FName& InIconName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NoceUIFunctionLibrary", "SetInputImage");

	Params::NoceUIFunctionLibrary_SetInputImage Parms{};

	Parms.InImage = InImage;
	Parms.InIconName = InIconName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIGameplayTagMappingImage.SetColorByKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIGameplayTagMappingImage::SetColorByKey(const struct FGameplayTag& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIGameplayTagMappingImage", "SetColorByKey");

	Params::NoceUIGameplayTagMappingImage_SetColorByKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIGameplayTagMappingImage.SetImageByKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIGameplayTagMappingImage::SetImageByKey(const struct FGameplayTag& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIGameplayTagMappingImage", "SetImageByKey");

	Params::NoceUIGameplayTagMappingImage_SetImageByKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIGameplayTagMappingImage.SetImageIfHasKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     TagContainer                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUIGameplayTagMappingImage::SetImageIfHasKey(const struct FGameplayTagContainer& TagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIGameplayTagMappingImage", "SetImageIfHasKey");

	Params::NoceUIGameplayTagMappingImage_SetImageIfHasKey Parms{};

	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIImage.SetImageTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftObjectPath&           InImageTexture                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIImage::SetImageTexture(const struct FSoftObjectPath& InImageTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIImage", "SetImageTexture");

	Params::NoceUIImage_SetImageTexture Parms{};

	Parms.InImageTexture = std::move(InImageTexture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIInputDirectionHelper.IsLeftRight
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUIInputDirectionHelper::IsLeftRight(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputDirectionHelper", "IsLeftRight");

	Params::NoceUIInputDirectionHelper_IsLeftRight Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIInputDirectionHelper.IsUpDown
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FKey&                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUIInputDirectionHelper::IsUpDown(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputDirectionHelper", "IsUpDown");

	Params::NoceUIInputDirectionHelper_IsUpDown Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUIInputDirectionHelper.SetAnalogValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      Key                                                    (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIInputDirectionHelper::SetAnalogValue(const struct FKey& Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputDirectionHelper", "SetAnalogValue");

	Params::NoceUIInputDirectionHelper_SetAnalogValue Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIInputDirectionHelper.SetupKeys
// (Final, Native, Public, BlueprintCallable)

void UNoceUIInputDirectionHelper::SetupKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIInputDirectionHelper", "SetupKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKBActionImage.SetInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIKBActionImage::SetInputAction(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKBActionImage", "SetInputAction");

	Params::NoceUIKBActionImage_SetInputAction Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKBActionImage.UpdateIcon
// (Final, Native, Public, BlueprintCallable)

void UNoceUIKBActionImage::UpdateIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKBActionImage", "UpdateIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKeyMappingImage.SetDefaultImage
// (Native, Event, Protected, BlueprintEvent)

void UNoceUIKeyMappingImage::SetDefaultImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKeyMappingImage", "SetDefaultImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIKeyMappingImage.SetImageKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIKeyMappingImage::SetImageKey(int32 Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIKeyMappingImage", "SetImageKey");

	Params::NoceUIKeyMappingImage_SetImageKey Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUILockOnTarget.BP_FadeIn
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceUILockOnTarget::BP_FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUILockOnTarget", "BP_FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceUILockOnTarget.BP_FadeOut
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNoceUILockOnTarget::BP_FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUILockOnTarget", "BP_FadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GameNoce.NoceUIMissionSubsystem.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              ProgressTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIMissionSubsystem::OnGameProgressChanged(const struct FGameplayTag& ProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIMissionSubsystem", "OnGameProgressChanged");

	Params::NoceUIMissionSubsystem_OnGameProgressChanged Parms{};

	Parms.ProgressTag = std::move(ProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIMissionSubsystem.OnMissionStart
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InMissionHint                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoceUIMissionSubsystem::OnMissionStart(const class FText& InMissionHint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIMissionSubsystem", "OnMissionStart");

	Params::NoceUIMissionSubsystem_OnMissionStart Parms{};

	Parms.InMissionHint = std::move(InMissionHint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameNoce.NoceUIRestrictionOverlay.BindEvents
// (Final, Native, Public, BlueprintCallable)

void UNoceUIRestrictionOverlay::BindEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIRestrictionOverlay", "BindEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIRestrictionOverlay.OnRestrictionChanged
// (Final, Native, Protected)
// Parameters:
// ENoceUIRestrictionType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAdd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUIRestrictionOverlay::OnRestrictionChanged(ENoceUIRestrictionType InType, bool IsAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIRestrictionOverlay", "OnRestrictionChanged");

	Params::NoceUIRestrictionOverlay_OnRestrictionChanged Parms{};

	Parms.InType = InType;
	Parms.IsAdd = IsAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUIRestrictionOverlay.UnbindEvents
// (Final, Native, Public, BlueprintCallable)

void UNoceUIRestrictionOverlay::UnbindEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUIRestrictionOverlay", "UnbindEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.AddRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUIRestrictionType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::AddRestriction(ENoceUIRestrictionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "AddRestriction");

	Params::NoceUISubsystem_AddRestriction Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.AddWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::AddWidget(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "AddWidget");

	Params::NoceUISubsystem_AddWidget Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.Clear
// (Final, Native, Public, BlueprintCallable)

void UNoceUISubsystem::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.ClearWidgetStack
// (Final, Native, Public, BlueprintCallable)

void UNoceUISubsystem::ClearWidgetStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "ClearWidgetStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.GetTopWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceUISubsystem::GetTopWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "GetTopWidget");

	Params::NoceUISubsystem_GetTopWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.GetWidget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftClassPath&            Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceUISubsystem::GetWidget(class APlayerController* PlayerController, const struct FSoftClassPath& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "GetWidget");

	Params::NoceUISubsystem_GetWidget Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.GetWidgetByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WidgetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UNoceUISubsystem::GetWidgetByName(class APlayerController* PlayerController, class FName WidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "GetWidgetByName");

	Params::NoceUISubsystem_GetWidgetByName Parms{};

	Parms.PlayerController = PlayerController;
	Parms.WidgetName = WidgetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.GetWidgetPathByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             WidgetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftClassPath                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftClassPath UNoceUISubsystem::GetWidgetPathByName(class FName WidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "GetWidgetPathByName");

	Params::NoceUISubsystem_GetWidgetPathByName Parms{};

	Parms.WidgetName = WidgetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.GetWidgetStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UUserWidget*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UUserWidget*> UNoceUISubsystem::GetWidgetStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "GetWidgetStack");

	Params::NoceUISubsystem_GetWidgetStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.HasRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUIRestrictionType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceUISubsystem::HasRestriction(ENoceUIRestrictionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "HasRestriction");

	Params::NoceUISubsystem_HasRestriction Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceUISubsystem.IsWidgetInStack
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsInStack                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget**                     Widget                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::IsWidgetInStack(const struct FSoftClassPath& Path, bool* IsInStack, class UUserWidget** Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "IsWidgetInStack");

	Params::NoceUISubsystem_IsWidgetInStack Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsInStack != nullptr)
		*IsInStack = Parms.IsInStack;

	if (Widget != nullptr)
		*Widget = Parms.Widget;
}


// Function GameNoce.NoceUISubsystem.NotifyInputDeviceChange
// (Final, Native, Public, BlueprintCallable)

void UNoceUISubsystem::NotifyInputDeviceChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "NotifyInputDeviceChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.RemoveCreatedUIWidget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSoftClassPath&            Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::RemoveCreatedUIWidget(const struct FSoftClassPath& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "RemoveCreatedUIWidget");

	Params::NoceUISubsystem_RemoveCreatedUIWidget Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.RemoveRestriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENoceUIRestrictionType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::RemoveRestriction(ENoceUIRestrictionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "RemoveRestriction");

	Params::NoceUISubsystem_RemoveRestriction Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.RemoveWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUISubsystem::RemoveWidget(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "RemoveWidget");

	Params::NoceUISubsystem_RemoveWidget Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUISubsystem.RequestLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FSoftClassPath>&    WidgetPaths                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNoceUISubsystem::RequestLoad(const TArray<struct FSoftClassPath>& WidgetPaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUISubsystem", "RequestLoad");

	Params::NoceUISubsystem_RequestLoad Parms{};

	Parms.WidgetPaths = std::move(WidgetPaths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceUpgradePopResultWidget.ShowResult
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENoceUpgradeType                        InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InEmaName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceUpgradePopResultWidget::ShowResult(ENoceUpgradeType InType, class FName InEmaName, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceUpgradePopResultWidget", "ShowResult");

	Params::NoceUpgradePopResultWidget_ShowResult Parms{};

	Parms.InType = InType;
	Parms.InEmaName = InEmaName;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function GameNoce.NoceVerticalGrid.SetNumItemsPerLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceVerticalGrid::SetNumItemsPerLine(int32 InNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceVerticalGrid", "SetNumItemsPerLine");

	Params::NoceVerticalGrid_SetNumItemsPerLine Parms{};

	Parms.InNumber = InNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWalkToComponentInterface.GetIsRunTo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceWalkToComponentInterface::GetIsRunTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceWalkToComponentInterface", "GetIsRunTo");

	Params::NoceWalkToComponentInterface_GetIsRunTo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWalkToComponentInterface.GetIsWalkTo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceWalkToComponentInterface::GetIsWalkTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceWalkToComponentInterface", "GetIsWalkTo");

	Params::NoceWalkToComponentInterface_GetIsWalkTo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWalkToComponentInterface.GetIsWalkToWithCameraRotation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool INoceWalkToComponentInterface::GetIsWalkToWithCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("NoceWalkToComponentInterface", "GetIsWalkToWithCameraRotation");

	Params::NoceWalkToComponentInterface_GetIsWalkToWithCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWaveSpawnManager.OnGameProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoceWaveSpawnManager::OnGameProgressChanged(const struct FGameplayTag& NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWaveSpawnManager", "OnGameProgressChanged");

	Params::NoceWaveSpawnManager_OnGameProgressChanged Parms{};

	Parms.NewTag = std::move(NewTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWeaponSubsystem.GetAttackInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurabilityRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutAttackMultiplier                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutExtraAttackMultiplier                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutWinceMultiplier                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWeaponSubsystem::GetAttackInfo(class FName InWeaponName, float InDurabilityRatio, float* OutAttackMultiplier, float* OutExtraAttackMultiplier, float* OutWinceMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetAttackInfo");

	Params::NoceWeaponSubsystem_GetAttackInfo Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDurabilityRatio = InDurabilityRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAttackMultiplier != nullptr)
		*OutAttackMultiplier = Parms.OutAttackMultiplier;

	if (OutExtraAttackMultiplier != nullptr)
		*OutExtraAttackMultiplier = Parms.OutExtraAttackMultiplier;

	if (OutWinceMultiplier != nullptr)
		*OutWinceMultiplier = Parms.OutWinceMultiplier;
}


// Function GameNoce.NoceWeaponSubsystem.GetCanBeBroken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetCanBeBroken(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetCanBeBroken");

	Params::NoceWeaponSubsystem_GetCanBeBroken Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetCanBeBrokenInShiromukuRevive2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetCanBeBrokenInShiromukuRevive2(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetCanBeBrokenInShiromukuRevive2");

	Params::NoceWeaponSubsystem_GetCanBeBrokenInShiromukuRevive2 Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetCanCostDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetCanCostDurability(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetCanCostDurability");

	Params::NoceWeaponSubsystem_GetCanCostDurability Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetCanDiscard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetCanDiscard(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetCanDiscard");

	Params::NoceWeaponSubsystem_GetCanDiscard Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetCanFocusAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetCanFocusAttack(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetCanFocusAttack");

	Params::NoceWeaponSubsystem_GetCanFocusAttack Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetDeflectRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurabilityRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceWeaponSubsystem::GetDeflectRate(class FName InWeaponName, float InDurabilityRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetDeflectRate");

	Params::NoceWeaponSubsystem_GetDeflectRate Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDurabilityRatio = InDurabilityRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetDurabilityUICount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurability                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutUIMaxCount                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutUICount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWeaponSubsystem::GetDurabilityUICount(class FName InWeaponName, float InDurability, int32* OutUIMaxCount, int32* OutUICount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetDurabilityUICount");

	Params::NoceWeaponSubsystem_GetDurabilityUICount Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDurability = InDurability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUIMaxCount != nullptr)
		*OutUIMaxCount = Parms.OutUIMaxCount;

	if (OutUICount != nullptr)
		*OutUICount = Parms.OutUICount;
}


// Function GameNoce.NoceWeaponSubsystem.GetMaxDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceWeaponSubsystem::GetMaxDurability(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetMaxDurability");

	Params::NoceWeaponSubsystem_GetMaxDurability Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetOverrideComboInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InComboName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNoceWeaponInfoOverride*         OutComboInfo                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UNoceWeaponSubsystem::GetOverrideComboInfo(class FName InWeaponName, class FName InComboName, bool* OutFound, struct FNoceWeaponInfoOverride* OutComboInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetOverrideComboInfo");

	Params::NoceWeaponSubsystem_GetOverrideComboInfo Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InComboName = InComboName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = Parms.OutFound;

	if (OutComboInfo != nullptr)
		*OutComboInfo = std::move(Parms.OutComboInfo);
}


// Function GameNoce.NoceWeaponSubsystem.GetOverrideStaminaKeyCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStaminaKey                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutStaminaCost                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWeaponSubsystem::GetOverrideStaminaKeyCost(class FName InWeaponName, class FName InStaminaKey, bool* OutFound, float* OutStaminaCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetOverrideStaminaKeyCost");

	Params::NoceWeaponSubsystem_GetOverrideStaminaKeyCost Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InStaminaKey = InStaminaKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = Parms.OutFound;

	if (OutStaminaCost != nullptr)
		*OutStaminaCost = Parms.OutStaminaCost;
}


// Function GameNoce.NoceWeaponSubsystem.GetUIInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurabilityRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutShowOnUI                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWeaponSubsystem::GetUIInfo(class FName InWeaponName, float InDurabilityRatio, bool* OutShowOnUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetUIInfo");

	Params::NoceWeaponSubsystem_GetUIInfo Parms{};

	Parms.InWeaponName = InWeaponName;
	Parms.InDurabilityRatio = InDurabilityRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShowOnUI != nullptr)
		*OutShowOnUI = Parms.OutShowOnUI;
}


// Function GameNoce.NoceWeaponSubsystem.GetUseFocusAttackWhenFullCharged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWeaponSubsystem::GetUseFocusAttackWhenFullCharged(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetUseFocusAttackWhenFullCharged");

	Params::NoceWeaponSubsystem_GetUseFocusAttackWhenFullCharged Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetWeaponInfoDataAssetByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNoceWeaponInfoDataAsset*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNoceWeaponInfoDataAsset* UNoceWeaponSubsystem::GetWeaponInfoDataAssetByName(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetWeaponInfoDataAssetByName");

	Params::NoceWeaponSubsystem_GetWeaponInfoDataAssetByName Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.GetWeaponQueryName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNoceWeaponSubsystem::GetWeaponQueryName(class FName InWeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "GetWeaponQueryName");

	Params::NoceWeaponSubsystem_GetWeaponQueryName Parms{};

	Parms.InWeaponName = InWeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWeaponSubsystem.SpawnWeaponHandMesh
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InWeaponName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InTransform                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANoceWeapon*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANoceWeapon* UNoceWeaponSubsystem::SpawnWeaponHandMesh(const class UObject* WorldContextObject, class FName InWeaponName, const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWeaponSubsystem", "SpawnWeaponHandMesh");

	Params::NoceWeaponSubsystem_SpawnWeaponHandMesh Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWeaponName = InWeaponName;
	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWepDurabilityWidget.SetDurability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             WeaponName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWepDurabilityWidget::SetDurability(class FName WeaponName, float Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWepDurabilityWidget", "SetDurability");

	Params::NoceWepDurabilityWidget_SetDurability Parms{};

	Parms.WeaponName = WeaponName;
	Parms.Durability = Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWinceDamageReduceComponent.EndWinceDamageReduce
// (Final, Native, Public, BlueprintCallable)

void UNoceWinceDamageReduceComponent::EndWinceDamageReduce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWinceDamageReduceComponent", "EndWinceDamageReduce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWinceDamageReduceComponent.HandleWinceDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsForceWince                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWinceDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceWinceDamageReduceComponent::HandleWinceDamage(bool InIsForceWince, float InWinceDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWinceDamageReduceComponent", "HandleWinceDamage");

	Params::NoceWinceDamageReduceComponent_HandleWinceDamage Parms{};

	Parms.InIsForceWince = InIsForceWince;
	Parms.InWinceDamage = InWinceDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWinceDamageReduceComponent.IsWinceDamageReduce
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNoceWinceDamageReduceComponent::IsWinceDamageReduce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWinceDamageReduceComponent", "IsWinceDamageReduce");

	Params::NoceWinceDamageReduceComponent_IsWinceDamageReduce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceWinceDamageReduceComponent.StartWinceDamageReduce
// (Final, Native, Public, BlueprintCallable)

void UNoceWinceDamageReduceComponent::StartWinceDamageReduce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWinceDamageReduceComponent", "StartWinceDamageReduce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.ClearAllRequestBySetting
// (Final, Native, Public, BlueprintCallable)

void UNoceWorldManagerSubsystem::ClearAllRequestBySetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "ClearAllRequestBySetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.NoceDataLayerTrackUpdateCallback
// (Final, Native, Private)
// Parameters:
// const class UDataLayerInstance*         InDataLayerInstance                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::NoceDataLayerTrackUpdateCallback(const class UDataLayerInstance* InDataLayerInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "NoceDataLayerTrackUpdateCallback");

	Params::NoceWorldManagerSubsystem_NoceDataLayerTrackUpdateCallback Parms{};

	Parms.InDataLayerInstance = InDataLayerInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.PauseWorldTriggerUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::PauseWorldTriggerUpdate(bool InPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "PauseWorldTriggerUpdate");

	Params::NoceWorldManagerSubsystem_PauseWorldTriggerUpdate Parms{};

	Parms.InPause = InPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.RegisterLevelAlarm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::RegisterLevelAlarm(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "RegisterLevelAlarm");

	Params::NoceWorldManagerSubsystem_RegisterLevelAlarm Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.RequestFromWorldTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InDisplayName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataLayerAsset*                  InDataLayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerRuntimeState                  TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DoRequest                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::RequestFromWorldTrigger(class AActor* InTrigger, const class FString& InDisplayName, class UDataLayerAsset* InDataLayer, EDataLayerRuntimeState TargetState, bool DoRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "RequestFromWorldTrigger");

	Params::NoceWorldManagerSubsystem_RequestFromWorldTrigger Parms{};

	Parms.InTrigger = InTrigger;
	Parms.InDisplayName = std::move(InDisplayName);
	Parms.InDataLayer = InDataLayer;
	Parms.TargetState = TargetState;
	Parms.DoRequest = DoRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.RequestGateway
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DoRequest                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::RequestGateway(class FName InRowName, bool DoRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "RequestGateway");

	Params::NoceWorldManagerSubsystem_RequestGateway Parms{};

	Parms.InRowName = InRowName;
	Parms.DoRequest = DoRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.RequestGatewayWithProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InRowName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DoRequest                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ProgressTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::RequestGatewayWithProgress(class FName InRowName, bool DoRequest, const struct FGameplayTag& ProgressTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "RequestGatewayWithProgress");

	Params::NoceWorldManagerSubsystem_RequestGatewayWithProgress Parms{};

	Parms.InRowName = InRowName;
	Parms.DoRequest = DoRequest;
	Parms.ProgressTag = std::move(ProgressTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceWorldManagerSubsystem.UnregisterLevelAlarm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceWorldManagerSubsystem::UnregisterLevelAlarm(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceWorldManagerSubsystem", "UnregisterLevelAlarm");

	Params::NoceWorldManagerSubsystem_UnregisterLevelAlarm Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.PerformanceOptimizerInterface.EnablePerformanceSaving
// (Native, Public)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPerformanceOptimizerInterface::EnablePerformanceSaving(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("PerformanceOptimizerInterface", "EnablePerformanceSaving");

	Params::PerformanceOptimizerInterface_EnablePerformanceSaving Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.PerformanceOptimizerInterface.EnablePerformanceSaving_BP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPerformanceOptimizerInterface::EnablePerformanceSaving_BP(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("PerformanceOptimizerInterface", "EnablePerformanceSaving_BP");

	Params::PerformanceOptimizerInterface_EnablePerformanceSaving_BP Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceColorCorrectionSubsystem.GetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceColorCorrectionSubsystem::GetBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceColorCorrectionSubsystem", "GetBrightness");

	Params::NoceColorCorrectionSubsystem_GetBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceColorCorrectionSubsystem.GetContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoceColorCorrectionSubsystem::GetContrast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceColorCorrectionSubsystem", "GetContrast");

	Params::NoceColorCorrectionSubsystem_GetContrast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameNoce.NoceColorCorrectionSubsystem.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceColorCorrectionSubsystem::SetBrightness(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceColorCorrectionSubsystem", "SetBrightness");

	Params::NoceColorCorrectionSubsystem_SetBrightness Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameNoce.NoceColorCorrectionSubsystem.SetContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoceColorCorrectionSubsystem::SetContrast(float InVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoceColorCorrectionSubsystem", "SetContrast");

	Params::NoceColorCorrectionSubsystem_SetContrast Parms{};

	Parms.InVal = InVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

